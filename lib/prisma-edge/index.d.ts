
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model ScamReport
 * 
 */
export type ScamReport = $Result.DefaultSelection<Prisma.$ScamReportPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Vote
 * 
 */
export type Vote = $Result.DefaultSelection<Prisma.$VotePayload>
/**
 * Model WikiPage
 * 
 */
export type WikiPage = $Result.DefaultSelection<Prisma.$WikiPagePayload>
/**
 * Model SearchCache
 * 
 */
export type SearchCache = $Result.DefaultSelection<Prisma.$SearchCachePayload>
/**
 * Model AIScamReport
 * 
 */
export type AIScamReport = $Result.DefaultSelection<Prisma.$AIScamReportPayload>
/**
 * Model ScamType
 * 
 */
export type ScamType = $Result.DefaultSelection<Prisma.$ScamTypePayload>
/**
 * Model Severity
 * 
 */
export type Severity = $Result.DefaultSelection<Prisma.$SeverityPayload>
/**
 * Model Flag
 * 
 */
export type Flag = $Result.DefaultSelection<Prisma.$FlagPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model OutcomeType
 * 
 */
export type OutcomeType = $Result.DefaultSelection<Prisma.$OutcomeTypePayload>
/**
 * Model EducationPost
 * Educational posts (blog-style) for learning hub
 */
export type EducationPost = $Result.DefaultSelection<Prisma.$EducationPostPayload>
/**
 * Model Tag
 * Tags, shared between posts and contacts
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model PostTag
 * 
 */
export type PostTag = $Result.DefaultSelection<Prisma.$PostTagPayload>
/**
 * Model EducationPostScamType
 * 
 */
export type EducationPostScamType = $Result.DefaultSelection<Prisma.$EducationPostScamTypePayload>
/**
 * Model Contact
 * Community-driven localized contacts (authorities/resources)
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model ContactScamType
 * 
 */
export type ContactScamType = $Result.DefaultSelection<Prisma.$ContactScamTypePayload>
/**
 * Model ContactTag
 * 
 */
export type ContactTag = $Result.DefaultSelection<Prisma.$ContactTagPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const PostStatus: {
  DRAFT: 'DRAFT',
  PUBLISHED: 'PUBLISHED',
  ARCHIVED: 'ARCHIVED'
};

export type PostStatus = (typeof PostStatus)[keyof typeof PostStatus]


export const PostCategory: {
  REPORT_TO_AUTHORITIES: 'REPORT_TO_AUTHORITIES',
  PREVENTION: 'PREVENTION',
  CHECKLIST: 'CHECKLIST',
  RECOVERY: 'RECOVERY',
  NEWS: 'NEWS',
  GUIDE: 'GUIDE'
};

export type PostCategory = (typeof PostCategory)[keyof typeof PostCategory]


export const ContactCategory: {
  AUTHORITY: 'AUTHORITY',
  CONSUMER_PROTECTION: 'CONSUMER_PROTECTION',
  FINANCIAL_REGULATOR: 'FINANCIAL_REGULATOR',
  POLICE: 'POLICE',
  ADVISORY: 'ADVISORY',
  OTHER: 'OTHER'
};

export type ContactCategory = (typeof ContactCategory)[keyof typeof ContactCategory]


export const ContactStatus: {
  DRAFT: 'DRAFT',
  PENDING_REVIEW: 'PENDING_REVIEW',
  PUBLISHED: 'PUBLISHED',
  ARCHIVED: 'ARCHIVED'
};

export type ContactStatus = (typeof ContactStatus)[keyof typeof ContactStatus]

}

export type PostStatus = $Enums.PostStatus

export const PostStatus: typeof $Enums.PostStatus

export type PostCategory = $Enums.PostCategory

export const PostCategory: typeof $Enums.PostCategory

export type ContactCategory = $Enums.ContactCategory

export const ContactCategory: typeof $Enums.ContactCategory

export type ContactStatus = $Enums.ContactStatus

export const ContactStatus: typeof $Enums.ContactStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more ScamReports
 * const scamReports = await prisma.scamReport.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more ScamReports
   * const scamReports = await prisma.scamReport.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.scamReport`: Exposes CRUD operations for the **ScamReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScamReports
    * const scamReports = await prisma.scamReport.findMany()
    * ```
    */
  get scamReport(): Prisma.ScamReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vote`: Exposes CRUD operations for the **Vote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Votes
    * const votes = await prisma.vote.findMany()
    * ```
    */
  get vote(): Prisma.VoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wikiPage`: Exposes CRUD operations for the **WikiPage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WikiPages
    * const wikiPages = await prisma.wikiPage.findMany()
    * ```
    */
  get wikiPage(): Prisma.WikiPageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.searchCache`: Exposes CRUD operations for the **SearchCache** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SearchCaches
    * const searchCaches = await prisma.searchCache.findMany()
    * ```
    */
  get searchCache(): Prisma.SearchCacheDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aIScamReport`: Exposes CRUD operations for the **AIScamReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIScamReports
    * const aIScamReports = await prisma.aIScamReport.findMany()
    * ```
    */
  get aIScamReport(): Prisma.AIScamReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scamType`: Exposes CRUD operations for the **ScamType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScamTypes
    * const scamTypes = await prisma.scamType.findMany()
    * ```
    */
  get scamType(): Prisma.ScamTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.severity`: Exposes CRUD operations for the **Severity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Severities
    * const severities = await prisma.severity.findMany()
    * ```
    */
  get severity(): Prisma.SeverityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.flag`: Exposes CRUD operations for the **Flag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Flags
    * const flags = await prisma.flag.findMany()
    * ```
    */
  get flag(): Prisma.FlagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.outcomeType`: Exposes CRUD operations for the **OutcomeType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OutcomeTypes
    * const outcomeTypes = await prisma.outcomeType.findMany()
    * ```
    */
  get outcomeType(): Prisma.OutcomeTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.educationPost`: Exposes CRUD operations for the **EducationPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EducationPosts
    * const educationPosts = await prisma.educationPost.findMany()
    * ```
    */
  get educationPost(): Prisma.EducationPostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.postTag`: Exposes CRUD operations for the **PostTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostTags
    * const postTags = await prisma.postTag.findMany()
    * ```
    */
  get postTag(): Prisma.PostTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.educationPostScamType`: Exposes CRUD operations for the **EducationPostScamType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EducationPostScamTypes
    * const educationPostScamTypes = await prisma.educationPostScamType.findMany()
    * ```
    */
  get educationPostScamType(): Prisma.EducationPostScamTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactScamType`: Exposes CRUD operations for the **ContactScamType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactScamTypes
    * const contactScamTypes = await prisma.contactScamType.findMany()
    * ```
    */
  get contactScamType(): Prisma.ContactScamTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactTag`: Exposes CRUD operations for the **ContactTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactTags
    * const contactTags = await prisma.contactTag.findMany()
    * ```
    */
  get contactTag(): Prisma.ContactTagDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.13.0
   * Query Engine version: 361e86d0ea4987e9f53a565309b3eed797a6bcbd
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    ScamReport: 'ScamReport',
    Comment: 'Comment',
    Vote: 'Vote',
    WikiPage: 'WikiPage',
    SearchCache: 'SearchCache',
    AIScamReport: 'AIScamReport',
    ScamType: 'ScamType',
    Severity: 'Severity',
    Flag: 'Flag',
    User: 'User',
    Notification: 'Notification',
    OutcomeType: 'OutcomeType',
    EducationPost: 'EducationPost',
    Tag: 'Tag',
    PostTag: 'PostTag',
    EducationPostScamType: 'EducationPostScamType',
    Contact: 'Contact',
    ContactScamType: 'ContactScamType',
    ContactTag: 'ContactTag'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "scamReport" | "comment" | "vote" | "wikiPage" | "searchCache" | "aIScamReport" | "scamType" | "severity" | "flag" | "user" | "notification" | "outcomeType" | "educationPost" | "tag" | "postTag" | "educationPostScamType" | "contact" | "contactScamType" | "contactTag"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      ScamReport: {
        payload: Prisma.$ScamReportPayload<ExtArgs>
        fields: Prisma.ScamReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScamReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScamReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScamReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScamReportPayload>
          }
          findFirst: {
            args: Prisma.ScamReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScamReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScamReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScamReportPayload>
          }
          findMany: {
            args: Prisma.ScamReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScamReportPayload>[]
          }
          create: {
            args: Prisma.ScamReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScamReportPayload>
          }
          createMany: {
            args: Prisma.ScamReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScamReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScamReportPayload>[]
          }
          delete: {
            args: Prisma.ScamReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScamReportPayload>
          }
          update: {
            args: Prisma.ScamReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScamReportPayload>
          }
          deleteMany: {
            args: Prisma.ScamReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScamReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScamReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScamReportPayload>[]
          }
          upsert: {
            args: Prisma.ScamReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScamReportPayload>
          }
          aggregate: {
            args: Prisma.ScamReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScamReport>
          }
          groupBy: {
            args: Prisma.ScamReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScamReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScamReportCountArgs<ExtArgs>
            result: $Utils.Optional<ScamReportCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Vote: {
        payload: Prisma.$VotePayload<ExtArgs>
        fields: Prisma.VoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          findFirst: {
            args: Prisma.VoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          findMany: {
            args: Prisma.VoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>[]
          }
          create: {
            args: Prisma.VoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          createMany: {
            args: Prisma.VoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>[]
          }
          delete: {
            args: Prisma.VoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          update: {
            args: Prisma.VoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          deleteMany: {
            args: Prisma.VoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>[]
          }
          upsert: {
            args: Prisma.VoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VotePayload>
          }
          aggregate: {
            args: Prisma.VoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVote>
          }
          groupBy: {
            args: Prisma.VoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<VoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.VoteCountArgs<ExtArgs>
            result: $Utils.Optional<VoteCountAggregateOutputType> | number
          }
        }
      }
      WikiPage: {
        payload: Prisma.$WikiPagePayload<ExtArgs>
        fields: Prisma.WikiPageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WikiPageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WikiPagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WikiPageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WikiPagePayload>
          }
          findFirst: {
            args: Prisma.WikiPageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WikiPagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WikiPageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WikiPagePayload>
          }
          findMany: {
            args: Prisma.WikiPageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WikiPagePayload>[]
          }
          create: {
            args: Prisma.WikiPageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WikiPagePayload>
          }
          createMany: {
            args: Prisma.WikiPageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WikiPageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WikiPagePayload>[]
          }
          delete: {
            args: Prisma.WikiPageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WikiPagePayload>
          }
          update: {
            args: Prisma.WikiPageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WikiPagePayload>
          }
          deleteMany: {
            args: Prisma.WikiPageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WikiPageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WikiPageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WikiPagePayload>[]
          }
          upsert: {
            args: Prisma.WikiPageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WikiPagePayload>
          }
          aggregate: {
            args: Prisma.WikiPageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWikiPage>
          }
          groupBy: {
            args: Prisma.WikiPageGroupByArgs<ExtArgs>
            result: $Utils.Optional<WikiPageGroupByOutputType>[]
          }
          count: {
            args: Prisma.WikiPageCountArgs<ExtArgs>
            result: $Utils.Optional<WikiPageCountAggregateOutputType> | number
          }
        }
      }
      SearchCache: {
        payload: Prisma.$SearchCachePayload<ExtArgs>
        fields: Prisma.SearchCacheFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SearchCacheFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchCachePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SearchCacheFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchCachePayload>
          }
          findFirst: {
            args: Prisma.SearchCacheFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchCachePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SearchCacheFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchCachePayload>
          }
          findMany: {
            args: Prisma.SearchCacheFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchCachePayload>[]
          }
          create: {
            args: Prisma.SearchCacheCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchCachePayload>
          }
          createMany: {
            args: Prisma.SearchCacheCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SearchCacheCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchCachePayload>[]
          }
          delete: {
            args: Prisma.SearchCacheDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchCachePayload>
          }
          update: {
            args: Prisma.SearchCacheUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchCachePayload>
          }
          deleteMany: {
            args: Prisma.SearchCacheDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SearchCacheUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SearchCacheUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchCachePayload>[]
          }
          upsert: {
            args: Prisma.SearchCacheUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchCachePayload>
          }
          aggregate: {
            args: Prisma.SearchCacheAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSearchCache>
          }
          groupBy: {
            args: Prisma.SearchCacheGroupByArgs<ExtArgs>
            result: $Utils.Optional<SearchCacheGroupByOutputType>[]
          }
          count: {
            args: Prisma.SearchCacheCountArgs<ExtArgs>
            result: $Utils.Optional<SearchCacheCountAggregateOutputType> | number
          }
        }
      }
      AIScamReport: {
        payload: Prisma.$AIScamReportPayload<ExtArgs>
        fields: Prisma.AIScamReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIScamReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIScamReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIScamReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIScamReportPayload>
          }
          findFirst: {
            args: Prisma.AIScamReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIScamReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIScamReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIScamReportPayload>
          }
          findMany: {
            args: Prisma.AIScamReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIScamReportPayload>[]
          }
          create: {
            args: Prisma.AIScamReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIScamReportPayload>
          }
          createMany: {
            args: Prisma.AIScamReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIScamReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIScamReportPayload>[]
          }
          delete: {
            args: Prisma.AIScamReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIScamReportPayload>
          }
          update: {
            args: Prisma.AIScamReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIScamReportPayload>
          }
          deleteMany: {
            args: Prisma.AIScamReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIScamReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AIScamReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIScamReportPayload>[]
          }
          upsert: {
            args: Prisma.AIScamReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIScamReportPayload>
          }
          aggregate: {
            args: Prisma.AIScamReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIScamReport>
          }
          groupBy: {
            args: Prisma.AIScamReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIScamReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIScamReportCountArgs<ExtArgs>
            result: $Utils.Optional<AIScamReportCountAggregateOutputType> | number
          }
        }
      }
      ScamType: {
        payload: Prisma.$ScamTypePayload<ExtArgs>
        fields: Prisma.ScamTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScamTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScamTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScamTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScamTypePayload>
          }
          findFirst: {
            args: Prisma.ScamTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScamTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScamTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScamTypePayload>
          }
          findMany: {
            args: Prisma.ScamTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScamTypePayload>[]
          }
          create: {
            args: Prisma.ScamTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScamTypePayload>
          }
          createMany: {
            args: Prisma.ScamTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScamTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScamTypePayload>[]
          }
          delete: {
            args: Prisma.ScamTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScamTypePayload>
          }
          update: {
            args: Prisma.ScamTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScamTypePayload>
          }
          deleteMany: {
            args: Prisma.ScamTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScamTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScamTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScamTypePayload>[]
          }
          upsert: {
            args: Prisma.ScamTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScamTypePayload>
          }
          aggregate: {
            args: Prisma.ScamTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScamType>
          }
          groupBy: {
            args: Prisma.ScamTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScamTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScamTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ScamTypeCountAggregateOutputType> | number
          }
        }
      }
      Severity: {
        payload: Prisma.$SeverityPayload<ExtArgs>
        fields: Prisma.SeverityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeverityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeverityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeverityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeverityPayload>
          }
          findFirst: {
            args: Prisma.SeverityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeverityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeverityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeverityPayload>
          }
          findMany: {
            args: Prisma.SeverityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeverityPayload>[]
          }
          create: {
            args: Prisma.SeverityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeverityPayload>
          }
          createMany: {
            args: Prisma.SeverityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeverityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeverityPayload>[]
          }
          delete: {
            args: Prisma.SeverityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeverityPayload>
          }
          update: {
            args: Prisma.SeverityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeverityPayload>
          }
          deleteMany: {
            args: Prisma.SeverityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeverityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SeverityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeverityPayload>[]
          }
          upsert: {
            args: Prisma.SeverityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeverityPayload>
          }
          aggregate: {
            args: Prisma.SeverityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeverity>
          }
          groupBy: {
            args: Prisma.SeverityGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeverityGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeverityCountArgs<ExtArgs>
            result: $Utils.Optional<SeverityCountAggregateOutputType> | number
          }
        }
      }
      Flag: {
        payload: Prisma.$FlagPayload<ExtArgs>
        fields: Prisma.FlagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlagPayload>
          }
          findFirst: {
            args: Prisma.FlagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlagPayload>
          }
          findMany: {
            args: Prisma.FlagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlagPayload>[]
          }
          create: {
            args: Prisma.FlagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlagPayload>
          }
          createMany: {
            args: Prisma.FlagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FlagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlagPayload>[]
          }
          delete: {
            args: Prisma.FlagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlagPayload>
          }
          update: {
            args: Prisma.FlagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlagPayload>
          }
          deleteMany: {
            args: Prisma.FlagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FlagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlagPayload>[]
          }
          upsert: {
            args: Prisma.FlagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlagPayload>
          }
          aggregate: {
            args: Prisma.FlagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlag>
          }
          groupBy: {
            args: Prisma.FlagGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlagGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlagCountArgs<ExtArgs>
            result: $Utils.Optional<FlagCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      OutcomeType: {
        payload: Prisma.$OutcomeTypePayload<ExtArgs>
        fields: Prisma.OutcomeTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OutcomeTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutcomeTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OutcomeTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutcomeTypePayload>
          }
          findFirst: {
            args: Prisma.OutcomeTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutcomeTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OutcomeTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutcomeTypePayload>
          }
          findMany: {
            args: Prisma.OutcomeTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutcomeTypePayload>[]
          }
          create: {
            args: Prisma.OutcomeTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutcomeTypePayload>
          }
          createMany: {
            args: Prisma.OutcomeTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OutcomeTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutcomeTypePayload>[]
          }
          delete: {
            args: Prisma.OutcomeTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutcomeTypePayload>
          }
          update: {
            args: Prisma.OutcomeTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutcomeTypePayload>
          }
          deleteMany: {
            args: Prisma.OutcomeTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OutcomeTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OutcomeTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutcomeTypePayload>[]
          }
          upsert: {
            args: Prisma.OutcomeTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutcomeTypePayload>
          }
          aggregate: {
            args: Prisma.OutcomeTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOutcomeType>
          }
          groupBy: {
            args: Prisma.OutcomeTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<OutcomeTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.OutcomeTypeCountArgs<ExtArgs>
            result: $Utils.Optional<OutcomeTypeCountAggregateOutputType> | number
          }
        }
      }
      EducationPost: {
        payload: Prisma.$EducationPostPayload<ExtArgs>
        fields: Prisma.EducationPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EducationPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EducationPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPostPayload>
          }
          findFirst: {
            args: Prisma.EducationPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EducationPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPostPayload>
          }
          findMany: {
            args: Prisma.EducationPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPostPayload>[]
          }
          create: {
            args: Prisma.EducationPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPostPayload>
          }
          createMany: {
            args: Prisma.EducationPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EducationPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPostPayload>[]
          }
          delete: {
            args: Prisma.EducationPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPostPayload>
          }
          update: {
            args: Prisma.EducationPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPostPayload>
          }
          deleteMany: {
            args: Prisma.EducationPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EducationPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EducationPostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPostPayload>[]
          }
          upsert: {
            args: Prisma.EducationPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPostPayload>
          }
          aggregate: {
            args: Prisma.EducationPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEducationPost>
          }
          groupBy: {
            args: Prisma.EducationPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<EducationPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.EducationPostCountArgs<ExtArgs>
            result: $Utils.Optional<EducationPostCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      PostTag: {
        payload: Prisma.$PostTagPayload<ExtArgs>
        fields: Prisma.PostTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          findFirst: {
            args: Prisma.PostTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          findMany: {
            args: Prisma.PostTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>[]
          }
          create: {
            args: Prisma.PostTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          createMany: {
            args: Prisma.PostTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>[]
          }
          delete: {
            args: Prisma.PostTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          update: {
            args: Prisma.PostTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          deleteMany: {
            args: Prisma.PostTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>[]
          }
          upsert: {
            args: Prisma.PostTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostTagPayload>
          }
          aggregate: {
            args: Prisma.PostTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostTag>
          }
          groupBy: {
            args: Prisma.PostTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostTagCountArgs<ExtArgs>
            result: $Utils.Optional<PostTagCountAggregateOutputType> | number
          }
        }
      }
      EducationPostScamType: {
        payload: Prisma.$EducationPostScamTypePayload<ExtArgs>
        fields: Prisma.EducationPostScamTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EducationPostScamTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPostScamTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EducationPostScamTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPostScamTypePayload>
          }
          findFirst: {
            args: Prisma.EducationPostScamTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPostScamTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EducationPostScamTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPostScamTypePayload>
          }
          findMany: {
            args: Prisma.EducationPostScamTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPostScamTypePayload>[]
          }
          create: {
            args: Prisma.EducationPostScamTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPostScamTypePayload>
          }
          createMany: {
            args: Prisma.EducationPostScamTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EducationPostScamTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPostScamTypePayload>[]
          }
          delete: {
            args: Prisma.EducationPostScamTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPostScamTypePayload>
          }
          update: {
            args: Prisma.EducationPostScamTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPostScamTypePayload>
          }
          deleteMany: {
            args: Prisma.EducationPostScamTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EducationPostScamTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EducationPostScamTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPostScamTypePayload>[]
          }
          upsert: {
            args: Prisma.EducationPostScamTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationPostScamTypePayload>
          }
          aggregate: {
            args: Prisma.EducationPostScamTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEducationPostScamType>
          }
          groupBy: {
            args: Prisma.EducationPostScamTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EducationPostScamTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EducationPostScamTypeCountArgs<ExtArgs>
            result: $Utils.Optional<EducationPostScamTypeCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      ContactScamType: {
        payload: Prisma.$ContactScamTypePayload<ExtArgs>
        fields: Prisma.ContactScamTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactScamTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactScamTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactScamTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactScamTypePayload>
          }
          findFirst: {
            args: Prisma.ContactScamTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactScamTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactScamTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactScamTypePayload>
          }
          findMany: {
            args: Prisma.ContactScamTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactScamTypePayload>[]
          }
          create: {
            args: Prisma.ContactScamTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactScamTypePayload>
          }
          createMany: {
            args: Prisma.ContactScamTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactScamTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactScamTypePayload>[]
          }
          delete: {
            args: Prisma.ContactScamTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactScamTypePayload>
          }
          update: {
            args: Prisma.ContactScamTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactScamTypePayload>
          }
          deleteMany: {
            args: Prisma.ContactScamTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactScamTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactScamTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactScamTypePayload>[]
          }
          upsert: {
            args: Prisma.ContactScamTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactScamTypePayload>
          }
          aggregate: {
            args: Prisma.ContactScamTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactScamType>
          }
          groupBy: {
            args: Prisma.ContactScamTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactScamTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactScamTypeCountArgs<ExtArgs>
            result: $Utils.Optional<ContactScamTypeCountAggregateOutputType> | number
          }
        }
      }
      ContactTag: {
        payload: Prisma.$ContactTagPayload<ExtArgs>
        fields: Prisma.ContactTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTagPayload>
          }
          findFirst: {
            args: Prisma.ContactTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTagPayload>
          }
          findMany: {
            args: Prisma.ContactTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTagPayload>[]
          }
          create: {
            args: Prisma.ContactTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTagPayload>
          }
          createMany: {
            args: Prisma.ContactTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTagPayload>[]
          }
          delete: {
            args: Prisma.ContactTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTagPayload>
          }
          update: {
            args: Prisma.ContactTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTagPayload>
          }
          deleteMany: {
            args: Prisma.ContactTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTagPayload>[]
          }
          upsert: {
            args: Prisma.ContactTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactTagPayload>
          }
          aggregate: {
            args: Prisma.ContactTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactTag>
          }
          groupBy: {
            args: Prisma.ContactTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactTagCountArgs<ExtArgs>
            result: $Utils.Optional<ContactTagCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    scamReport?: ScamReportOmit
    comment?: CommentOmit
    vote?: VoteOmit
    wikiPage?: WikiPageOmit
    searchCache?: SearchCacheOmit
    aIScamReport?: AIScamReportOmit
    scamType?: ScamTypeOmit
    severity?: SeverityOmit
    flag?: FlagOmit
    user?: UserOmit
    notification?: NotificationOmit
    outcomeType?: OutcomeTypeOmit
    educationPost?: EducationPostOmit
    tag?: TagOmit
    postTag?: PostTagOmit
    educationPostScamType?: EducationPostScamTypeOmit
    contact?: ContactOmit
    contactScamType?: ContactScamTypeOmit
    contactTag?: ContactTagOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ScamReportCountOutputType
   */

  export type ScamReportCountOutputType = {
    comments: number
    flags: number
    votes: number
  }

  export type ScamReportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | ScamReportCountOutputTypeCountCommentsArgs
    flags?: boolean | ScamReportCountOutputTypeCountFlagsArgs
    votes?: boolean | ScamReportCountOutputTypeCountVotesArgs
  }

  // Custom InputTypes
  /**
   * ScamReportCountOutputType without action
   */
  export type ScamReportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScamReportCountOutputType
     */
    select?: ScamReportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ScamReportCountOutputType without action
   */
  export type ScamReportCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * ScamReportCountOutputType without action
   */
  export type ScamReportCountOutputTypeCountFlagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlagWhereInput
  }

  /**
   * ScamReportCountOutputType without action
   */
  export type ScamReportCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoteWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    replies: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | CommentCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type ScamTypeCountOutputType
   */

  export type ScamTypeCountOutputType = {
    contactLinks: number
    postLinks: number
    reports: number
    severityRecords: number
  }

  export type ScamTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contactLinks?: boolean | ScamTypeCountOutputTypeCountContactLinksArgs
    postLinks?: boolean | ScamTypeCountOutputTypeCountPostLinksArgs
    reports?: boolean | ScamTypeCountOutputTypeCountReportsArgs
    severityRecords?: boolean | ScamTypeCountOutputTypeCountSeverityRecordsArgs
  }

  // Custom InputTypes
  /**
   * ScamTypeCountOutputType without action
   */
  export type ScamTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScamTypeCountOutputType
     */
    select?: ScamTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ScamTypeCountOutputType without action
   */
  export type ScamTypeCountOutputTypeCountContactLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactScamTypeWhereInput
  }

  /**
   * ScamTypeCountOutputType without action
   */
  export type ScamTypeCountOutputTypeCountPostLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EducationPostScamTypeWhereInput
  }

  /**
   * ScamTypeCountOutputType without action
   */
  export type ScamTypeCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScamReportWhereInput
  }

  /**
   * ScamTypeCountOutputType without action
   */
  export type ScamTypeCountOutputTypeCountSeverityRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeverityWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    comments: number
    flags: number
    notifications: number
    votes: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    flags?: boolean | UserCountOutputTypeCountFlagsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    votes?: boolean | UserCountOutputTypeCountVotesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFlagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlagWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoteWhereInput
  }


  /**
   * Count Type EducationPostCountOutputType
   */

  export type EducationPostCountOutputType = {
    scamTypes: number
    tags: number
  }

  export type EducationPostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scamTypes?: boolean | EducationPostCountOutputTypeCountScamTypesArgs
    tags?: boolean | EducationPostCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes
  /**
   * EducationPostCountOutputType without action
   */
  export type EducationPostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationPostCountOutputType
     */
    select?: EducationPostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EducationPostCountOutputType without action
   */
  export type EducationPostCountOutputTypeCountScamTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EducationPostScamTypeWhereInput
  }

  /**
   * EducationPostCountOutputType without action
   */
  export type EducationPostCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostTagWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    contacts: number
    posts: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contacts?: boolean | TagCountOutputTypeCountContactsArgs
    posts?: boolean | TagCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactTagWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostTagWhereInput
  }


  /**
   * Count Type ContactCountOutputType
   */

  export type ContactCountOutputType = {
    scamTypes: number
    tags: number
  }

  export type ContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scamTypes?: boolean | ContactCountOutputTypeCountScamTypesArgs
    tags?: boolean | ContactCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes
  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCountOutputType
     */
    select?: ContactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountScamTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactScamTypeWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactTagWhereInput
  }


  /**
   * Models
   */

  /**
   * Model ScamReport
   */

  export type AggregateScamReport = {
    _count: ScamReportCountAggregateOutputType | null
    _avg: ScamReportAvgAggregateOutputType | null
    _sum: ScamReportSumAggregateOutputType | null
    _min: ScamReportMinAggregateOutputType | null
    _max: ScamReportMaxAggregateOutputType | null
  }

  export type ScamReportAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    trustScore: number | null
    reportCount: number | null
  }

  export type ScamReportSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    trustScore: number | null
    reportCount: number | null
  }

  export type ScamReportMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
    city: string | null
    country: string | null
    region: string | null
    ipHash: string | null
    latitude: number | null
    longitude: number | null
    verified: boolean | null
    trustScore: number | null
    reportCount: number | null
    reporterName: string | null
    reporterEmail: string | null
    anonymous: boolean | null
    screenshots: string | null
    evidence: string | null
    scamTypeId: string | null
    source: string | null
  }

  export type ScamReportMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    description: string | null
    city: string | null
    country: string | null
    region: string | null
    ipHash: string | null
    latitude: number | null
    longitude: number | null
    verified: boolean | null
    trustScore: number | null
    reportCount: number | null
    reporterName: string | null
    reporterEmail: string | null
    anonymous: boolean | null
    screenshots: string | null
    evidence: string | null
    scamTypeId: string | null
    source: string | null
  }

  export type ScamReportCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    description: number
    scammerDetails: number
    city: number
    country: number
    region: number
    ipHash: number
    latitude: number
    longitude: number
    verified: number
    trustScore: number
    reportCount: number
    reporterName: number
    reporterEmail: number
    anonymous: number
    outcome: number
    screenshots: number
    evidence: number
    scamTypeId: number
    source: number
    _all: number
  }


  export type ScamReportAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    trustScore?: true
    reportCount?: true
  }

  export type ScamReportSumAggregateInputType = {
    latitude?: true
    longitude?: true
    trustScore?: true
    reportCount?: true
  }

  export type ScamReportMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    city?: true
    country?: true
    region?: true
    ipHash?: true
    latitude?: true
    longitude?: true
    verified?: true
    trustScore?: true
    reportCount?: true
    reporterName?: true
    reporterEmail?: true
    anonymous?: true
    screenshots?: true
    evidence?: true
    scamTypeId?: true
    source?: true
  }

  export type ScamReportMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    city?: true
    country?: true
    region?: true
    ipHash?: true
    latitude?: true
    longitude?: true
    verified?: true
    trustScore?: true
    reportCount?: true
    reporterName?: true
    reporterEmail?: true
    anonymous?: true
    screenshots?: true
    evidence?: true
    scamTypeId?: true
    source?: true
  }

  export type ScamReportCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    description?: true
    scammerDetails?: true
    city?: true
    country?: true
    region?: true
    ipHash?: true
    latitude?: true
    longitude?: true
    verified?: true
    trustScore?: true
    reportCount?: true
    reporterName?: true
    reporterEmail?: true
    anonymous?: true
    outcome?: true
    screenshots?: true
    evidence?: true
    scamTypeId?: true
    source?: true
    _all?: true
  }

  export type ScamReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScamReport to aggregate.
     */
    where?: ScamReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScamReports to fetch.
     */
    orderBy?: ScamReportOrderByWithRelationInput | ScamReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScamReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScamReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScamReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScamReports
    **/
    _count?: true | ScamReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScamReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScamReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScamReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScamReportMaxAggregateInputType
  }

  export type GetScamReportAggregateType<T extends ScamReportAggregateArgs> = {
        [P in keyof T & keyof AggregateScamReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScamReport[P]>
      : GetScalarType<T[P], AggregateScamReport[P]>
  }




  export type ScamReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScamReportWhereInput
    orderBy?: ScamReportOrderByWithAggregationInput | ScamReportOrderByWithAggregationInput[]
    by: ScamReportScalarFieldEnum[] | ScamReportScalarFieldEnum
    having?: ScamReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScamReportCountAggregateInputType | true
    _avg?: ScamReportAvgAggregateInputType
    _sum?: ScamReportSumAggregateInputType
    _min?: ScamReportMinAggregateInputType
    _max?: ScamReportMaxAggregateInputType
  }

  export type ScamReportGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    description: string
    scammerDetails: JsonValue | null
    city: string | null
    country: string | null
    region: string | null
    ipHash: string | null
    latitude: number | null
    longitude: number | null
    verified: boolean
    trustScore: number
    reportCount: number
    reporterName: string | null
    reporterEmail: string | null
    anonymous: boolean
    outcome: JsonValue | null
    screenshots: string | null
    evidence: string | null
    scamTypeId: string | null
    source: string | null
    _count: ScamReportCountAggregateOutputType | null
    _avg: ScamReportAvgAggregateOutputType | null
    _sum: ScamReportSumAggregateOutputType | null
    _min: ScamReportMinAggregateOutputType | null
    _max: ScamReportMaxAggregateOutputType | null
  }

  type GetScamReportGroupByPayload<T extends ScamReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScamReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScamReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScamReportGroupByOutputType[P]>
            : GetScalarType<T[P], ScamReportGroupByOutputType[P]>
        }
      >
    >


  export type ScamReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    scammerDetails?: boolean
    city?: boolean
    country?: boolean
    region?: boolean
    ipHash?: boolean
    latitude?: boolean
    longitude?: boolean
    verified?: boolean
    trustScore?: boolean
    reportCount?: boolean
    reporterName?: boolean
    reporterEmail?: boolean
    anonymous?: boolean
    outcome?: boolean
    screenshots?: boolean
    evidence?: boolean
    scamTypeId?: boolean
    source?: boolean
    comments?: boolean | ScamReport$commentsArgs<ExtArgs>
    flags?: boolean | ScamReport$flagsArgs<ExtArgs>
    scamType?: boolean | ScamReport$scamTypeArgs<ExtArgs>
    votes?: boolean | ScamReport$votesArgs<ExtArgs>
    _count?: boolean | ScamReportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scamReport"]>

  export type ScamReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    scammerDetails?: boolean
    city?: boolean
    country?: boolean
    region?: boolean
    ipHash?: boolean
    latitude?: boolean
    longitude?: boolean
    verified?: boolean
    trustScore?: boolean
    reportCount?: boolean
    reporterName?: boolean
    reporterEmail?: boolean
    anonymous?: boolean
    outcome?: boolean
    screenshots?: boolean
    evidence?: boolean
    scamTypeId?: boolean
    source?: boolean
    scamType?: boolean | ScamReport$scamTypeArgs<ExtArgs>
  }, ExtArgs["result"]["scamReport"]>

  export type ScamReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    scammerDetails?: boolean
    city?: boolean
    country?: boolean
    region?: boolean
    ipHash?: boolean
    latitude?: boolean
    longitude?: boolean
    verified?: boolean
    trustScore?: boolean
    reportCount?: boolean
    reporterName?: boolean
    reporterEmail?: boolean
    anonymous?: boolean
    outcome?: boolean
    screenshots?: boolean
    evidence?: boolean
    scamTypeId?: boolean
    source?: boolean
    scamType?: boolean | ScamReport$scamTypeArgs<ExtArgs>
  }, ExtArgs["result"]["scamReport"]>

  export type ScamReportSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    description?: boolean
    scammerDetails?: boolean
    city?: boolean
    country?: boolean
    region?: boolean
    ipHash?: boolean
    latitude?: boolean
    longitude?: boolean
    verified?: boolean
    trustScore?: boolean
    reportCount?: boolean
    reporterName?: boolean
    reporterEmail?: boolean
    anonymous?: boolean
    outcome?: boolean
    screenshots?: boolean
    evidence?: boolean
    scamTypeId?: boolean
    source?: boolean
  }

  export type ScamReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "description" | "scammerDetails" | "city" | "country" | "region" | "ipHash" | "latitude" | "longitude" | "verified" | "trustScore" | "reportCount" | "reporterName" | "reporterEmail" | "anonymous" | "outcome" | "screenshots" | "evidence" | "scamTypeId" | "source", ExtArgs["result"]["scamReport"]>
  export type ScamReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | ScamReport$commentsArgs<ExtArgs>
    flags?: boolean | ScamReport$flagsArgs<ExtArgs>
    scamType?: boolean | ScamReport$scamTypeArgs<ExtArgs>
    votes?: boolean | ScamReport$votesArgs<ExtArgs>
    _count?: boolean | ScamReportCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ScamReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scamType?: boolean | ScamReport$scamTypeArgs<ExtArgs>
  }
  export type ScamReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scamType?: boolean | ScamReport$scamTypeArgs<ExtArgs>
  }

  export type $ScamReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScamReport"
    objects: {
      comments: Prisma.$CommentPayload<ExtArgs>[]
      flags: Prisma.$FlagPayload<ExtArgs>[]
      scamType: Prisma.$ScamTypePayload<ExtArgs> | null
      votes: Prisma.$VotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      description: string
      scammerDetails: Prisma.JsonValue | null
      city: string | null
      country: string | null
      region: string | null
      ipHash: string | null
      latitude: number | null
      longitude: number | null
      verified: boolean
      trustScore: number
      reportCount: number
      reporterName: string | null
      reporterEmail: string | null
      anonymous: boolean
      outcome: Prisma.JsonValue | null
      screenshots: string | null
      evidence: string | null
      scamTypeId: string | null
      source: string | null
    }, ExtArgs["result"]["scamReport"]>
    composites: {}
  }

  type ScamReportGetPayload<S extends boolean | null | undefined | ScamReportDefaultArgs> = $Result.GetResult<Prisma.$ScamReportPayload, S>

  type ScamReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScamReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScamReportCountAggregateInputType | true
    }

  export interface ScamReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScamReport'], meta: { name: 'ScamReport' } }
    /**
     * Find zero or one ScamReport that matches the filter.
     * @param {ScamReportFindUniqueArgs} args - Arguments to find a ScamReport
     * @example
     * // Get one ScamReport
     * const scamReport = await prisma.scamReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScamReportFindUniqueArgs>(args: SelectSubset<T, ScamReportFindUniqueArgs<ExtArgs>>): Prisma__ScamReportClient<$Result.GetResult<Prisma.$ScamReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScamReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScamReportFindUniqueOrThrowArgs} args - Arguments to find a ScamReport
     * @example
     * // Get one ScamReport
     * const scamReport = await prisma.scamReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScamReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ScamReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScamReportClient<$Result.GetResult<Prisma.$ScamReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScamReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScamReportFindFirstArgs} args - Arguments to find a ScamReport
     * @example
     * // Get one ScamReport
     * const scamReport = await prisma.scamReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScamReportFindFirstArgs>(args?: SelectSubset<T, ScamReportFindFirstArgs<ExtArgs>>): Prisma__ScamReportClient<$Result.GetResult<Prisma.$ScamReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScamReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScamReportFindFirstOrThrowArgs} args - Arguments to find a ScamReport
     * @example
     * // Get one ScamReport
     * const scamReport = await prisma.scamReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScamReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ScamReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScamReportClient<$Result.GetResult<Prisma.$ScamReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScamReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScamReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScamReports
     * const scamReports = await prisma.scamReport.findMany()
     * 
     * // Get first 10 ScamReports
     * const scamReports = await prisma.scamReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scamReportWithIdOnly = await prisma.scamReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScamReportFindManyArgs>(args?: SelectSubset<T, ScamReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScamReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScamReport.
     * @param {ScamReportCreateArgs} args - Arguments to create a ScamReport.
     * @example
     * // Create one ScamReport
     * const ScamReport = await prisma.scamReport.create({
     *   data: {
     *     // ... data to create a ScamReport
     *   }
     * })
     * 
     */
    create<T extends ScamReportCreateArgs>(args: SelectSubset<T, ScamReportCreateArgs<ExtArgs>>): Prisma__ScamReportClient<$Result.GetResult<Prisma.$ScamReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScamReports.
     * @param {ScamReportCreateManyArgs} args - Arguments to create many ScamReports.
     * @example
     * // Create many ScamReports
     * const scamReport = await prisma.scamReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScamReportCreateManyArgs>(args?: SelectSubset<T, ScamReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScamReports and returns the data saved in the database.
     * @param {ScamReportCreateManyAndReturnArgs} args - Arguments to create many ScamReports.
     * @example
     * // Create many ScamReports
     * const scamReport = await prisma.scamReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScamReports and only return the `id`
     * const scamReportWithIdOnly = await prisma.scamReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScamReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ScamReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScamReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ScamReport.
     * @param {ScamReportDeleteArgs} args - Arguments to delete one ScamReport.
     * @example
     * // Delete one ScamReport
     * const ScamReport = await prisma.scamReport.delete({
     *   where: {
     *     // ... filter to delete one ScamReport
     *   }
     * })
     * 
     */
    delete<T extends ScamReportDeleteArgs>(args: SelectSubset<T, ScamReportDeleteArgs<ExtArgs>>): Prisma__ScamReportClient<$Result.GetResult<Prisma.$ScamReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScamReport.
     * @param {ScamReportUpdateArgs} args - Arguments to update one ScamReport.
     * @example
     * // Update one ScamReport
     * const scamReport = await prisma.scamReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScamReportUpdateArgs>(args: SelectSubset<T, ScamReportUpdateArgs<ExtArgs>>): Prisma__ScamReportClient<$Result.GetResult<Prisma.$ScamReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScamReports.
     * @param {ScamReportDeleteManyArgs} args - Arguments to filter ScamReports to delete.
     * @example
     * // Delete a few ScamReports
     * const { count } = await prisma.scamReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScamReportDeleteManyArgs>(args?: SelectSubset<T, ScamReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScamReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScamReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScamReports
     * const scamReport = await prisma.scamReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScamReportUpdateManyArgs>(args: SelectSubset<T, ScamReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScamReports and returns the data updated in the database.
     * @param {ScamReportUpdateManyAndReturnArgs} args - Arguments to update many ScamReports.
     * @example
     * // Update many ScamReports
     * const scamReport = await prisma.scamReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ScamReports and only return the `id`
     * const scamReportWithIdOnly = await prisma.scamReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScamReportUpdateManyAndReturnArgs>(args: SelectSubset<T, ScamReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScamReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ScamReport.
     * @param {ScamReportUpsertArgs} args - Arguments to update or create a ScamReport.
     * @example
     * // Update or create a ScamReport
     * const scamReport = await prisma.scamReport.upsert({
     *   create: {
     *     // ... data to create a ScamReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScamReport we want to update
     *   }
     * })
     */
    upsert<T extends ScamReportUpsertArgs>(args: SelectSubset<T, ScamReportUpsertArgs<ExtArgs>>): Prisma__ScamReportClient<$Result.GetResult<Prisma.$ScamReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScamReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScamReportCountArgs} args - Arguments to filter ScamReports to count.
     * @example
     * // Count the number of ScamReports
     * const count = await prisma.scamReport.count({
     *   where: {
     *     // ... the filter for the ScamReports we want to count
     *   }
     * })
    **/
    count<T extends ScamReportCountArgs>(
      args?: Subset<T, ScamReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScamReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScamReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScamReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScamReportAggregateArgs>(args: Subset<T, ScamReportAggregateArgs>): Prisma.PrismaPromise<GetScamReportAggregateType<T>>

    /**
     * Group by ScamReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScamReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScamReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScamReportGroupByArgs['orderBy'] }
        : { orderBy?: ScamReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScamReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScamReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScamReport model
   */
  readonly fields: ScamReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScamReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScamReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comments<T extends ScamReport$commentsArgs<ExtArgs> = {}>(args?: Subset<T, ScamReport$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    flags<T extends ScamReport$flagsArgs<ExtArgs> = {}>(args?: Subset<T, ScamReport$flagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    scamType<T extends ScamReport$scamTypeArgs<ExtArgs> = {}>(args?: Subset<T, ScamReport$scamTypeArgs<ExtArgs>>): Prisma__ScamTypeClient<$Result.GetResult<Prisma.$ScamTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    votes<T extends ScamReport$votesArgs<ExtArgs> = {}>(args?: Subset<T, ScamReport$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScamReport model
   */
  interface ScamReportFieldRefs {
    readonly id: FieldRef<"ScamReport", 'String'>
    readonly createdAt: FieldRef<"ScamReport", 'DateTime'>
    readonly updatedAt: FieldRef<"ScamReport", 'DateTime'>
    readonly description: FieldRef<"ScamReport", 'String'>
    readonly scammerDetails: FieldRef<"ScamReport", 'Json'>
    readonly city: FieldRef<"ScamReport", 'String'>
    readonly country: FieldRef<"ScamReport", 'String'>
    readonly region: FieldRef<"ScamReport", 'String'>
    readonly ipHash: FieldRef<"ScamReport", 'String'>
    readonly latitude: FieldRef<"ScamReport", 'Float'>
    readonly longitude: FieldRef<"ScamReport", 'Float'>
    readonly verified: FieldRef<"ScamReport", 'Boolean'>
    readonly trustScore: FieldRef<"ScamReport", 'Int'>
    readonly reportCount: FieldRef<"ScamReport", 'Int'>
    readonly reporterName: FieldRef<"ScamReport", 'String'>
    readonly reporterEmail: FieldRef<"ScamReport", 'String'>
    readonly anonymous: FieldRef<"ScamReport", 'Boolean'>
    readonly outcome: FieldRef<"ScamReport", 'Json'>
    readonly screenshots: FieldRef<"ScamReport", 'String'>
    readonly evidence: FieldRef<"ScamReport", 'String'>
    readonly scamTypeId: FieldRef<"ScamReport", 'String'>
    readonly source: FieldRef<"ScamReport", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ScamReport findUnique
   */
  export type ScamReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScamReport
     */
    select?: ScamReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScamReport
     */
    omit?: ScamReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScamReportInclude<ExtArgs> | null
    /**
     * Filter, which ScamReport to fetch.
     */
    where: ScamReportWhereUniqueInput
  }

  /**
   * ScamReport findUniqueOrThrow
   */
  export type ScamReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScamReport
     */
    select?: ScamReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScamReport
     */
    omit?: ScamReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScamReportInclude<ExtArgs> | null
    /**
     * Filter, which ScamReport to fetch.
     */
    where: ScamReportWhereUniqueInput
  }

  /**
   * ScamReport findFirst
   */
  export type ScamReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScamReport
     */
    select?: ScamReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScamReport
     */
    omit?: ScamReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScamReportInclude<ExtArgs> | null
    /**
     * Filter, which ScamReport to fetch.
     */
    where?: ScamReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScamReports to fetch.
     */
    orderBy?: ScamReportOrderByWithRelationInput | ScamReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScamReports.
     */
    cursor?: ScamReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScamReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScamReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScamReports.
     */
    distinct?: ScamReportScalarFieldEnum | ScamReportScalarFieldEnum[]
  }

  /**
   * ScamReport findFirstOrThrow
   */
  export type ScamReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScamReport
     */
    select?: ScamReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScamReport
     */
    omit?: ScamReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScamReportInclude<ExtArgs> | null
    /**
     * Filter, which ScamReport to fetch.
     */
    where?: ScamReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScamReports to fetch.
     */
    orderBy?: ScamReportOrderByWithRelationInput | ScamReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScamReports.
     */
    cursor?: ScamReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScamReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScamReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScamReports.
     */
    distinct?: ScamReportScalarFieldEnum | ScamReportScalarFieldEnum[]
  }

  /**
   * ScamReport findMany
   */
  export type ScamReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScamReport
     */
    select?: ScamReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScamReport
     */
    omit?: ScamReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScamReportInclude<ExtArgs> | null
    /**
     * Filter, which ScamReports to fetch.
     */
    where?: ScamReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScamReports to fetch.
     */
    orderBy?: ScamReportOrderByWithRelationInput | ScamReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScamReports.
     */
    cursor?: ScamReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScamReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScamReports.
     */
    skip?: number
    distinct?: ScamReportScalarFieldEnum | ScamReportScalarFieldEnum[]
  }

  /**
   * ScamReport create
   */
  export type ScamReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScamReport
     */
    select?: ScamReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScamReport
     */
    omit?: ScamReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScamReportInclude<ExtArgs> | null
    /**
     * The data needed to create a ScamReport.
     */
    data: XOR<ScamReportCreateInput, ScamReportUncheckedCreateInput>
  }

  /**
   * ScamReport createMany
   */
  export type ScamReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScamReports.
     */
    data: ScamReportCreateManyInput | ScamReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScamReport createManyAndReturn
   */
  export type ScamReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScamReport
     */
    select?: ScamReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScamReport
     */
    omit?: ScamReportOmit<ExtArgs> | null
    /**
     * The data used to create many ScamReports.
     */
    data: ScamReportCreateManyInput | ScamReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScamReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScamReport update
   */
  export type ScamReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScamReport
     */
    select?: ScamReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScamReport
     */
    omit?: ScamReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScamReportInclude<ExtArgs> | null
    /**
     * The data needed to update a ScamReport.
     */
    data: XOR<ScamReportUpdateInput, ScamReportUncheckedUpdateInput>
    /**
     * Choose, which ScamReport to update.
     */
    where: ScamReportWhereUniqueInput
  }

  /**
   * ScamReport updateMany
   */
  export type ScamReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScamReports.
     */
    data: XOR<ScamReportUpdateManyMutationInput, ScamReportUncheckedUpdateManyInput>
    /**
     * Filter which ScamReports to update
     */
    where?: ScamReportWhereInput
    /**
     * Limit how many ScamReports to update.
     */
    limit?: number
  }

  /**
   * ScamReport updateManyAndReturn
   */
  export type ScamReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScamReport
     */
    select?: ScamReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScamReport
     */
    omit?: ScamReportOmit<ExtArgs> | null
    /**
     * The data used to update ScamReports.
     */
    data: XOR<ScamReportUpdateManyMutationInput, ScamReportUncheckedUpdateManyInput>
    /**
     * Filter which ScamReports to update
     */
    where?: ScamReportWhereInput
    /**
     * Limit how many ScamReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScamReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScamReport upsert
   */
  export type ScamReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScamReport
     */
    select?: ScamReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScamReport
     */
    omit?: ScamReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScamReportInclude<ExtArgs> | null
    /**
     * The filter to search for the ScamReport to update in case it exists.
     */
    where: ScamReportWhereUniqueInput
    /**
     * In case the ScamReport found by the `where` argument doesn't exist, create a new ScamReport with this data.
     */
    create: XOR<ScamReportCreateInput, ScamReportUncheckedCreateInput>
    /**
     * In case the ScamReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScamReportUpdateInput, ScamReportUncheckedUpdateInput>
  }

  /**
   * ScamReport delete
   */
  export type ScamReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScamReport
     */
    select?: ScamReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScamReport
     */
    omit?: ScamReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScamReportInclude<ExtArgs> | null
    /**
     * Filter which ScamReport to delete.
     */
    where: ScamReportWhereUniqueInput
  }

  /**
   * ScamReport deleteMany
   */
  export type ScamReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScamReports to delete
     */
    where?: ScamReportWhereInput
    /**
     * Limit how many ScamReports to delete.
     */
    limit?: number
  }

  /**
   * ScamReport.comments
   */
  export type ScamReport$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * ScamReport.flags
   */
  export type ScamReport$flagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flag
     */
    select?: FlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flag
     */
    omit?: FlagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagInclude<ExtArgs> | null
    where?: FlagWhereInput
    orderBy?: FlagOrderByWithRelationInput | FlagOrderByWithRelationInput[]
    cursor?: FlagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlagScalarFieldEnum | FlagScalarFieldEnum[]
  }

  /**
   * ScamReport.scamType
   */
  export type ScamReport$scamTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScamType
     */
    select?: ScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScamType
     */
    omit?: ScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScamTypeInclude<ExtArgs> | null
    where?: ScamTypeWhereInput
  }

  /**
   * ScamReport.votes
   */
  export type ScamReport$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    where?: VoteWhereInput
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    cursor?: VoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * ScamReport without action
   */
  export type ScamReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScamReport
     */
    select?: ScamReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScamReport
     */
    omit?: ScamReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScamReportInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    content: string | null
    reportId: string | null
    parentId: string | null
    userId: string | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    content: string | null
    reportId: string | null
    parentId: string | null
    userId: string | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    createdAt: number
    content: number
    reportId: number
    parentId: number
    userId: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    createdAt?: true
    content?: true
    reportId?: true
    parentId?: true
    userId?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    createdAt?: true
    content?: true
    reportId?: true
    parentId?: true
    userId?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    createdAt?: true
    content?: true
    reportId?: true
    parentId?: true
    userId?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    createdAt: Date
    content: string
    reportId: string
    parentId: string | null
    userId: string | null
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    content?: boolean
    reportId?: boolean
    parentId?: boolean
    userId?: boolean
    parent?: boolean | Comment$parentArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    report?: boolean | ScamReportDefaultArgs<ExtArgs>
    user?: boolean | Comment$userArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    content?: boolean
    reportId?: boolean
    parentId?: boolean
    userId?: boolean
    parent?: boolean | Comment$parentArgs<ExtArgs>
    report?: boolean | ScamReportDefaultArgs<ExtArgs>
    user?: boolean | Comment$userArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    content?: boolean
    reportId?: boolean
    parentId?: boolean
    userId?: boolean
    parent?: boolean | Comment$parentArgs<ExtArgs>
    report?: boolean | ScamReportDefaultArgs<ExtArgs>
    user?: boolean | Comment$userArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    createdAt?: boolean
    content?: boolean
    reportId?: boolean
    parentId?: boolean
    userId?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "content" | "reportId" | "parentId" | "userId", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Comment$parentArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    report?: boolean | ScamReportDefaultArgs<ExtArgs>
    user?: boolean | Comment$userArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Comment$parentArgs<ExtArgs>
    report?: boolean | ScamReportDefaultArgs<ExtArgs>
    user?: boolean | Comment$userArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Comment$parentArgs<ExtArgs>
    report?: boolean | ScamReportDefaultArgs<ExtArgs>
    user?: boolean | Comment$userArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      parent: Prisma.$CommentPayload<ExtArgs> | null
      replies: Prisma.$CommentPayload<ExtArgs>[]
      report: Prisma.$ScamReportPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      content: string
      reportId: string
      parentId: string | null
      userId: string | null
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends Comment$parentArgs<ExtArgs> = {}>(args?: Subset<T, Comment$parentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    replies<T extends Comment$repliesArgs<ExtArgs> = {}>(args?: Subset<T, Comment$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    report<T extends ScamReportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ScamReportDefaultArgs<ExtArgs>>): Prisma__ScamReportClient<$Result.GetResult<Prisma.$ScamReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends Comment$userArgs<ExtArgs> = {}>(args?: Subset<T, Comment$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly reportId: FieldRef<"Comment", 'String'>
    readonly parentId: FieldRef<"Comment", 'String'>
    readonly userId: FieldRef<"Comment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment.parent
   */
  export type Comment$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Comment.replies
   */
  export type Comment$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment.user
   */
  export type Comment$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Vote
   */

  export type AggregateVote = {
    _count: VoteCountAggregateOutputType | null
    _min: VoteMinAggregateOutputType | null
    _max: VoteMaxAggregateOutputType | null
  }

  export type VoteMinAggregateOutputType = {
    id: string | null
    reportId: string | null
    userId: string | null
    voteType: string | null
  }

  export type VoteMaxAggregateOutputType = {
    id: string | null
    reportId: string | null
    userId: string | null
    voteType: string | null
  }

  export type VoteCountAggregateOutputType = {
    id: number
    reportId: number
    userId: number
    voteType: number
    _all: number
  }


  export type VoteMinAggregateInputType = {
    id?: true
    reportId?: true
    userId?: true
    voteType?: true
  }

  export type VoteMaxAggregateInputType = {
    id?: true
    reportId?: true
    userId?: true
    voteType?: true
  }

  export type VoteCountAggregateInputType = {
    id?: true
    reportId?: true
    userId?: true
    voteType?: true
    _all?: true
  }

  export type VoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vote to aggregate.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Votes
    **/
    _count?: true | VoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VoteMaxAggregateInputType
  }

  export type GetVoteAggregateType<T extends VoteAggregateArgs> = {
        [P in keyof T & keyof AggregateVote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVote[P]>
      : GetScalarType<T[P], AggregateVote[P]>
  }




  export type VoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VoteWhereInput
    orderBy?: VoteOrderByWithAggregationInput | VoteOrderByWithAggregationInput[]
    by: VoteScalarFieldEnum[] | VoteScalarFieldEnum
    having?: VoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VoteCountAggregateInputType | true
    _min?: VoteMinAggregateInputType
    _max?: VoteMaxAggregateInputType
  }

  export type VoteGroupByOutputType = {
    id: string
    reportId: string
    userId: string
    voteType: string
    _count: VoteCountAggregateOutputType | null
    _min: VoteMinAggregateOutputType | null
    _max: VoteMaxAggregateOutputType | null
  }

  type GetVoteGroupByPayload<T extends VoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VoteGroupByOutputType[P]>
            : GetScalarType<T[P], VoteGroupByOutputType[P]>
        }
      >
    >


  export type VoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportId?: boolean
    userId?: boolean
    voteType?: boolean
    report?: boolean | ScamReportDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vote"]>

  export type VoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportId?: boolean
    userId?: boolean
    voteType?: boolean
    report?: boolean | ScamReportDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vote"]>

  export type VoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportId?: boolean
    userId?: boolean
    voteType?: boolean
    report?: boolean | ScamReportDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vote"]>

  export type VoteSelectScalar = {
    id?: boolean
    reportId?: boolean
    userId?: boolean
    voteType?: boolean
  }

  export type VoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reportId" | "userId" | "voteType", ExtArgs["result"]["vote"]>
  export type VoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    report?: boolean | ScamReportDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    report?: boolean | ScamReportDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    report?: boolean | ScamReportDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vote"
    objects: {
      report: Prisma.$ScamReportPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reportId: string
      userId: string
      voteType: string
    }, ExtArgs["result"]["vote"]>
    composites: {}
  }

  type VoteGetPayload<S extends boolean | null | undefined | VoteDefaultArgs> = $Result.GetResult<Prisma.$VotePayload, S>

  type VoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VoteCountAggregateInputType | true
    }

  export interface VoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vote'], meta: { name: 'Vote' } }
    /**
     * Find zero or one Vote that matches the filter.
     * @param {VoteFindUniqueArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VoteFindUniqueArgs>(args: SelectSubset<T, VoteFindUniqueArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VoteFindUniqueOrThrowArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VoteFindUniqueOrThrowArgs>(args: SelectSubset<T, VoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteFindFirstArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VoteFindFirstArgs>(args?: SelectSubset<T, VoteFindFirstArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteFindFirstOrThrowArgs} args - Arguments to find a Vote
     * @example
     * // Get one Vote
     * const vote = await prisma.vote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VoteFindFirstOrThrowArgs>(args?: SelectSubset<T, VoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Votes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Votes
     * const votes = await prisma.vote.findMany()
     * 
     * // Get first 10 Votes
     * const votes = await prisma.vote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const voteWithIdOnly = await prisma.vote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VoteFindManyArgs>(args?: SelectSubset<T, VoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vote.
     * @param {VoteCreateArgs} args - Arguments to create a Vote.
     * @example
     * // Create one Vote
     * const Vote = await prisma.vote.create({
     *   data: {
     *     // ... data to create a Vote
     *   }
     * })
     * 
     */
    create<T extends VoteCreateArgs>(args: SelectSubset<T, VoteCreateArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Votes.
     * @param {VoteCreateManyArgs} args - Arguments to create many Votes.
     * @example
     * // Create many Votes
     * const vote = await prisma.vote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VoteCreateManyArgs>(args?: SelectSubset<T, VoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Votes and returns the data saved in the database.
     * @param {VoteCreateManyAndReturnArgs} args - Arguments to create many Votes.
     * @example
     * // Create many Votes
     * const vote = await prisma.vote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Votes and only return the `id`
     * const voteWithIdOnly = await prisma.vote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VoteCreateManyAndReturnArgs>(args?: SelectSubset<T, VoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vote.
     * @param {VoteDeleteArgs} args - Arguments to delete one Vote.
     * @example
     * // Delete one Vote
     * const Vote = await prisma.vote.delete({
     *   where: {
     *     // ... filter to delete one Vote
     *   }
     * })
     * 
     */
    delete<T extends VoteDeleteArgs>(args: SelectSubset<T, VoteDeleteArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vote.
     * @param {VoteUpdateArgs} args - Arguments to update one Vote.
     * @example
     * // Update one Vote
     * const vote = await prisma.vote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VoteUpdateArgs>(args: SelectSubset<T, VoteUpdateArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Votes.
     * @param {VoteDeleteManyArgs} args - Arguments to filter Votes to delete.
     * @example
     * // Delete a few Votes
     * const { count } = await prisma.vote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VoteDeleteManyArgs>(args?: SelectSubset<T, VoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Votes
     * const vote = await prisma.vote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VoteUpdateManyArgs>(args: SelectSubset<T, VoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Votes and returns the data updated in the database.
     * @param {VoteUpdateManyAndReturnArgs} args - Arguments to update many Votes.
     * @example
     * // Update many Votes
     * const vote = await prisma.vote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Votes and only return the `id`
     * const voteWithIdOnly = await prisma.vote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VoteUpdateManyAndReturnArgs>(args: SelectSubset<T, VoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vote.
     * @param {VoteUpsertArgs} args - Arguments to update or create a Vote.
     * @example
     * // Update or create a Vote
     * const vote = await prisma.vote.upsert({
     *   create: {
     *     // ... data to create a Vote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vote we want to update
     *   }
     * })
     */
    upsert<T extends VoteUpsertArgs>(args: SelectSubset<T, VoteUpsertArgs<ExtArgs>>): Prisma__VoteClient<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteCountArgs} args - Arguments to filter Votes to count.
     * @example
     * // Count the number of Votes
     * const count = await prisma.vote.count({
     *   where: {
     *     // ... the filter for the Votes we want to count
     *   }
     * })
    **/
    count<T extends VoteCountArgs>(
      args?: Subset<T, VoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VoteAggregateArgs>(args: Subset<T, VoteAggregateArgs>): Prisma.PrismaPromise<GetVoteAggregateType<T>>

    /**
     * Group by Vote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VoteGroupByArgs['orderBy'] }
        : { orderBy?: VoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vote model
   */
  readonly fields: VoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    report<T extends ScamReportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ScamReportDefaultArgs<ExtArgs>>): Prisma__ScamReportClient<$Result.GetResult<Prisma.$ScamReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vote model
   */
  interface VoteFieldRefs {
    readonly id: FieldRef<"Vote", 'String'>
    readonly reportId: FieldRef<"Vote", 'String'>
    readonly userId: FieldRef<"Vote", 'String'>
    readonly voteType: FieldRef<"Vote", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Vote findUnique
   */
  export type VoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where: VoteWhereUniqueInput
  }

  /**
   * Vote findUniqueOrThrow
   */
  export type VoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where: VoteWhereUniqueInput
  }

  /**
   * Vote findFirst
   */
  export type VoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Votes.
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Votes.
     */
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * Vote findFirstOrThrow
   */
  export type VoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Vote to fetch.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Votes.
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Votes.
     */
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * Vote findMany
   */
  export type VoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter, which Votes to fetch.
     */
    where?: VoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Votes to fetch.
     */
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Votes.
     */
    cursor?: VoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Votes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Votes.
     */
    skip?: number
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * Vote create
   */
  export type VoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Vote.
     */
    data: XOR<VoteCreateInput, VoteUncheckedCreateInput>
  }

  /**
   * Vote createMany
   */
  export type VoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Votes.
     */
    data: VoteCreateManyInput | VoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vote createManyAndReturn
   */
  export type VoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * The data used to create many Votes.
     */
    data: VoteCreateManyInput | VoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vote update
   */
  export type VoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Vote.
     */
    data: XOR<VoteUpdateInput, VoteUncheckedUpdateInput>
    /**
     * Choose, which Vote to update.
     */
    where: VoteWhereUniqueInput
  }

  /**
   * Vote updateMany
   */
  export type VoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Votes.
     */
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyInput>
    /**
     * Filter which Votes to update
     */
    where?: VoteWhereInput
    /**
     * Limit how many Votes to update.
     */
    limit?: number
  }

  /**
   * Vote updateManyAndReturn
   */
  export type VoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * The data used to update Votes.
     */
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyInput>
    /**
     * Filter which Votes to update
     */
    where?: VoteWhereInput
    /**
     * Limit how many Votes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vote upsert
   */
  export type VoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Vote to update in case it exists.
     */
    where: VoteWhereUniqueInput
    /**
     * In case the Vote found by the `where` argument doesn't exist, create a new Vote with this data.
     */
    create: XOR<VoteCreateInput, VoteUncheckedCreateInput>
    /**
     * In case the Vote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VoteUpdateInput, VoteUncheckedUpdateInput>
  }

  /**
   * Vote delete
   */
  export type VoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    /**
     * Filter which Vote to delete.
     */
    where: VoteWhereUniqueInput
  }

  /**
   * Vote deleteMany
   */
  export type VoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Votes to delete
     */
    where?: VoteWhereInput
    /**
     * Limit how many Votes to delete.
     */
    limit?: number
  }

  /**
   * Vote without action
   */
  export type VoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
  }


  /**
   * Model WikiPage
   */

  export type AggregateWikiPage = {
    _count: WikiPageCountAggregateOutputType | null
    _avg: WikiPageAvgAggregateOutputType | null
    _sum: WikiPageSumAggregateOutputType | null
    _min: WikiPageMinAggregateOutputType | null
    _max: WikiPageMaxAggregateOutputType | null
  }

  export type WikiPageAvgAggregateOutputType = {
    views: number | null
  }

  export type WikiPageSumAggregateOutputType = {
    views: number | null
  }

  export type WikiPageMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    title: string | null
    slug: string | null
    content: string | null
    category: string | null
    country: string | null
    views: number | null
    featured: boolean | null
  }

  export type WikiPageMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    title: string | null
    slug: string | null
    content: string | null
    category: string | null
    country: string | null
    views: number | null
    featured: boolean | null
  }

  export type WikiPageCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    title: number
    slug: number
    content: number
    category: number
    country: number
    views: number
    featured: number
    _all: number
  }


  export type WikiPageAvgAggregateInputType = {
    views?: true
  }

  export type WikiPageSumAggregateInputType = {
    views?: true
  }

  export type WikiPageMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    title?: true
    slug?: true
    content?: true
    category?: true
    country?: true
    views?: true
    featured?: true
  }

  export type WikiPageMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    title?: true
    slug?: true
    content?: true
    category?: true
    country?: true
    views?: true
    featured?: true
  }

  export type WikiPageCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    title?: true
    slug?: true
    content?: true
    category?: true
    country?: true
    views?: true
    featured?: true
    _all?: true
  }

  export type WikiPageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WikiPage to aggregate.
     */
    where?: WikiPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WikiPages to fetch.
     */
    orderBy?: WikiPageOrderByWithRelationInput | WikiPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WikiPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WikiPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WikiPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WikiPages
    **/
    _count?: true | WikiPageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WikiPageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WikiPageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WikiPageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WikiPageMaxAggregateInputType
  }

  export type GetWikiPageAggregateType<T extends WikiPageAggregateArgs> = {
        [P in keyof T & keyof AggregateWikiPage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWikiPage[P]>
      : GetScalarType<T[P], AggregateWikiPage[P]>
  }




  export type WikiPageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WikiPageWhereInput
    orderBy?: WikiPageOrderByWithAggregationInput | WikiPageOrderByWithAggregationInput[]
    by: WikiPageScalarFieldEnum[] | WikiPageScalarFieldEnum
    having?: WikiPageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WikiPageCountAggregateInputType | true
    _avg?: WikiPageAvgAggregateInputType
    _sum?: WikiPageSumAggregateInputType
    _min?: WikiPageMinAggregateInputType
    _max?: WikiPageMaxAggregateInputType
  }

  export type WikiPageGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    title: string
    slug: string
    content: string
    category: string
    country: string | null
    views: number
    featured: boolean
    _count: WikiPageCountAggregateOutputType | null
    _avg: WikiPageAvgAggregateOutputType | null
    _sum: WikiPageSumAggregateOutputType | null
    _min: WikiPageMinAggregateOutputType | null
    _max: WikiPageMaxAggregateOutputType | null
  }

  type GetWikiPageGroupByPayload<T extends WikiPageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WikiPageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WikiPageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WikiPageGroupByOutputType[P]>
            : GetScalarType<T[P], WikiPageGroupByOutputType[P]>
        }
      >
    >


  export type WikiPageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    category?: boolean
    country?: boolean
    views?: boolean
    featured?: boolean
  }, ExtArgs["result"]["wikiPage"]>

  export type WikiPageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    category?: boolean
    country?: boolean
    views?: boolean
    featured?: boolean
  }, ExtArgs["result"]["wikiPage"]>

  export type WikiPageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    category?: boolean
    country?: boolean
    views?: boolean
    featured?: boolean
  }, ExtArgs["result"]["wikiPage"]>

  export type WikiPageSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    category?: boolean
    country?: boolean
    views?: boolean
    featured?: boolean
  }

  export type WikiPageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "title" | "slug" | "content" | "category" | "country" | "views" | "featured", ExtArgs["result"]["wikiPage"]>

  export type $WikiPagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WikiPage"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      title: string
      slug: string
      content: string
      category: string
      country: string | null
      views: number
      featured: boolean
    }, ExtArgs["result"]["wikiPage"]>
    composites: {}
  }

  type WikiPageGetPayload<S extends boolean | null | undefined | WikiPageDefaultArgs> = $Result.GetResult<Prisma.$WikiPagePayload, S>

  type WikiPageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WikiPageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WikiPageCountAggregateInputType | true
    }

  export interface WikiPageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WikiPage'], meta: { name: 'WikiPage' } }
    /**
     * Find zero or one WikiPage that matches the filter.
     * @param {WikiPageFindUniqueArgs} args - Arguments to find a WikiPage
     * @example
     * // Get one WikiPage
     * const wikiPage = await prisma.wikiPage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WikiPageFindUniqueArgs>(args: SelectSubset<T, WikiPageFindUniqueArgs<ExtArgs>>): Prisma__WikiPageClient<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WikiPage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WikiPageFindUniqueOrThrowArgs} args - Arguments to find a WikiPage
     * @example
     * // Get one WikiPage
     * const wikiPage = await prisma.wikiPage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WikiPageFindUniqueOrThrowArgs>(args: SelectSubset<T, WikiPageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WikiPageClient<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WikiPage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WikiPageFindFirstArgs} args - Arguments to find a WikiPage
     * @example
     * // Get one WikiPage
     * const wikiPage = await prisma.wikiPage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WikiPageFindFirstArgs>(args?: SelectSubset<T, WikiPageFindFirstArgs<ExtArgs>>): Prisma__WikiPageClient<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WikiPage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WikiPageFindFirstOrThrowArgs} args - Arguments to find a WikiPage
     * @example
     * // Get one WikiPage
     * const wikiPage = await prisma.wikiPage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WikiPageFindFirstOrThrowArgs>(args?: SelectSubset<T, WikiPageFindFirstOrThrowArgs<ExtArgs>>): Prisma__WikiPageClient<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WikiPages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WikiPageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WikiPages
     * const wikiPages = await prisma.wikiPage.findMany()
     * 
     * // Get first 10 WikiPages
     * const wikiPages = await prisma.wikiPage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wikiPageWithIdOnly = await prisma.wikiPage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WikiPageFindManyArgs>(args?: SelectSubset<T, WikiPageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WikiPage.
     * @param {WikiPageCreateArgs} args - Arguments to create a WikiPage.
     * @example
     * // Create one WikiPage
     * const WikiPage = await prisma.wikiPage.create({
     *   data: {
     *     // ... data to create a WikiPage
     *   }
     * })
     * 
     */
    create<T extends WikiPageCreateArgs>(args: SelectSubset<T, WikiPageCreateArgs<ExtArgs>>): Prisma__WikiPageClient<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WikiPages.
     * @param {WikiPageCreateManyArgs} args - Arguments to create many WikiPages.
     * @example
     * // Create many WikiPages
     * const wikiPage = await prisma.wikiPage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WikiPageCreateManyArgs>(args?: SelectSubset<T, WikiPageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WikiPages and returns the data saved in the database.
     * @param {WikiPageCreateManyAndReturnArgs} args - Arguments to create many WikiPages.
     * @example
     * // Create many WikiPages
     * const wikiPage = await prisma.wikiPage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WikiPages and only return the `id`
     * const wikiPageWithIdOnly = await prisma.wikiPage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WikiPageCreateManyAndReturnArgs>(args?: SelectSubset<T, WikiPageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WikiPage.
     * @param {WikiPageDeleteArgs} args - Arguments to delete one WikiPage.
     * @example
     * // Delete one WikiPage
     * const WikiPage = await prisma.wikiPage.delete({
     *   where: {
     *     // ... filter to delete one WikiPage
     *   }
     * })
     * 
     */
    delete<T extends WikiPageDeleteArgs>(args: SelectSubset<T, WikiPageDeleteArgs<ExtArgs>>): Prisma__WikiPageClient<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WikiPage.
     * @param {WikiPageUpdateArgs} args - Arguments to update one WikiPage.
     * @example
     * // Update one WikiPage
     * const wikiPage = await prisma.wikiPage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WikiPageUpdateArgs>(args: SelectSubset<T, WikiPageUpdateArgs<ExtArgs>>): Prisma__WikiPageClient<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WikiPages.
     * @param {WikiPageDeleteManyArgs} args - Arguments to filter WikiPages to delete.
     * @example
     * // Delete a few WikiPages
     * const { count } = await prisma.wikiPage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WikiPageDeleteManyArgs>(args?: SelectSubset<T, WikiPageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WikiPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WikiPageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WikiPages
     * const wikiPage = await prisma.wikiPage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WikiPageUpdateManyArgs>(args: SelectSubset<T, WikiPageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WikiPages and returns the data updated in the database.
     * @param {WikiPageUpdateManyAndReturnArgs} args - Arguments to update many WikiPages.
     * @example
     * // Update many WikiPages
     * const wikiPage = await prisma.wikiPage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WikiPages and only return the `id`
     * const wikiPageWithIdOnly = await prisma.wikiPage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WikiPageUpdateManyAndReturnArgs>(args: SelectSubset<T, WikiPageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WikiPage.
     * @param {WikiPageUpsertArgs} args - Arguments to update or create a WikiPage.
     * @example
     * // Update or create a WikiPage
     * const wikiPage = await prisma.wikiPage.upsert({
     *   create: {
     *     // ... data to create a WikiPage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WikiPage we want to update
     *   }
     * })
     */
    upsert<T extends WikiPageUpsertArgs>(args: SelectSubset<T, WikiPageUpsertArgs<ExtArgs>>): Prisma__WikiPageClient<$Result.GetResult<Prisma.$WikiPagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WikiPages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WikiPageCountArgs} args - Arguments to filter WikiPages to count.
     * @example
     * // Count the number of WikiPages
     * const count = await prisma.wikiPage.count({
     *   where: {
     *     // ... the filter for the WikiPages we want to count
     *   }
     * })
    **/
    count<T extends WikiPageCountArgs>(
      args?: Subset<T, WikiPageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WikiPageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WikiPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WikiPageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WikiPageAggregateArgs>(args: Subset<T, WikiPageAggregateArgs>): Prisma.PrismaPromise<GetWikiPageAggregateType<T>>

    /**
     * Group by WikiPage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WikiPageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WikiPageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WikiPageGroupByArgs['orderBy'] }
        : { orderBy?: WikiPageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WikiPageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWikiPageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WikiPage model
   */
  readonly fields: WikiPageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WikiPage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WikiPageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WikiPage model
   */
  interface WikiPageFieldRefs {
    readonly id: FieldRef<"WikiPage", 'String'>
    readonly createdAt: FieldRef<"WikiPage", 'DateTime'>
    readonly updatedAt: FieldRef<"WikiPage", 'DateTime'>
    readonly title: FieldRef<"WikiPage", 'String'>
    readonly slug: FieldRef<"WikiPage", 'String'>
    readonly content: FieldRef<"WikiPage", 'String'>
    readonly category: FieldRef<"WikiPage", 'String'>
    readonly country: FieldRef<"WikiPage", 'String'>
    readonly views: FieldRef<"WikiPage", 'Int'>
    readonly featured: FieldRef<"WikiPage", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * WikiPage findUnique
   */
  export type WikiPageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * Filter, which WikiPage to fetch.
     */
    where: WikiPageWhereUniqueInput
  }

  /**
   * WikiPage findUniqueOrThrow
   */
  export type WikiPageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * Filter, which WikiPage to fetch.
     */
    where: WikiPageWhereUniqueInput
  }

  /**
   * WikiPage findFirst
   */
  export type WikiPageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * Filter, which WikiPage to fetch.
     */
    where?: WikiPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WikiPages to fetch.
     */
    orderBy?: WikiPageOrderByWithRelationInput | WikiPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WikiPages.
     */
    cursor?: WikiPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WikiPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WikiPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WikiPages.
     */
    distinct?: WikiPageScalarFieldEnum | WikiPageScalarFieldEnum[]
  }

  /**
   * WikiPage findFirstOrThrow
   */
  export type WikiPageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * Filter, which WikiPage to fetch.
     */
    where?: WikiPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WikiPages to fetch.
     */
    orderBy?: WikiPageOrderByWithRelationInput | WikiPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WikiPages.
     */
    cursor?: WikiPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WikiPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WikiPages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WikiPages.
     */
    distinct?: WikiPageScalarFieldEnum | WikiPageScalarFieldEnum[]
  }

  /**
   * WikiPage findMany
   */
  export type WikiPageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * Filter, which WikiPages to fetch.
     */
    where?: WikiPageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WikiPages to fetch.
     */
    orderBy?: WikiPageOrderByWithRelationInput | WikiPageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WikiPages.
     */
    cursor?: WikiPageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WikiPages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WikiPages.
     */
    skip?: number
    distinct?: WikiPageScalarFieldEnum | WikiPageScalarFieldEnum[]
  }

  /**
   * WikiPage create
   */
  export type WikiPageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * The data needed to create a WikiPage.
     */
    data: XOR<WikiPageCreateInput, WikiPageUncheckedCreateInput>
  }

  /**
   * WikiPage createMany
   */
  export type WikiPageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WikiPages.
     */
    data: WikiPageCreateManyInput | WikiPageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WikiPage createManyAndReturn
   */
  export type WikiPageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * The data used to create many WikiPages.
     */
    data: WikiPageCreateManyInput | WikiPageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WikiPage update
   */
  export type WikiPageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * The data needed to update a WikiPage.
     */
    data: XOR<WikiPageUpdateInput, WikiPageUncheckedUpdateInput>
    /**
     * Choose, which WikiPage to update.
     */
    where: WikiPageWhereUniqueInput
  }

  /**
   * WikiPage updateMany
   */
  export type WikiPageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WikiPages.
     */
    data: XOR<WikiPageUpdateManyMutationInput, WikiPageUncheckedUpdateManyInput>
    /**
     * Filter which WikiPages to update
     */
    where?: WikiPageWhereInput
    /**
     * Limit how many WikiPages to update.
     */
    limit?: number
  }

  /**
   * WikiPage updateManyAndReturn
   */
  export type WikiPageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * The data used to update WikiPages.
     */
    data: XOR<WikiPageUpdateManyMutationInput, WikiPageUncheckedUpdateManyInput>
    /**
     * Filter which WikiPages to update
     */
    where?: WikiPageWhereInput
    /**
     * Limit how many WikiPages to update.
     */
    limit?: number
  }

  /**
   * WikiPage upsert
   */
  export type WikiPageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * The filter to search for the WikiPage to update in case it exists.
     */
    where: WikiPageWhereUniqueInput
    /**
     * In case the WikiPage found by the `where` argument doesn't exist, create a new WikiPage with this data.
     */
    create: XOR<WikiPageCreateInput, WikiPageUncheckedCreateInput>
    /**
     * In case the WikiPage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WikiPageUpdateInput, WikiPageUncheckedUpdateInput>
  }

  /**
   * WikiPage delete
   */
  export type WikiPageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
    /**
     * Filter which WikiPage to delete.
     */
    where: WikiPageWhereUniqueInput
  }

  /**
   * WikiPage deleteMany
   */
  export type WikiPageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WikiPages to delete
     */
    where?: WikiPageWhereInput
    /**
     * Limit how many WikiPages to delete.
     */
    limit?: number
  }

  /**
   * WikiPage without action
   */
  export type WikiPageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WikiPage
     */
    select?: WikiPageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WikiPage
     */
    omit?: WikiPageOmit<ExtArgs> | null
  }


  /**
   * Model SearchCache
   */

  export type AggregateSearchCache = {
    _count: SearchCacheCountAggregateOutputType | null
    _avg: SearchCacheAvgAggregateOutputType | null
    _sum: SearchCacheSumAggregateOutputType | null
    _min: SearchCacheMinAggregateOutputType | null
    _max: SearchCacheMaxAggregateOutputType | null
  }

  export type SearchCacheAvgAggregateOutputType = {
    hitCount: number | null
  }

  export type SearchCacheSumAggregateOutputType = {
    hitCount: number | null
  }

  export type SearchCacheMinAggregateOutputType = {
    id: string | null
    query: string | null
    results: string | null
    lastUpdated: Date | null
    hitCount: number | null
  }

  export type SearchCacheMaxAggregateOutputType = {
    id: string | null
    query: string | null
    results: string | null
    lastUpdated: Date | null
    hitCount: number | null
  }

  export type SearchCacheCountAggregateOutputType = {
    id: number
    query: number
    results: number
    lastUpdated: number
    hitCount: number
    _all: number
  }


  export type SearchCacheAvgAggregateInputType = {
    hitCount?: true
  }

  export type SearchCacheSumAggregateInputType = {
    hitCount?: true
  }

  export type SearchCacheMinAggregateInputType = {
    id?: true
    query?: true
    results?: true
    lastUpdated?: true
    hitCount?: true
  }

  export type SearchCacheMaxAggregateInputType = {
    id?: true
    query?: true
    results?: true
    lastUpdated?: true
    hitCount?: true
  }

  export type SearchCacheCountAggregateInputType = {
    id?: true
    query?: true
    results?: true
    lastUpdated?: true
    hitCount?: true
    _all?: true
  }

  export type SearchCacheAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchCache to aggregate.
     */
    where?: SearchCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchCaches to fetch.
     */
    orderBy?: SearchCacheOrderByWithRelationInput | SearchCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SearchCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchCaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SearchCaches
    **/
    _count?: true | SearchCacheCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SearchCacheAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SearchCacheSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SearchCacheMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SearchCacheMaxAggregateInputType
  }

  export type GetSearchCacheAggregateType<T extends SearchCacheAggregateArgs> = {
        [P in keyof T & keyof AggregateSearchCache]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSearchCache[P]>
      : GetScalarType<T[P], AggregateSearchCache[P]>
  }




  export type SearchCacheGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchCacheWhereInput
    orderBy?: SearchCacheOrderByWithAggregationInput | SearchCacheOrderByWithAggregationInput[]
    by: SearchCacheScalarFieldEnum[] | SearchCacheScalarFieldEnum
    having?: SearchCacheScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SearchCacheCountAggregateInputType | true
    _avg?: SearchCacheAvgAggregateInputType
    _sum?: SearchCacheSumAggregateInputType
    _min?: SearchCacheMinAggregateInputType
    _max?: SearchCacheMaxAggregateInputType
  }

  export type SearchCacheGroupByOutputType = {
    id: string
    query: string
    results: string
    lastUpdated: Date
    hitCount: number
    _count: SearchCacheCountAggregateOutputType | null
    _avg: SearchCacheAvgAggregateOutputType | null
    _sum: SearchCacheSumAggregateOutputType | null
    _min: SearchCacheMinAggregateOutputType | null
    _max: SearchCacheMaxAggregateOutputType | null
  }

  type GetSearchCacheGroupByPayload<T extends SearchCacheGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SearchCacheGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SearchCacheGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SearchCacheGroupByOutputType[P]>
            : GetScalarType<T[P], SearchCacheGroupByOutputType[P]>
        }
      >
    >


  export type SearchCacheSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    query?: boolean
    results?: boolean
    lastUpdated?: boolean
    hitCount?: boolean
  }, ExtArgs["result"]["searchCache"]>

  export type SearchCacheSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    query?: boolean
    results?: boolean
    lastUpdated?: boolean
    hitCount?: boolean
  }, ExtArgs["result"]["searchCache"]>

  export type SearchCacheSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    query?: boolean
    results?: boolean
    lastUpdated?: boolean
    hitCount?: boolean
  }, ExtArgs["result"]["searchCache"]>

  export type SearchCacheSelectScalar = {
    id?: boolean
    query?: boolean
    results?: boolean
    lastUpdated?: boolean
    hitCount?: boolean
  }

  export type SearchCacheOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "query" | "results" | "lastUpdated" | "hitCount", ExtArgs["result"]["searchCache"]>

  export type $SearchCachePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SearchCache"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      query: string
      results: string
      lastUpdated: Date
      hitCount: number
    }, ExtArgs["result"]["searchCache"]>
    composites: {}
  }

  type SearchCacheGetPayload<S extends boolean | null | undefined | SearchCacheDefaultArgs> = $Result.GetResult<Prisma.$SearchCachePayload, S>

  type SearchCacheCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SearchCacheFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SearchCacheCountAggregateInputType | true
    }

  export interface SearchCacheDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SearchCache'], meta: { name: 'SearchCache' } }
    /**
     * Find zero or one SearchCache that matches the filter.
     * @param {SearchCacheFindUniqueArgs} args - Arguments to find a SearchCache
     * @example
     * // Get one SearchCache
     * const searchCache = await prisma.searchCache.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SearchCacheFindUniqueArgs>(args: SelectSubset<T, SearchCacheFindUniqueArgs<ExtArgs>>): Prisma__SearchCacheClient<$Result.GetResult<Prisma.$SearchCachePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SearchCache that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SearchCacheFindUniqueOrThrowArgs} args - Arguments to find a SearchCache
     * @example
     * // Get one SearchCache
     * const searchCache = await prisma.searchCache.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SearchCacheFindUniqueOrThrowArgs>(args: SelectSubset<T, SearchCacheFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SearchCacheClient<$Result.GetResult<Prisma.$SearchCachePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchCache that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchCacheFindFirstArgs} args - Arguments to find a SearchCache
     * @example
     * // Get one SearchCache
     * const searchCache = await prisma.searchCache.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SearchCacheFindFirstArgs>(args?: SelectSubset<T, SearchCacheFindFirstArgs<ExtArgs>>): Prisma__SearchCacheClient<$Result.GetResult<Prisma.$SearchCachePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchCache that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchCacheFindFirstOrThrowArgs} args - Arguments to find a SearchCache
     * @example
     * // Get one SearchCache
     * const searchCache = await prisma.searchCache.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SearchCacheFindFirstOrThrowArgs>(args?: SelectSubset<T, SearchCacheFindFirstOrThrowArgs<ExtArgs>>): Prisma__SearchCacheClient<$Result.GetResult<Prisma.$SearchCachePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SearchCaches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchCacheFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SearchCaches
     * const searchCaches = await prisma.searchCache.findMany()
     * 
     * // Get first 10 SearchCaches
     * const searchCaches = await prisma.searchCache.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const searchCacheWithIdOnly = await prisma.searchCache.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SearchCacheFindManyArgs>(args?: SelectSubset<T, SearchCacheFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchCachePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SearchCache.
     * @param {SearchCacheCreateArgs} args - Arguments to create a SearchCache.
     * @example
     * // Create one SearchCache
     * const SearchCache = await prisma.searchCache.create({
     *   data: {
     *     // ... data to create a SearchCache
     *   }
     * })
     * 
     */
    create<T extends SearchCacheCreateArgs>(args: SelectSubset<T, SearchCacheCreateArgs<ExtArgs>>): Prisma__SearchCacheClient<$Result.GetResult<Prisma.$SearchCachePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SearchCaches.
     * @param {SearchCacheCreateManyArgs} args - Arguments to create many SearchCaches.
     * @example
     * // Create many SearchCaches
     * const searchCache = await prisma.searchCache.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SearchCacheCreateManyArgs>(args?: SelectSubset<T, SearchCacheCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SearchCaches and returns the data saved in the database.
     * @param {SearchCacheCreateManyAndReturnArgs} args - Arguments to create many SearchCaches.
     * @example
     * // Create many SearchCaches
     * const searchCache = await prisma.searchCache.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SearchCaches and only return the `id`
     * const searchCacheWithIdOnly = await prisma.searchCache.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SearchCacheCreateManyAndReturnArgs>(args?: SelectSubset<T, SearchCacheCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchCachePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SearchCache.
     * @param {SearchCacheDeleteArgs} args - Arguments to delete one SearchCache.
     * @example
     * // Delete one SearchCache
     * const SearchCache = await prisma.searchCache.delete({
     *   where: {
     *     // ... filter to delete one SearchCache
     *   }
     * })
     * 
     */
    delete<T extends SearchCacheDeleteArgs>(args: SelectSubset<T, SearchCacheDeleteArgs<ExtArgs>>): Prisma__SearchCacheClient<$Result.GetResult<Prisma.$SearchCachePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SearchCache.
     * @param {SearchCacheUpdateArgs} args - Arguments to update one SearchCache.
     * @example
     * // Update one SearchCache
     * const searchCache = await prisma.searchCache.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SearchCacheUpdateArgs>(args: SelectSubset<T, SearchCacheUpdateArgs<ExtArgs>>): Prisma__SearchCacheClient<$Result.GetResult<Prisma.$SearchCachePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SearchCaches.
     * @param {SearchCacheDeleteManyArgs} args - Arguments to filter SearchCaches to delete.
     * @example
     * // Delete a few SearchCaches
     * const { count } = await prisma.searchCache.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SearchCacheDeleteManyArgs>(args?: SelectSubset<T, SearchCacheDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SearchCaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchCacheUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SearchCaches
     * const searchCache = await prisma.searchCache.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SearchCacheUpdateManyArgs>(args: SelectSubset<T, SearchCacheUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SearchCaches and returns the data updated in the database.
     * @param {SearchCacheUpdateManyAndReturnArgs} args - Arguments to update many SearchCaches.
     * @example
     * // Update many SearchCaches
     * const searchCache = await prisma.searchCache.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SearchCaches and only return the `id`
     * const searchCacheWithIdOnly = await prisma.searchCache.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SearchCacheUpdateManyAndReturnArgs>(args: SelectSubset<T, SearchCacheUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchCachePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SearchCache.
     * @param {SearchCacheUpsertArgs} args - Arguments to update or create a SearchCache.
     * @example
     * // Update or create a SearchCache
     * const searchCache = await prisma.searchCache.upsert({
     *   create: {
     *     // ... data to create a SearchCache
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SearchCache we want to update
     *   }
     * })
     */
    upsert<T extends SearchCacheUpsertArgs>(args: SelectSubset<T, SearchCacheUpsertArgs<ExtArgs>>): Prisma__SearchCacheClient<$Result.GetResult<Prisma.$SearchCachePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SearchCaches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchCacheCountArgs} args - Arguments to filter SearchCaches to count.
     * @example
     * // Count the number of SearchCaches
     * const count = await prisma.searchCache.count({
     *   where: {
     *     // ... the filter for the SearchCaches we want to count
     *   }
     * })
    **/
    count<T extends SearchCacheCountArgs>(
      args?: Subset<T, SearchCacheCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SearchCacheCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SearchCache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchCacheAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SearchCacheAggregateArgs>(args: Subset<T, SearchCacheAggregateArgs>): Prisma.PrismaPromise<GetSearchCacheAggregateType<T>>

    /**
     * Group by SearchCache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchCacheGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SearchCacheGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SearchCacheGroupByArgs['orderBy'] }
        : { orderBy?: SearchCacheGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SearchCacheGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSearchCacheGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SearchCache model
   */
  readonly fields: SearchCacheFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SearchCache.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SearchCacheClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SearchCache model
   */
  interface SearchCacheFieldRefs {
    readonly id: FieldRef<"SearchCache", 'String'>
    readonly query: FieldRef<"SearchCache", 'String'>
    readonly results: FieldRef<"SearchCache", 'String'>
    readonly lastUpdated: FieldRef<"SearchCache", 'DateTime'>
    readonly hitCount: FieldRef<"SearchCache", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SearchCache findUnique
   */
  export type SearchCacheFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchCache
     */
    select?: SearchCacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchCache
     */
    omit?: SearchCacheOmit<ExtArgs> | null
    /**
     * Filter, which SearchCache to fetch.
     */
    where: SearchCacheWhereUniqueInput
  }

  /**
   * SearchCache findUniqueOrThrow
   */
  export type SearchCacheFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchCache
     */
    select?: SearchCacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchCache
     */
    omit?: SearchCacheOmit<ExtArgs> | null
    /**
     * Filter, which SearchCache to fetch.
     */
    where: SearchCacheWhereUniqueInput
  }

  /**
   * SearchCache findFirst
   */
  export type SearchCacheFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchCache
     */
    select?: SearchCacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchCache
     */
    omit?: SearchCacheOmit<ExtArgs> | null
    /**
     * Filter, which SearchCache to fetch.
     */
    where?: SearchCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchCaches to fetch.
     */
    orderBy?: SearchCacheOrderByWithRelationInput | SearchCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchCaches.
     */
    cursor?: SearchCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchCaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchCaches.
     */
    distinct?: SearchCacheScalarFieldEnum | SearchCacheScalarFieldEnum[]
  }

  /**
   * SearchCache findFirstOrThrow
   */
  export type SearchCacheFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchCache
     */
    select?: SearchCacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchCache
     */
    omit?: SearchCacheOmit<ExtArgs> | null
    /**
     * Filter, which SearchCache to fetch.
     */
    where?: SearchCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchCaches to fetch.
     */
    orderBy?: SearchCacheOrderByWithRelationInput | SearchCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchCaches.
     */
    cursor?: SearchCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchCaches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchCaches.
     */
    distinct?: SearchCacheScalarFieldEnum | SearchCacheScalarFieldEnum[]
  }

  /**
   * SearchCache findMany
   */
  export type SearchCacheFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchCache
     */
    select?: SearchCacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchCache
     */
    omit?: SearchCacheOmit<ExtArgs> | null
    /**
     * Filter, which SearchCaches to fetch.
     */
    where?: SearchCacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchCaches to fetch.
     */
    orderBy?: SearchCacheOrderByWithRelationInput | SearchCacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SearchCaches.
     */
    cursor?: SearchCacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchCaches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchCaches.
     */
    skip?: number
    distinct?: SearchCacheScalarFieldEnum | SearchCacheScalarFieldEnum[]
  }

  /**
   * SearchCache create
   */
  export type SearchCacheCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchCache
     */
    select?: SearchCacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchCache
     */
    omit?: SearchCacheOmit<ExtArgs> | null
    /**
     * The data needed to create a SearchCache.
     */
    data: XOR<SearchCacheCreateInput, SearchCacheUncheckedCreateInput>
  }

  /**
   * SearchCache createMany
   */
  export type SearchCacheCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SearchCaches.
     */
    data: SearchCacheCreateManyInput | SearchCacheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SearchCache createManyAndReturn
   */
  export type SearchCacheCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchCache
     */
    select?: SearchCacheSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SearchCache
     */
    omit?: SearchCacheOmit<ExtArgs> | null
    /**
     * The data used to create many SearchCaches.
     */
    data: SearchCacheCreateManyInput | SearchCacheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SearchCache update
   */
  export type SearchCacheUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchCache
     */
    select?: SearchCacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchCache
     */
    omit?: SearchCacheOmit<ExtArgs> | null
    /**
     * The data needed to update a SearchCache.
     */
    data: XOR<SearchCacheUpdateInput, SearchCacheUncheckedUpdateInput>
    /**
     * Choose, which SearchCache to update.
     */
    where: SearchCacheWhereUniqueInput
  }

  /**
   * SearchCache updateMany
   */
  export type SearchCacheUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SearchCaches.
     */
    data: XOR<SearchCacheUpdateManyMutationInput, SearchCacheUncheckedUpdateManyInput>
    /**
     * Filter which SearchCaches to update
     */
    where?: SearchCacheWhereInput
    /**
     * Limit how many SearchCaches to update.
     */
    limit?: number
  }

  /**
   * SearchCache updateManyAndReturn
   */
  export type SearchCacheUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchCache
     */
    select?: SearchCacheSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SearchCache
     */
    omit?: SearchCacheOmit<ExtArgs> | null
    /**
     * The data used to update SearchCaches.
     */
    data: XOR<SearchCacheUpdateManyMutationInput, SearchCacheUncheckedUpdateManyInput>
    /**
     * Filter which SearchCaches to update
     */
    where?: SearchCacheWhereInput
    /**
     * Limit how many SearchCaches to update.
     */
    limit?: number
  }

  /**
   * SearchCache upsert
   */
  export type SearchCacheUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchCache
     */
    select?: SearchCacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchCache
     */
    omit?: SearchCacheOmit<ExtArgs> | null
    /**
     * The filter to search for the SearchCache to update in case it exists.
     */
    where: SearchCacheWhereUniqueInput
    /**
     * In case the SearchCache found by the `where` argument doesn't exist, create a new SearchCache with this data.
     */
    create: XOR<SearchCacheCreateInput, SearchCacheUncheckedCreateInput>
    /**
     * In case the SearchCache was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SearchCacheUpdateInput, SearchCacheUncheckedUpdateInput>
  }

  /**
   * SearchCache delete
   */
  export type SearchCacheDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchCache
     */
    select?: SearchCacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchCache
     */
    omit?: SearchCacheOmit<ExtArgs> | null
    /**
     * Filter which SearchCache to delete.
     */
    where: SearchCacheWhereUniqueInput
  }

  /**
   * SearchCache deleteMany
   */
  export type SearchCacheDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchCaches to delete
     */
    where?: SearchCacheWhereInput
    /**
     * Limit how many SearchCaches to delete.
     */
    limit?: number
  }

  /**
   * SearchCache without action
   */
  export type SearchCacheDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchCache
     */
    select?: SearchCacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchCache
     */
    omit?: SearchCacheOmit<ExtArgs> | null
  }


  /**
   * Model AIScamReport
   */

  export type AggregateAIScamReport = {
    _count: AIScamReportCountAggregateOutputType | null
    _avg: AIScamReportAvgAggregateOutputType | null
    _sum: AIScamReportSumAggregateOutputType | null
    _min: AIScamReportMinAggregateOutputType | null
    _max: AIScamReportMaxAggregateOutputType | null
  }

  export type AIScamReportAvgAggregateOutputType = {
    averageFinancialImpact: number | null
  }

  export type AIScamReportSumAggregateOutputType = {
    averageFinancialImpact: number | null
  }

  export type AIScamReportMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    summary: string | null
    averageRiskLevel: string | null
    averageFinancialImpact: number | null
    category: string | null
  }

  export type AIScamReportMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    summary: string | null
    averageRiskLevel: string | null
    averageFinancialImpact: number | null
    category: string | null
  }

  export type AIScamReportCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    summary: number
    averageRiskLevel: number
    averageFinancialImpact: number
    category: number
    _all: number
  }


  export type AIScamReportAvgAggregateInputType = {
    averageFinancialImpact?: true
  }

  export type AIScamReportSumAggregateInputType = {
    averageFinancialImpact?: true
  }

  export type AIScamReportMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    summary?: true
    averageRiskLevel?: true
    averageFinancialImpact?: true
    category?: true
  }

  export type AIScamReportMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    summary?: true
    averageRiskLevel?: true
    averageFinancialImpact?: true
    category?: true
  }

  export type AIScamReportCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    summary?: true
    averageRiskLevel?: true
    averageFinancialImpact?: true
    category?: true
    _all?: true
  }

  export type AIScamReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIScamReport to aggregate.
     */
    where?: AIScamReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIScamReports to fetch.
     */
    orderBy?: AIScamReportOrderByWithRelationInput | AIScamReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIScamReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIScamReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIScamReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIScamReports
    **/
    _count?: true | AIScamReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AIScamReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AIScamReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIScamReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIScamReportMaxAggregateInputType
  }

  export type GetAIScamReportAggregateType<T extends AIScamReportAggregateArgs> = {
        [P in keyof T & keyof AggregateAIScamReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIScamReport[P]>
      : GetScalarType<T[P], AggregateAIScamReport[P]>
  }




  export type AIScamReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIScamReportWhereInput
    orderBy?: AIScamReportOrderByWithAggregationInput | AIScamReportOrderByWithAggregationInput[]
    by: AIScamReportScalarFieldEnum[] | AIScamReportScalarFieldEnum
    having?: AIScamReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIScamReportCountAggregateInputType | true
    _avg?: AIScamReportAvgAggregateInputType
    _sum?: AIScamReportSumAggregateInputType
    _min?: AIScamReportMinAggregateInputType
    _max?: AIScamReportMaxAggregateInputType
  }

  export type AIScamReportGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    summary: string
    averageRiskLevel: string
    averageFinancialImpact: number
    category: string
    _count: AIScamReportCountAggregateOutputType | null
    _avg: AIScamReportAvgAggregateOutputType | null
    _sum: AIScamReportSumAggregateOutputType | null
    _min: AIScamReportMinAggregateOutputType | null
    _max: AIScamReportMaxAggregateOutputType | null
  }

  type GetAIScamReportGroupByPayload<T extends AIScamReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIScamReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIScamReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIScamReportGroupByOutputType[P]>
            : GetScalarType<T[P], AIScamReportGroupByOutputType[P]>
        }
      >
    >


  export type AIScamReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    summary?: boolean
    averageRiskLevel?: boolean
    averageFinancialImpact?: boolean
    category?: boolean
  }, ExtArgs["result"]["aIScamReport"]>

  export type AIScamReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    summary?: boolean
    averageRiskLevel?: boolean
    averageFinancialImpact?: boolean
    category?: boolean
  }, ExtArgs["result"]["aIScamReport"]>

  export type AIScamReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    summary?: boolean
    averageRiskLevel?: boolean
    averageFinancialImpact?: boolean
    category?: boolean
  }, ExtArgs["result"]["aIScamReport"]>

  export type AIScamReportSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    summary?: boolean
    averageRiskLevel?: boolean
    averageFinancialImpact?: boolean
    category?: boolean
  }

  export type AIScamReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "summary" | "averageRiskLevel" | "averageFinancialImpact" | "category", ExtArgs["result"]["aIScamReport"]>

  export type $AIScamReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIScamReport"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      summary: string
      averageRiskLevel: string
      averageFinancialImpact: number
      category: string
    }, ExtArgs["result"]["aIScamReport"]>
    composites: {}
  }

  type AIScamReportGetPayload<S extends boolean | null | undefined | AIScamReportDefaultArgs> = $Result.GetResult<Prisma.$AIScamReportPayload, S>

  type AIScamReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AIScamReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AIScamReportCountAggregateInputType | true
    }

  export interface AIScamReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIScamReport'], meta: { name: 'AIScamReport' } }
    /**
     * Find zero or one AIScamReport that matches the filter.
     * @param {AIScamReportFindUniqueArgs} args - Arguments to find a AIScamReport
     * @example
     * // Get one AIScamReport
     * const aIScamReport = await prisma.aIScamReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIScamReportFindUniqueArgs>(args: SelectSubset<T, AIScamReportFindUniqueArgs<ExtArgs>>): Prisma__AIScamReportClient<$Result.GetResult<Prisma.$AIScamReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AIScamReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AIScamReportFindUniqueOrThrowArgs} args - Arguments to find a AIScamReport
     * @example
     * // Get one AIScamReport
     * const aIScamReport = await prisma.aIScamReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIScamReportFindUniqueOrThrowArgs>(args: SelectSubset<T, AIScamReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIScamReportClient<$Result.GetResult<Prisma.$AIScamReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIScamReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIScamReportFindFirstArgs} args - Arguments to find a AIScamReport
     * @example
     * // Get one AIScamReport
     * const aIScamReport = await prisma.aIScamReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIScamReportFindFirstArgs>(args?: SelectSubset<T, AIScamReportFindFirstArgs<ExtArgs>>): Prisma__AIScamReportClient<$Result.GetResult<Prisma.$AIScamReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AIScamReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIScamReportFindFirstOrThrowArgs} args - Arguments to find a AIScamReport
     * @example
     * // Get one AIScamReport
     * const aIScamReport = await prisma.aIScamReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIScamReportFindFirstOrThrowArgs>(args?: SelectSubset<T, AIScamReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIScamReportClient<$Result.GetResult<Prisma.$AIScamReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AIScamReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIScamReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIScamReports
     * const aIScamReports = await prisma.aIScamReport.findMany()
     * 
     * // Get first 10 AIScamReports
     * const aIScamReports = await prisma.aIScamReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIScamReportWithIdOnly = await prisma.aIScamReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIScamReportFindManyArgs>(args?: SelectSubset<T, AIScamReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIScamReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AIScamReport.
     * @param {AIScamReportCreateArgs} args - Arguments to create a AIScamReport.
     * @example
     * // Create one AIScamReport
     * const AIScamReport = await prisma.aIScamReport.create({
     *   data: {
     *     // ... data to create a AIScamReport
     *   }
     * })
     * 
     */
    create<T extends AIScamReportCreateArgs>(args: SelectSubset<T, AIScamReportCreateArgs<ExtArgs>>): Prisma__AIScamReportClient<$Result.GetResult<Prisma.$AIScamReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AIScamReports.
     * @param {AIScamReportCreateManyArgs} args - Arguments to create many AIScamReports.
     * @example
     * // Create many AIScamReports
     * const aIScamReport = await prisma.aIScamReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIScamReportCreateManyArgs>(args?: SelectSubset<T, AIScamReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIScamReports and returns the data saved in the database.
     * @param {AIScamReportCreateManyAndReturnArgs} args - Arguments to create many AIScamReports.
     * @example
     * // Create many AIScamReports
     * const aIScamReport = await prisma.aIScamReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIScamReports and only return the `id`
     * const aIScamReportWithIdOnly = await prisma.aIScamReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIScamReportCreateManyAndReturnArgs>(args?: SelectSubset<T, AIScamReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIScamReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AIScamReport.
     * @param {AIScamReportDeleteArgs} args - Arguments to delete one AIScamReport.
     * @example
     * // Delete one AIScamReport
     * const AIScamReport = await prisma.aIScamReport.delete({
     *   where: {
     *     // ... filter to delete one AIScamReport
     *   }
     * })
     * 
     */
    delete<T extends AIScamReportDeleteArgs>(args: SelectSubset<T, AIScamReportDeleteArgs<ExtArgs>>): Prisma__AIScamReportClient<$Result.GetResult<Prisma.$AIScamReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AIScamReport.
     * @param {AIScamReportUpdateArgs} args - Arguments to update one AIScamReport.
     * @example
     * // Update one AIScamReport
     * const aIScamReport = await prisma.aIScamReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIScamReportUpdateArgs>(args: SelectSubset<T, AIScamReportUpdateArgs<ExtArgs>>): Prisma__AIScamReportClient<$Result.GetResult<Prisma.$AIScamReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AIScamReports.
     * @param {AIScamReportDeleteManyArgs} args - Arguments to filter AIScamReports to delete.
     * @example
     * // Delete a few AIScamReports
     * const { count } = await prisma.aIScamReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIScamReportDeleteManyArgs>(args?: SelectSubset<T, AIScamReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIScamReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIScamReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIScamReports
     * const aIScamReport = await prisma.aIScamReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIScamReportUpdateManyArgs>(args: SelectSubset<T, AIScamReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIScamReports and returns the data updated in the database.
     * @param {AIScamReportUpdateManyAndReturnArgs} args - Arguments to update many AIScamReports.
     * @example
     * // Update many AIScamReports
     * const aIScamReport = await prisma.aIScamReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AIScamReports and only return the `id`
     * const aIScamReportWithIdOnly = await prisma.aIScamReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AIScamReportUpdateManyAndReturnArgs>(args: SelectSubset<T, AIScamReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIScamReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AIScamReport.
     * @param {AIScamReportUpsertArgs} args - Arguments to update or create a AIScamReport.
     * @example
     * // Update or create a AIScamReport
     * const aIScamReport = await prisma.aIScamReport.upsert({
     *   create: {
     *     // ... data to create a AIScamReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIScamReport we want to update
     *   }
     * })
     */
    upsert<T extends AIScamReportUpsertArgs>(args: SelectSubset<T, AIScamReportUpsertArgs<ExtArgs>>): Prisma__AIScamReportClient<$Result.GetResult<Prisma.$AIScamReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AIScamReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIScamReportCountArgs} args - Arguments to filter AIScamReports to count.
     * @example
     * // Count the number of AIScamReports
     * const count = await prisma.aIScamReport.count({
     *   where: {
     *     // ... the filter for the AIScamReports we want to count
     *   }
     * })
    **/
    count<T extends AIScamReportCountArgs>(
      args?: Subset<T, AIScamReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIScamReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIScamReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIScamReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIScamReportAggregateArgs>(args: Subset<T, AIScamReportAggregateArgs>): Prisma.PrismaPromise<GetAIScamReportAggregateType<T>>

    /**
     * Group by AIScamReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIScamReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIScamReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIScamReportGroupByArgs['orderBy'] }
        : { orderBy?: AIScamReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIScamReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIScamReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIScamReport model
   */
  readonly fields: AIScamReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIScamReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIScamReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIScamReport model
   */
  interface AIScamReportFieldRefs {
    readonly id: FieldRef<"AIScamReport", 'String'>
    readonly createdAt: FieldRef<"AIScamReport", 'DateTime'>
    readonly updatedAt: FieldRef<"AIScamReport", 'DateTime'>
    readonly summary: FieldRef<"AIScamReport", 'String'>
    readonly averageRiskLevel: FieldRef<"AIScamReport", 'String'>
    readonly averageFinancialImpact: FieldRef<"AIScamReport", 'Float'>
    readonly category: FieldRef<"AIScamReport", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AIScamReport findUnique
   */
  export type AIScamReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIScamReport
     */
    select?: AIScamReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIScamReport
     */
    omit?: AIScamReportOmit<ExtArgs> | null
    /**
     * Filter, which AIScamReport to fetch.
     */
    where: AIScamReportWhereUniqueInput
  }

  /**
   * AIScamReport findUniqueOrThrow
   */
  export type AIScamReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIScamReport
     */
    select?: AIScamReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIScamReport
     */
    omit?: AIScamReportOmit<ExtArgs> | null
    /**
     * Filter, which AIScamReport to fetch.
     */
    where: AIScamReportWhereUniqueInput
  }

  /**
   * AIScamReport findFirst
   */
  export type AIScamReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIScamReport
     */
    select?: AIScamReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIScamReport
     */
    omit?: AIScamReportOmit<ExtArgs> | null
    /**
     * Filter, which AIScamReport to fetch.
     */
    where?: AIScamReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIScamReports to fetch.
     */
    orderBy?: AIScamReportOrderByWithRelationInput | AIScamReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIScamReports.
     */
    cursor?: AIScamReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIScamReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIScamReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIScamReports.
     */
    distinct?: AIScamReportScalarFieldEnum | AIScamReportScalarFieldEnum[]
  }

  /**
   * AIScamReport findFirstOrThrow
   */
  export type AIScamReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIScamReport
     */
    select?: AIScamReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIScamReport
     */
    omit?: AIScamReportOmit<ExtArgs> | null
    /**
     * Filter, which AIScamReport to fetch.
     */
    where?: AIScamReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIScamReports to fetch.
     */
    orderBy?: AIScamReportOrderByWithRelationInput | AIScamReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIScamReports.
     */
    cursor?: AIScamReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIScamReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIScamReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIScamReports.
     */
    distinct?: AIScamReportScalarFieldEnum | AIScamReportScalarFieldEnum[]
  }

  /**
   * AIScamReport findMany
   */
  export type AIScamReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIScamReport
     */
    select?: AIScamReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIScamReport
     */
    omit?: AIScamReportOmit<ExtArgs> | null
    /**
     * Filter, which AIScamReports to fetch.
     */
    where?: AIScamReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIScamReports to fetch.
     */
    orderBy?: AIScamReportOrderByWithRelationInput | AIScamReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIScamReports.
     */
    cursor?: AIScamReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIScamReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIScamReports.
     */
    skip?: number
    distinct?: AIScamReportScalarFieldEnum | AIScamReportScalarFieldEnum[]
  }

  /**
   * AIScamReport create
   */
  export type AIScamReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIScamReport
     */
    select?: AIScamReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIScamReport
     */
    omit?: AIScamReportOmit<ExtArgs> | null
    /**
     * The data needed to create a AIScamReport.
     */
    data: XOR<AIScamReportCreateInput, AIScamReportUncheckedCreateInput>
  }

  /**
   * AIScamReport createMany
   */
  export type AIScamReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIScamReports.
     */
    data: AIScamReportCreateManyInput | AIScamReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIScamReport createManyAndReturn
   */
  export type AIScamReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIScamReport
     */
    select?: AIScamReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIScamReport
     */
    omit?: AIScamReportOmit<ExtArgs> | null
    /**
     * The data used to create many AIScamReports.
     */
    data: AIScamReportCreateManyInput | AIScamReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIScamReport update
   */
  export type AIScamReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIScamReport
     */
    select?: AIScamReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIScamReport
     */
    omit?: AIScamReportOmit<ExtArgs> | null
    /**
     * The data needed to update a AIScamReport.
     */
    data: XOR<AIScamReportUpdateInput, AIScamReportUncheckedUpdateInput>
    /**
     * Choose, which AIScamReport to update.
     */
    where: AIScamReportWhereUniqueInput
  }

  /**
   * AIScamReport updateMany
   */
  export type AIScamReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIScamReports.
     */
    data: XOR<AIScamReportUpdateManyMutationInput, AIScamReportUncheckedUpdateManyInput>
    /**
     * Filter which AIScamReports to update
     */
    where?: AIScamReportWhereInput
    /**
     * Limit how many AIScamReports to update.
     */
    limit?: number
  }

  /**
   * AIScamReport updateManyAndReturn
   */
  export type AIScamReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIScamReport
     */
    select?: AIScamReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AIScamReport
     */
    omit?: AIScamReportOmit<ExtArgs> | null
    /**
     * The data used to update AIScamReports.
     */
    data: XOR<AIScamReportUpdateManyMutationInput, AIScamReportUncheckedUpdateManyInput>
    /**
     * Filter which AIScamReports to update
     */
    where?: AIScamReportWhereInput
    /**
     * Limit how many AIScamReports to update.
     */
    limit?: number
  }

  /**
   * AIScamReport upsert
   */
  export type AIScamReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIScamReport
     */
    select?: AIScamReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIScamReport
     */
    omit?: AIScamReportOmit<ExtArgs> | null
    /**
     * The filter to search for the AIScamReport to update in case it exists.
     */
    where: AIScamReportWhereUniqueInput
    /**
     * In case the AIScamReport found by the `where` argument doesn't exist, create a new AIScamReport with this data.
     */
    create: XOR<AIScamReportCreateInput, AIScamReportUncheckedCreateInput>
    /**
     * In case the AIScamReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIScamReportUpdateInput, AIScamReportUncheckedUpdateInput>
  }

  /**
   * AIScamReport delete
   */
  export type AIScamReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIScamReport
     */
    select?: AIScamReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIScamReport
     */
    omit?: AIScamReportOmit<ExtArgs> | null
    /**
     * Filter which AIScamReport to delete.
     */
    where: AIScamReportWhereUniqueInput
  }

  /**
   * AIScamReport deleteMany
   */
  export type AIScamReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIScamReports to delete
     */
    where?: AIScamReportWhereInput
    /**
     * Limit how many AIScamReports to delete.
     */
    limit?: number
  }

  /**
   * AIScamReport without action
   */
  export type AIScamReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIScamReport
     */
    select?: AIScamReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AIScamReport
     */
    omit?: AIScamReportOmit<ExtArgs> | null
  }


  /**
   * Model ScamType
   */

  export type AggregateScamType = {
    _count: ScamTypeCountAggregateOutputType | null
    _min: ScamTypeMinAggregateOutputType | null
    _max: ScamTypeMaxAggregateOutputType | null
  }

  export type ScamTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    createdBy: string | null
    isApproved: boolean | null
    isUserCreated: boolean | null
    moderatedAt: Date | null
    moderatedBy: string | null
  }

  export type ScamTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    createdBy: string | null
    isApproved: boolean | null
    isUserCreated: boolean | null
    moderatedAt: Date | null
    moderatedBy: string | null
  }

  export type ScamTypeCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    createdBy: number
    isApproved: number
    isUserCreated: number
    moderatedAt: number
    moderatedBy: number
    _all: number
  }


  export type ScamTypeMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    createdBy?: true
    isApproved?: true
    isUserCreated?: true
    moderatedAt?: true
    moderatedBy?: true
  }

  export type ScamTypeMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    createdBy?: true
    isApproved?: true
    isUserCreated?: true
    moderatedAt?: true
    moderatedBy?: true
  }

  export type ScamTypeCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    createdBy?: true
    isApproved?: true
    isUserCreated?: true
    moderatedAt?: true
    moderatedBy?: true
    _all?: true
  }

  export type ScamTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScamType to aggregate.
     */
    where?: ScamTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScamTypes to fetch.
     */
    orderBy?: ScamTypeOrderByWithRelationInput | ScamTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScamTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScamTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScamTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScamTypes
    **/
    _count?: true | ScamTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScamTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScamTypeMaxAggregateInputType
  }

  export type GetScamTypeAggregateType<T extends ScamTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateScamType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScamType[P]>
      : GetScalarType<T[P], AggregateScamType[P]>
  }




  export type ScamTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScamTypeWhereInput
    orderBy?: ScamTypeOrderByWithAggregationInput | ScamTypeOrderByWithAggregationInput[]
    by: ScamTypeScalarFieldEnum[] | ScamTypeScalarFieldEnum
    having?: ScamTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScamTypeCountAggregateInputType | true
    _min?: ScamTypeMinAggregateInputType
    _max?: ScamTypeMaxAggregateInputType
  }

  export type ScamTypeGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    createdBy: string | null
    isApproved: boolean
    isUserCreated: boolean
    moderatedAt: Date | null
    moderatedBy: string | null
    _count: ScamTypeCountAggregateOutputType | null
    _min: ScamTypeMinAggregateOutputType | null
    _max: ScamTypeMaxAggregateOutputType | null
  }

  type GetScamTypeGroupByPayload<T extends ScamTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScamTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScamTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScamTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ScamTypeGroupByOutputType[P]>
        }
      >
    >


  export type ScamTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    createdBy?: boolean
    isApproved?: boolean
    isUserCreated?: boolean
    moderatedAt?: boolean
    moderatedBy?: boolean
    contactLinks?: boolean | ScamType$contactLinksArgs<ExtArgs>
    postLinks?: boolean | ScamType$postLinksArgs<ExtArgs>
    reports?: boolean | ScamType$reportsArgs<ExtArgs>
    severityRecords?: boolean | ScamType$severityRecordsArgs<ExtArgs>
    _count?: boolean | ScamTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scamType"]>

  export type ScamTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    createdBy?: boolean
    isApproved?: boolean
    isUserCreated?: boolean
    moderatedAt?: boolean
    moderatedBy?: boolean
  }, ExtArgs["result"]["scamType"]>

  export type ScamTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    createdBy?: boolean
    isApproved?: boolean
    isUserCreated?: boolean
    moderatedAt?: boolean
    moderatedBy?: boolean
  }, ExtArgs["result"]["scamType"]>

  export type ScamTypeSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    createdBy?: boolean
    isApproved?: boolean
    isUserCreated?: boolean
    moderatedAt?: boolean
    moderatedBy?: boolean
  }

  export type ScamTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "createdBy" | "isApproved" | "isUserCreated" | "moderatedAt" | "moderatedBy", ExtArgs["result"]["scamType"]>
  export type ScamTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contactLinks?: boolean | ScamType$contactLinksArgs<ExtArgs>
    postLinks?: boolean | ScamType$postLinksArgs<ExtArgs>
    reports?: boolean | ScamType$reportsArgs<ExtArgs>
    severityRecords?: boolean | ScamType$severityRecordsArgs<ExtArgs>
    _count?: boolean | ScamTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ScamTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ScamTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ScamTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScamType"
    objects: {
      contactLinks: Prisma.$ContactScamTypePayload<ExtArgs>[]
      postLinks: Prisma.$EducationPostScamTypePayload<ExtArgs>[]
      reports: Prisma.$ScamReportPayload<ExtArgs>[]
      severityRecords: Prisma.$SeverityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      createdBy: string | null
      isApproved: boolean
      isUserCreated: boolean
      moderatedAt: Date | null
      moderatedBy: string | null
    }, ExtArgs["result"]["scamType"]>
    composites: {}
  }

  type ScamTypeGetPayload<S extends boolean | null | undefined | ScamTypeDefaultArgs> = $Result.GetResult<Prisma.$ScamTypePayload, S>

  type ScamTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScamTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScamTypeCountAggregateInputType | true
    }

  export interface ScamTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScamType'], meta: { name: 'ScamType' } }
    /**
     * Find zero or one ScamType that matches the filter.
     * @param {ScamTypeFindUniqueArgs} args - Arguments to find a ScamType
     * @example
     * // Get one ScamType
     * const scamType = await prisma.scamType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScamTypeFindUniqueArgs>(args: SelectSubset<T, ScamTypeFindUniqueArgs<ExtArgs>>): Prisma__ScamTypeClient<$Result.GetResult<Prisma.$ScamTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScamType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScamTypeFindUniqueOrThrowArgs} args - Arguments to find a ScamType
     * @example
     * // Get one ScamType
     * const scamType = await prisma.scamType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScamTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ScamTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScamTypeClient<$Result.GetResult<Prisma.$ScamTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScamType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScamTypeFindFirstArgs} args - Arguments to find a ScamType
     * @example
     * // Get one ScamType
     * const scamType = await prisma.scamType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScamTypeFindFirstArgs>(args?: SelectSubset<T, ScamTypeFindFirstArgs<ExtArgs>>): Prisma__ScamTypeClient<$Result.GetResult<Prisma.$ScamTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScamType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScamTypeFindFirstOrThrowArgs} args - Arguments to find a ScamType
     * @example
     * // Get one ScamType
     * const scamType = await prisma.scamType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScamTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ScamTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScamTypeClient<$Result.GetResult<Prisma.$ScamTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScamTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScamTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScamTypes
     * const scamTypes = await prisma.scamType.findMany()
     * 
     * // Get first 10 ScamTypes
     * const scamTypes = await prisma.scamType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scamTypeWithIdOnly = await prisma.scamType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScamTypeFindManyArgs>(args?: SelectSubset<T, ScamTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScamTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScamType.
     * @param {ScamTypeCreateArgs} args - Arguments to create a ScamType.
     * @example
     * // Create one ScamType
     * const ScamType = await prisma.scamType.create({
     *   data: {
     *     // ... data to create a ScamType
     *   }
     * })
     * 
     */
    create<T extends ScamTypeCreateArgs>(args: SelectSubset<T, ScamTypeCreateArgs<ExtArgs>>): Prisma__ScamTypeClient<$Result.GetResult<Prisma.$ScamTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScamTypes.
     * @param {ScamTypeCreateManyArgs} args - Arguments to create many ScamTypes.
     * @example
     * // Create many ScamTypes
     * const scamType = await prisma.scamType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScamTypeCreateManyArgs>(args?: SelectSubset<T, ScamTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScamTypes and returns the data saved in the database.
     * @param {ScamTypeCreateManyAndReturnArgs} args - Arguments to create many ScamTypes.
     * @example
     * // Create many ScamTypes
     * const scamType = await prisma.scamType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScamTypes and only return the `id`
     * const scamTypeWithIdOnly = await prisma.scamType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScamTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, ScamTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScamTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ScamType.
     * @param {ScamTypeDeleteArgs} args - Arguments to delete one ScamType.
     * @example
     * // Delete one ScamType
     * const ScamType = await prisma.scamType.delete({
     *   where: {
     *     // ... filter to delete one ScamType
     *   }
     * })
     * 
     */
    delete<T extends ScamTypeDeleteArgs>(args: SelectSubset<T, ScamTypeDeleteArgs<ExtArgs>>): Prisma__ScamTypeClient<$Result.GetResult<Prisma.$ScamTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScamType.
     * @param {ScamTypeUpdateArgs} args - Arguments to update one ScamType.
     * @example
     * // Update one ScamType
     * const scamType = await prisma.scamType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScamTypeUpdateArgs>(args: SelectSubset<T, ScamTypeUpdateArgs<ExtArgs>>): Prisma__ScamTypeClient<$Result.GetResult<Prisma.$ScamTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScamTypes.
     * @param {ScamTypeDeleteManyArgs} args - Arguments to filter ScamTypes to delete.
     * @example
     * // Delete a few ScamTypes
     * const { count } = await prisma.scamType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScamTypeDeleteManyArgs>(args?: SelectSubset<T, ScamTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScamTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScamTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScamTypes
     * const scamType = await prisma.scamType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScamTypeUpdateManyArgs>(args: SelectSubset<T, ScamTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScamTypes and returns the data updated in the database.
     * @param {ScamTypeUpdateManyAndReturnArgs} args - Arguments to update many ScamTypes.
     * @example
     * // Update many ScamTypes
     * const scamType = await prisma.scamType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ScamTypes and only return the `id`
     * const scamTypeWithIdOnly = await prisma.scamType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScamTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, ScamTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScamTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ScamType.
     * @param {ScamTypeUpsertArgs} args - Arguments to update or create a ScamType.
     * @example
     * // Update or create a ScamType
     * const scamType = await prisma.scamType.upsert({
     *   create: {
     *     // ... data to create a ScamType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScamType we want to update
     *   }
     * })
     */
    upsert<T extends ScamTypeUpsertArgs>(args: SelectSubset<T, ScamTypeUpsertArgs<ExtArgs>>): Prisma__ScamTypeClient<$Result.GetResult<Prisma.$ScamTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScamTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScamTypeCountArgs} args - Arguments to filter ScamTypes to count.
     * @example
     * // Count the number of ScamTypes
     * const count = await prisma.scamType.count({
     *   where: {
     *     // ... the filter for the ScamTypes we want to count
     *   }
     * })
    **/
    count<T extends ScamTypeCountArgs>(
      args?: Subset<T, ScamTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScamTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScamType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScamTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScamTypeAggregateArgs>(args: Subset<T, ScamTypeAggregateArgs>): Prisma.PrismaPromise<GetScamTypeAggregateType<T>>

    /**
     * Group by ScamType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScamTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScamTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScamTypeGroupByArgs['orderBy'] }
        : { orderBy?: ScamTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScamTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScamTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScamType model
   */
  readonly fields: ScamTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScamType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScamTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contactLinks<T extends ScamType$contactLinksArgs<ExtArgs> = {}>(args?: Subset<T, ScamType$contactLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactScamTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    postLinks<T extends ScamType$postLinksArgs<ExtArgs> = {}>(args?: Subset<T, ScamType$postLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationPostScamTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reports<T extends ScamType$reportsArgs<ExtArgs> = {}>(args?: Subset<T, ScamType$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScamReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    severityRecords<T extends ScamType$severityRecordsArgs<ExtArgs> = {}>(args?: Subset<T, ScamType$severityRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeverityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScamType model
   */
  interface ScamTypeFieldRefs {
    readonly id: FieldRef<"ScamType", 'String'>
    readonly name: FieldRef<"ScamType", 'String'>
    readonly createdAt: FieldRef<"ScamType", 'DateTime'>
    readonly createdBy: FieldRef<"ScamType", 'String'>
    readonly isApproved: FieldRef<"ScamType", 'Boolean'>
    readonly isUserCreated: FieldRef<"ScamType", 'Boolean'>
    readonly moderatedAt: FieldRef<"ScamType", 'DateTime'>
    readonly moderatedBy: FieldRef<"ScamType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ScamType findUnique
   */
  export type ScamTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScamType
     */
    select?: ScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScamType
     */
    omit?: ScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScamTypeInclude<ExtArgs> | null
    /**
     * Filter, which ScamType to fetch.
     */
    where: ScamTypeWhereUniqueInput
  }

  /**
   * ScamType findUniqueOrThrow
   */
  export type ScamTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScamType
     */
    select?: ScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScamType
     */
    omit?: ScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScamTypeInclude<ExtArgs> | null
    /**
     * Filter, which ScamType to fetch.
     */
    where: ScamTypeWhereUniqueInput
  }

  /**
   * ScamType findFirst
   */
  export type ScamTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScamType
     */
    select?: ScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScamType
     */
    omit?: ScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScamTypeInclude<ExtArgs> | null
    /**
     * Filter, which ScamType to fetch.
     */
    where?: ScamTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScamTypes to fetch.
     */
    orderBy?: ScamTypeOrderByWithRelationInput | ScamTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScamTypes.
     */
    cursor?: ScamTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScamTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScamTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScamTypes.
     */
    distinct?: ScamTypeScalarFieldEnum | ScamTypeScalarFieldEnum[]
  }

  /**
   * ScamType findFirstOrThrow
   */
  export type ScamTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScamType
     */
    select?: ScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScamType
     */
    omit?: ScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScamTypeInclude<ExtArgs> | null
    /**
     * Filter, which ScamType to fetch.
     */
    where?: ScamTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScamTypes to fetch.
     */
    orderBy?: ScamTypeOrderByWithRelationInput | ScamTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScamTypes.
     */
    cursor?: ScamTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScamTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScamTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScamTypes.
     */
    distinct?: ScamTypeScalarFieldEnum | ScamTypeScalarFieldEnum[]
  }

  /**
   * ScamType findMany
   */
  export type ScamTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScamType
     */
    select?: ScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScamType
     */
    omit?: ScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScamTypeInclude<ExtArgs> | null
    /**
     * Filter, which ScamTypes to fetch.
     */
    where?: ScamTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScamTypes to fetch.
     */
    orderBy?: ScamTypeOrderByWithRelationInput | ScamTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScamTypes.
     */
    cursor?: ScamTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScamTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScamTypes.
     */
    skip?: number
    distinct?: ScamTypeScalarFieldEnum | ScamTypeScalarFieldEnum[]
  }

  /**
   * ScamType create
   */
  export type ScamTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScamType
     */
    select?: ScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScamType
     */
    omit?: ScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScamTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ScamType.
     */
    data: XOR<ScamTypeCreateInput, ScamTypeUncheckedCreateInput>
  }

  /**
   * ScamType createMany
   */
  export type ScamTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScamTypes.
     */
    data: ScamTypeCreateManyInput | ScamTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScamType createManyAndReturn
   */
  export type ScamTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScamType
     */
    select?: ScamTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScamType
     */
    omit?: ScamTypeOmit<ExtArgs> | null
    /**
     * The data used to create many ScamTypes.
     */
    data: ScamTypeCreateManyInput | ScamTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScamType update
   */
  export type ScamTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScamType
     */
    select?: ScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScamType
     */
    omit?: ScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScamTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ScamType.
     */
    data: XOR<ScamTypeUpdateInput, ScamTypeUncheckedUpdateInput>
    /**
     * Choose, which ScamType to update.
     */
    where: ScamTypeWhereUniqueInput
  }

  /**
   * ScamType updateMany
   */
  export type ScamTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScamTypes.
     */
    data: XOR<ScamTypeUpdateManyMutationInput, ScamTypeUncheckedUpdateManyInput>
    /**
     * Filter which ScamTypes to update
     */
    where?: ScamTypeWhereInput
    /**
     * Limit how many ScamTypes to update.
     */
    limit?: number
  }

  /**
   * ScamType updateManyAndReturn
   */
  export type ScamTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScamType
     */
    select?: ScamTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScamType
     */
    omit?: ScamTypeOmit<ExtArgs> | null
    /**
     * The data used to update ScamTypes.
     */
    data: XOR<ScamTypeUpdateManyMutationInput, ScamTypeUncheckedUpdateManyInput>
    /**
     * Filter which ScamTypes to update
     */
    where?: ScamTypeWhereInput
    /**
     * Limit how many ScamTypes to update.
     */
    limit?: number
  }

  /**
   * ScamType upsert
   */
  export type ScamTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScamType
     */
    select?: ScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScamType
     */
    omit?: ScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScamTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ScamType to update in case it exists.
     */
    where: ScamTypeWhereUniqueInput
    /**
     * In case the ScamType found by the `where` argument doesn't exist, create a new ScamType with this data.
     */
    create: XOR<ScamTypeCreateInput, ScamTypeUncheckedCreateInput>
    /**
     * In case the ScamType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScamTypeUpdateInput, ScamTypeUncheckedUpdateInput>
  }

  /**
   * ScamType delete
   */
  export type ScamTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScamType
     */
    select?: ScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScamType
     */
    omit?: ScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScamTypeInclude<ExtArgs> | null
    /**
     * Filter which ScamType to delete.
     */
    where: ScamTypeWhereUniqueInput
  }

  /**
   * ScamType deleteMany
   */
  export type ScamTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScamTypes to delete
     */
    where?: ScamTypeWhereInput
    /**
     * Limit how many ScamTypes to delete.
     */
    limit?: number
  }

  /**
   * ScamType.contactLinks
   */
  export type ScamType$contactLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactScamType
     */
    select?: ContactScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactScamType
     */
    omit?: ContactScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactScamTypeInclude<ExtArgs> | null
    where?: ContactScamTypeWhereInput
    orderBy?: ContactScamTypeOrderByWithRelationInput | ContactScamTypeOrderByWithRelationInput[]
    cursor?: ContactScamTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScamTypeScalarFieldEnum | ContactScamTypeScalarFieldEnum[]
  }

  /**
   * ScamType.postLinks
   */
  export type ScamType$postLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationPostScamType
     */
    select?: EducationPostScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationPostScamType
     */
    omit?: EducationPostScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationPostScamTypeInclude<ExtArgs> | null
    where?: EducationPostScamTypeWhereInput
    orderBy?: EducationPostScamTypeOrderByWithRelationInput | EducationPostScamTypeOrderByWithRelationInput[]
    cursor?: EducationPostScamTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EducationPostScamTypeScalarFieldEnum | EducationPostScamTypeScalarFieldEnum[]
  }

  /**
   * ScamType.reports
   */
  export type ScamType$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScamReport
     */
    select?: ScamReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScamReport
     */
    omit?: ScamReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScamReportInclude<ExtArgs> | null
    where?: ScamReportWhereInput
    orderBy?: ScamReportOrderByWithRelationInput | ScamReportOrderByWithRelationInput[]
    cursor?: ScamReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScamReportScalarFieldEnum | ScamReportScalarFieldEnum[]
  }

  /**
   * ScamType.severityRecords
   */
  export type ScamType$severityRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Severity
     */
    select?: SeveritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Severity
     */
    omit?: SeverityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeverityInclude<ExtArgs> | null
    where?: SeverityWhereInput
    orderBy?: SeverityOrderByWithRelationInput | SeverityOrderByWithRelationInput[]
    cursor?: SeverityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeverityScalarFieldEnum | SeverityScalarFieldEnum[]
  }

  /**
   * ScamType without action
   */
  export type ScamTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScamType
     */
    select?: ScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScamType
     */
    omit?: ScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScamTypeInclude<ExtArgs> | null
  }


  /**
   * Model Severity
   */

  export type AggregateSeverity = {
    _count: SeverityCountAggregateOutputType | null
    _avg: SeverityAvgAggregateOutputType | null
    _sum: SeveritySumAggregateOutputType | null
    _min: SeverityMinAggregateOutputType | null
    _max: SeverityMaxAggregateOutputType | null
  }

  export type SeverityAvgAggregateOutputType = {
    score: number | null
  }

  export type SeveritySumAggregateOutputType = {
    score: number | null
  }

  export type SeverityMinAggregateOutputType = {
    id: string | null
    scamTypeId: string | null
    country: string | null
    region: string | null
    city: string | null
    score: number | null
    level: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type SeverityMaxAggregateOutputType = {
    id: string | null
    scamTypeId: string | null
    country: string | null
    region: string | null
    city: string | null
    score: number | null
    level: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type SeverityCountAggregateOutputType = {
    id: number
    scamTypeId: number
    country: number
    region: number
    city: number
    score: number
    level: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type SeverityAvgAggregateInputType = {
    score?: true
  }

  export type SeveritySumAggregateInputType = {
    score?: true
  }

  export type SeverityMinAggregateInputType = {
    id?: true
    scamTypeId?: true
    country?: true
    region?: true
    city?: true
    score?: true
    level?: true
    updatedAt?: true
    createdAt?: true
  }

  export type SeverityMaxAggregateInputType = {
    id?: true
    scamTypeId?: true
    country?: true
    region?: true
    city?: true
    score?: true
    level?: true
    updatedAt?: true
    createdAt?: true
  }

  export type SeverityCountAggregateInputType = {
    id?: true
    scamTypeId?: true
    country?: true
    region?: true
    city?: true
    score?: true
    level?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type SeverityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Severity to aggregate.
     */
    where?: SeverityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Severities to fetch.
     */
    orderBy?: SeverityOrderByWithRelationInput | SeverityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeverityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Severities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Severities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Severities
    **/
    _count?: true | SeverityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeverityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeveritySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeverityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeverityMaxAggregateInputType
  }

  export type GetSeverityAggregateType<T extends SeverityAggregateArgs> = {
        [P in keyof T & keyof AggregateSeverity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeverity[P]>
      : GetScalarType<T[P], AggregateSeverity[P]>
  }




  export type SeverityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeverityWhereInput
    orderBy?: SeverityOrderByWithAggregationInput | SeverityOrderByWithAggregationInput[]
    by: SeverityScalarFieldEnum[] | SeverityScalarFieldEnum
    having?: SeverityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeverityCountAggregateInputType | true
    _avg?: SeverityAvgAggregateInputType
    _sum?: SeveritySumAggregateInputType
    _min?: SeverityMinAggregateInputType
    _max?: SeverityMaxAggregateInputType
  }

  export type SeverityGroupByOutputType = {
    id: string
    scamTypeId: string
    country: string | null
    region: string | null
    city: string | null
    score: number
    level: string
    updatedAt: Date
    createdAt: Date
    _count: SeverityCountAggregateOutputType | null
    _avg: SeverityAvgAggregateOutputType | null
    _sum: SeveritySumAggregateOutputType | null
    _min: SeverityMinAggregateOutputType | null
    _max: SeverityMaxAggregateOutputType | null
  }

  type GetSeverityGroupByPayload<T extends SeverityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeverityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeverityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeverityGroupByOutputType[P]>
            : GetScalarType<T[P], SeverityGroupByOutputType[P]>
        }
      >
    >


  export type SeveritySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scamTypeId?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    score?: boolean
    level?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    scamType?: boolean | ScamTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["severity"]>

  export type SeveritySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scamTypeId?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    score?: boolean
    level?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    scamType?: boolean | ScamTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["severity"]>

  export type SeveritySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scamTypeId?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    score?: boolean
    level?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    scamType?: boolean | ScamTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["severity"]>

  export type SeveritySelectScalar = {
    id?: boolean
    scamTypeId?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    score?: boolean
    level?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type SeverityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "scamTypeId" | "country" | "region" | "city" | "score" | "level" | "updatedAt" | "createdAt", ExtArgs["result"]["severity"]>
  export type SeverityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scamType?: boolean | ScamTypeDefaultArgs<ExtArgs>
  }
  export type SeverityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scamType?: boolean | ScamTypeDefaultArgs<ExtArgs>
  }
  export type SeverityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scamType?: boolean | ScamTypeDefaultArgs<ExtArgs>
  }

  export type $SeverityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Severity"
    objects: {
      scamType: Prisma.$ScamTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      scamTypeId: string
      country: string | null
      region: string | null
      city: string | null
      score: number
      level: string
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["severity"]>
    composites: {}
  }

  type SeverityGetPayload<S extends boolean | null | undefined | SeverityDefaultArgs> = $Result.GetResult<Prisma.$SeverityPayload, S>

  type SeverityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SeverityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeverityCountAggregateInputType | true
    }

  export interface SeverityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Severity'], meta: { name: 'Severity' } }
    /**
     * Find zero or one Severity that matches the filter.
     * @param {SeverityFindUniqueArgs} args - Arguments to find a Severity
     * @example
     * // Get one Severity
     * const severity = await prisma.severity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeverityFindUniqueArgs>(args: SelectSubset<T, SeverityFindUniqueArgs<ExtArgs>>): Prisma__SeverityClient<$Result.GetResult<Prisma.$SeverityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Severity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeverityFindUniqueOrThrowArgs} args - Arguments to find a Severity
     * @example
     * // Get one Severity
     * const severity = await prisma.severity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeverityFindUniqueOrThrowArgs>(args: SelectSubset<T, SeverityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeverityClient<$Result.GetResult<Prisma.$SeverityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Severity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeverityFindFirstArgs} args - Arguments to find a Severity
     * @example
     * // Get one Severity
     * const severity = await prisma.severity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeverityFindFirstArgs>(args?: SelectSubset<T, SeverityFindFirstArgs<ExtArgs>>): Prisma__SeverityClient<$Result.GetResult<Prisma.$SeverityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Severity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeverityFindFirstOrThrowArgs} args - Arguments to find a Severity
     * @example
     * // Get one Severity
     * const severity = await prisma.severity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeverityFindFirstOrThrowArgs>(args?: SelectSubset<T, SeverityFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeverityClient<$Result.GetResult<Prisma.$SeverityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Severities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeverityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Severities
     * const severities = await prisma.severity.findMany()
     * 
     * // Get first 10 Severities
     * const severities = await prisma.severity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const severityWithIdOnly = await prisma.severity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeverityFindManyArgs>(args?: SelectSubset<T, SeverityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeverityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Severity.
     * @param {SeverityCreateArgs} args - Arguments to create a Severity.
     * @example
     * // Create one Severity
     * const Severity = await prisma.severity.create({
     *   data: {
     *     // ... data to create a Severity
     *   }
     * })
     * 
     */
    create<T extends SeverityCreateArgs>(args: SelectSubset<T, SeverityCreateArgs<ExtArgs>>): Prisma__SeverityClient<$Result.GetResult<Prisma.$SeverityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Severities.
     * @param {SeverityCreateManyArgs} args - Arguments to create many Severities.
     * @example
     * // Create many Severities
     * const severity = await prisma.severity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeverityCreateManyArgs>(args?: SelectSubset<T, SeverityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Severities and returns the data saved in the database.
     * @param {SeverityCreateManyAndReturnArgs} args - Arguments to create many Severities.
     * @example
     * // Create many Severities
     * const severity = await prisma.severity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Severities and only return the `id`
     * const severityWithIdOnly = await prisma.severity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeverityCreateManyAndReturnArgs>(args?: SelectSubset<T, SeverityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeverityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Severity.
     * @param {SeverityDeleteArgs} args - Arguments to delete one Severity.
     * @example
     * // Delete one Severity
     * const Severity = await prisma.severity.delete({
     *   where: {
     *     // ... filter to delete one Severity
     *   }
     * })
     * 
     */
    delete<T extends SeverityDeleteArgs>(args: SelectSubset<T, SeverityDeleteArgs<ExtArgs>>): Prisma__SeverityClient<$Result.GetResult<Prisma.$SeverityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Severity.
     * @param {SeverityUpdateArgs} args - Arguments to update one Severity.
     * @example
     * // Update one Severity
     * const severity = await prisma.severity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeverityUpdateArgs>(args: SelectSubset<T, SeverityUpdateArgs<ExtArgs>>): Prisma__SeverityClient<$Result.GetResult<Prisma.$SeverityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Severities.
     * @param {SeverityDeleteManyArgs} args - Arguments to filter Severities to delete.
     * @example
     * // Delete a few Severities
     * const { count } = await prisma.severity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeverityDeleteManyArgs>(args?: SelectSubset<T, SeverityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Severities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeverityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Severities
     * const severity = await prisma.severity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeverityUpdateManyArgs>(args: SelectSubset<T, SeverityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Severities and returns the data updated in the database.
     * @param {SeverityUpdateManyAndReturnArgs} args - Arguments to update many Severities.
     * @example
     * // Update many Severities
     * const severity = await prisma.severity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Severities and only return the `id`
     * const severityWithIdOnly = await prisma.severity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SeverityUpdateManyAndReturnArgs>(args: SelectSubset<T, SeverityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeverityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Severity.
     * @param {SeverityUpsertArgs} args - Arguments to update or create a Severity.
     * @example
     * // Update or create a Severity
     * const severity = await prisma.severity.upsert({
     *   create: {
     *     // ... data to create a Severity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Severity we want to update
     *   }
     * })
     */
    upsert<T extends SeverityUpsertArgs>(args: SelectSubset<T, SeverityUpsertArgs<ExtArgs>>): Prisma__SeverityClient<$Result.GetResult<Prisma.$SeverityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Severities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeverityCountArgs} args - Arguments to filter Severities to count.
     * @example
     * // Count the number of Severities
     * const count = await prisma.severity.count({
     *   where: {
     *     // ... the filter for the Severities we want to count
     *   }
     * })
    **/
    count<T extends SeverityCountArgs>(
      args?: Subset<T, SeverityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeverityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Severity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeverityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeverityAggregateArgs>(args: Subset<T, SeverityAggregateArgs>): Prisma.PrismaPromise<GetSeverityAggregateType<T>>

    /**
     * Group by Severity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeverityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeverityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeverityGroupByArgs['orderBy'] }
        : { orderBy?: SeverityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeverityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeverityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Severity model
   */
  readonly fields: SeverityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Severity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeverityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    scamType<T extends ScamTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ScamTypeDefaultArgs<ExtArgs>>): Prisma__ScamTypeClient<$Result.GetResult<Prisma.$ScamTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Severity model
   */
  interface SeverityFieldRefs {
    readonly id: FieldRef<"Severity", 'String'>
    readonly scamTypeId: FieldRef<"Severity", 'String'>
    readonly country: FieldRef<"Severity", 'String'>
    readonly region: FieldRef<"Severity", 'String'>
    readonly city: FieldRef<"Severity", 'String'>
    readonly score: FieldRef<"Severity", 'Int'>
    readonly level: FieldRef<"Severity", 'String'>
    readonly updatedAt: FieldRef<"Severity", 'DateTime'>
    readonly createdAt: FieldRef<"Severity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Severity findUnique
   */
  export type SeverityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Severity
     */
    select?: SeveritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Severity
     */
    omit?: SeverityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeverityInclude<ExtArgs> | null
    /**
     * Filter, which Severity to fetch.
     */
    where: SeverityWhereUniqueInput
  }

  /**
   * Severity findUniqueOrThrow
   */
  export type SeverityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Severity
     */
    select?: SeveritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Severity
     */
    omit?: SeverityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeverityInclude<ExtArgs> | null
    /**
     * Filter, which Severity to fetch.
     */
    where: SeverityWhereUniqueInput
  }

  /**
   * Severity findFirst
   */
  export type SeverityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Severity
     */
    select?: SeveritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Severity
     */
    omit?: SeverityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeverityInclude<ExtArgs> | null
    /**
     * Filter, which Severity to fetch.
     */
    where?: SeverityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Severities to fetch.
     */
    orderBy?: SeverityOrderByWithRelationInput | SeverityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Severities.
     */
    cursor?: SeverityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Severities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Severities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Severities.
     */
    distinct?: SeverityScalarFieldEnum | SeverityScalarFieldEnum[]
  }

  /**
   * Severity findFirstOrThrow
   */
  export type SeverityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Severity
     */
    select?: SeveritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Severity
     */
    omit?: SeverityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeverityInclude<ExtArgs> | null
    /**
     * Filter, which Severity to fetch.
     */
    where?: SeverityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Severities to fetch.
     */
    orderBy?: SeverityOrderByWithRelationInput | SeverityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Severities.
     */
    cursor?: SeverityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Severities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Severities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Severities.
     */
    distinct?: SeverityScalarFieldEnum | SeverityScalarFieldEnum[]
  }

  /**
   * Severity findMany
   */
  export type SeverityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Severity
     */
    select?: SeveritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Severity
     */
    omit?: SeverityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeverityInclude<ExtArgs> | null
    /**
     * Filter, which Severities to fetch.
     */
    where?: SeverityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Severities to fetch.
     */
    orderBy?: SeverityOrderByWithRelationInput | SeverityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Severities.
     */
    cursor?: SeverityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Severities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Severities.
     */
    skip?: number
    distinct?: SeverityScalarFieldEnum | SeverityScalarFieldEnum[]
  }

  /**
   * Severity create
   */
  export type SeverityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Severity
     */
    select?: SeveritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Severity
     */
    omit?: SeverityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeverityInclude<ExtArgs> | null
    /**
     * The data needed to create a Severity.
     */
    data: XOR<SeverityCreateInput, SeverityUncheckedCreateInput>
  }

  /**
   * Severity createMany
   */
  export type SeverityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Severities.
     */
    data: SeverityCreateManyInput | SeverityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Severity createManyAndReturn
   */
  export type SeverityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Severity
     */
    select?: SeveritySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Severity
     */
    omit?: SeverityOmit<ExtArgs> | null
    /**
     * The data used to create many Severities.
     */
    data: SeverityCreateManyInput | SeverityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeverityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Severity update
   */
  export type SeverityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Severity
     */
    select?: SeveritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Severity
     */
    omit?: SeverityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeverityInclude<ExtArgs> | null
    /**
     * The data needed to update a Severity.
     */
    data: XOR<SeverityUpdateInput, SeverityUncheckedUpdateInput>
    /**
     * Choose, which Severity to update.
     */
    where: SeverityWhereUniqueInput
  }

  /**
   * Severity updateMany
   */
  export type SeverityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Severities.
     */
    data: XOR<SeverityUpdateManyMutationInput, SeverityUncheckedUpdateManyInput>
    /**
     * Filter which Severities to update
     */
    where?: SeverityWhereInput
    /**
     * Limit how many Severities to update.
     */
    limit?: number
  }

  /**
   * Severity updateManyAndReturn
   */
  export type SeverityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Severity
     */
    select?: SeveritySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Severity
     */
    omit?: SeverityOmit<ExtArgs> | null
    /**
     * The data used to update Severities.
     */
    data: XOR<SeverityUpdateManyMutationInput, SeverityUncheckedUpdateManyInput>
    /**
     * Filter which Severities to update
     */
    where?: SeverityWhereInput
    /**
     * Limit how many Severities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeverityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Severity upsert
   */
  export type SeverityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Severity
     */
    select?: SeveritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Severity
     */
    omit?: SeverityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeverityInclude<ExtArgs> | null
    /**
     * The filter to search for the Severity to update in case it exists.
     */
    where: SeverityWhereUniqueInput
    /**
     * In case the Severity found by the `where` argument doesn't exist, create a new Severity with this data.
     */
    create: XOR<SeverityCreateInput, SeverityUncheckedCreateInput>
    /**
     * In case the Severity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeverityUpdateInput, SeverityUncheckedUpdateInput>
  }

  /**
   * Severity delete
   */
  export type SeverityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Severity
     */
    select?: SeveritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Severity
     */
    omit?: SeverityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeverityInclude<ExtArgs> | null
    /**
     * Filter which Severity to delete.
     */
    where: SeverityWhereUniqueInput
  }

  /**
   * Severity deleteMany
   */
  export type SeverityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Severities to delete
     */
    where?: SeverityWhereInput
    /**
     * Limit how many Severities to delete.
     */
    limit?: number
  }

  /**
   * Severity without action
   */
  export type SeverityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Severity
     */
    select?: SeveritySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Severity
     */
    omit?: SeverityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeverityInclude<ExtArgs> | null
  }


  /**
   * Model Flag
   */

  export type AggregateFlag = {
    _count: FlagCountAggregateOutputType | null
    _min: FlagMinAggregateOutputType | null
    _max: FlagMaxAggregateOutputType | null
  }

  export type FlagMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    reportId: string | null
    userId: string | null
    reason: string | null
  }

  export type FlagMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    reportId: string | null
    userId: string | null
    reason: string | null
  }

  export type FlagCountAggregateOutputType = {
    id: number
    createdAt: number
    reportId: number
    userId: number
    reason: number
    _all: number
  }


  export type FlagMinAggregateInputType = {
    id?: true
    createdAt?: true
    reportId?: true
    userId?: true
    reason?: true
  }

  export type FlagMaxAggregateInputType = {
    id?: true
    createdAt?: true
    reportId?: true
    userId?: true
    reason?: true
  }

  export type FlagCountAggregateInputType = {
    id?: true
    createdAt?: true
    reportId?: true
    userId?: true
    reason?: true
    _all?: true
  }

  export type FlagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Flag to aggregate.
     */
    where?: FlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flags to fetch.
     */
    orderBy?: FlagOrderByWithRelationInput | FlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Flags
    **/
    _count?: true | FlagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlagMaxAggregateInputType
  }

  export type GetFlagAggregateType<T extends FlagAggregateArgs> = {
        [P in keyof T & keyof AggregateFlag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlag[P]>
      : GetScalarType<T[P], AggregateFlag[P]>
  }




  export type FlagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlagWhereInput
    orderBy?: FlagOrderByWithAggregationInput | FlagOrderByWithAggregationInput[]
    by: FlagScalarFieldEnum[] | FlagScalarFieldEnum
    having?: FlagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlagCountAggregateInputType | true
    _min?: FlagMinAggregateInputType
    _max?: FlagMaxAggregateInputType
  }

  export type FlagGroupByOutputType = {
    id: string
    createdAt: Date
    reportId: string
    userId: string
    reason: string | null
    _count: FlagCountAggregateOutputType | null
    _min: FlagMinAggregateOutputType | null
    _max: FlagMaxAggregateOutputType | null
  }

  type GetFlagGroupByPayload<T extends FlagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlagGroupByOutputType[P]>
            : GetScalarType<T[P], FlagGroupByOutputType[P]>
        }
      >
    >


  export type FlagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    reportId?: boolean
    userId?: boolean
    reason?: boolean
    report?: boolean | ScamReportDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flag"]>

  export type FlagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    reportId?: boolean
    userId?: boolean
    reason?: boolean
    report?: boolean | ScamReportDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flag"]>

  export type FlagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    reportId?: boolean
    userId?: boolean
    reason?: boolean
    report?: boolean | ScamReportDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flag"]>

  export type FlagSelectScalar = {
    id?: boolean
    createdAt?: boolean
    reportId?: boolean
    userId?: boolean
    reason?: boolean
  }

  export type FlagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "reportId" | "userId" | "reason", ExtArgs["result"]["flag"]>
  export type FlagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    report?: boolean | ScamReportDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FlagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    report?: boolean | ScamReportDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FlagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    report?: boolean | ScamReportDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FlagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Flag"
    objects: {
      report: Prisma.$ScamReportPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      reportId: string
      userId: string
      reason: string | null
    }, ExtArgs["result"]["flag"]>
    composites: {}
  }

  type FlagGetPayload<S extends boolean | null | undefined | FlagDefaultArgs> = $Result.GetResult<Prisma.$FlagPayload, S>

  type FlagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FlagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FlagCountAggregateInputType | true
    }

  export interface FlagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Flag'], meta: { name: 'Flag' } }
    /**
     * Find zero or one Flag that matches the filter.
     * @param {FlagFindUniqueArgs} args - Arguments to find a Flag
     * @example
     * // Get one Flag
     * const flag = await prisma.flag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlagFindUniqueArgs>(args: SelectSubset<T, FlagFindUniqueArgs<ExtArgs>>): Prisma__FlagClient<$Result.GetResult<Prisma.$FlagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Flag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FlagFindUniqueOrThrowArgs} args - Arguments to find a Flag
     * @example
     * // Get one Flag
     * const flag = await prisma.flag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlagFindUniqueOrThrowArgs>(args: SelectSubset<T, FlagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlagClient<$Result.GetResult<Prisma.$FlagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Flag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlagFindFirstArgs} args - Arguments to find a Flag
     * @example
     * // Get one Flag
     * const flag = await prisma.flag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlagFindFirstArgs>(args?: SelectSubset<T, FlagFindFirstArgs<ExtArgs>>): Prisma__FlagClient<$Result.GetResult<Prisma.$FlagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Flag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlagFindFirstOrThrowArgs} args - Arguments to find a Flag
     * @example
     * // Get one Flag
     * const flag = await prisma.flag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlagFindFirstOrThrowArgs>(args?: SelectSubset<T, FlagFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlagClient<$Result.GetResult<Prisma.$FlagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Flags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Flags
     * const flags = await prisma.flag.findMany()
     * 
     * // Get first 10 Flags
     * const flags = await prisma.flag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flagWithIdOnly = await prisma.flag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FlagFindManyArgs>(args?: SelectSubset<T, FlagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Flag.
     * @param {FlagCreateArgs} args - Arguments to create a Flag.
     * @example
     * // Create one Flag
     * const Flag = await prisma.flag.create({
     *   data: {
     *     // ... data to create a Flag
     *   }
     * })
     * 
     */
    create<T extends FlagCreateArgs>(args: SelectSubset<T, FlagCreateArgs<ExtArgs>>): Prisma__FlagClient<$Result.GetResult<Prisma.$FlagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Flags.
     * @param {FlagCreateManyArgs} args - Arguments to create many Flags.
     * @example
     * // Create many Flags
     * const flag = await prisma.flag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlagCreateManyArgs>(args?: SelectSubset<T, FlagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Flags and returns the data saved in the database.
     * @param {FlagCreateManyAndReturnArgs} args - Arguments to create many Flags.
     * @example
     * // Create many Flags
     * const flag = await prisma.flag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Flags and only return the `id`
     * const flagWithIdOnly = await prisma.flag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FlagCreateManyAndReturnArgs>(args?: SelectSubset<T, FlagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Flag.
     * @param {FlagDeleteArgs} args - Arguments to delete one Flag.
     * @example
     * // Delete one Flag
     * const Flag = await prisma.flag.delete({
     *   where: {
     *     // ... filter to delete one Flag
     *   }
     * })
     * 
     */
    delete<T extends FlagDeleteArgs>(args: SelectSubset<T, FlagDeleteArgs<ExtArgs>>): Prisma__FlagClient<$Result.GetResult<Prisma.$FlagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Flag.
     * @param {FlagUpdateArgs} args - Arguments to update one Flag.
     * @example
     * // Update one Flag
     * const flag = await prisma.flag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlagUpdateArgs>(args: SelectSubset<T, FlagUpdateArgs<ExtArgs>>): Prisma__FlagClient<$Result.GetResult<Prisma.$FlagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Flags.
     * @param {FlagDeleteManyArgs} args - Arguments to filter Flags to delete.
     * @example
     * // Delete a few Flags
     * const { count } = await prisma.flag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlagDeleteManyArgs>(args?: SelectSubset<T, FlagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Flags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Flags
     * const flag = await prisma.flag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlagUpdateManyArgs>(args: SelectSubset<T, FlagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Flags and returns the data updated in the database.
     * @param {FlagUpdateManyAndReturnArgs} args - Arguments to update many Flags.
     * @example
     * // Update many Flags
     * const flag = await prisma.flag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Flags and only return the `id`
     * const flagWithIdOnly = await prisma.flag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FlagUpdateManyAndReturnArgs>(args: SelectSubset<T, FlagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Flag.
     * @param {FlagUpsertArgs} args - Arguments to update or create a Flag.
     * @example
     * // Update or create a Flag
     * const flag = await prisma.flag.upsert({
     *   create: {
     *     // ... data to create a Flag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Flag we want to update
     *   }
     * })
     */
    upsert<T extends FlagUpsertArgs>(args: SelectSubset<T, FlagUpsertArgs<ExtArgs>>): Prisma__FlagClient<$Result.GetResult<Prisma.$FlagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Flags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlagCountArgs} args - Arguments to filter Flags to count.
     * @example
     * // Count the number of Flags
     * const count = await prisma.flag.count({
     *   where: {
     *     // ... the filter for the Flags we want to count
     *   }
     * })
    **/
    count<T extends FlagCountArgs>(
      args?: Subset<T, FlagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Flag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlagAggregateArgs>(args: Subset<T, FlagAggregateArgs>): Prisma.PrismaPromise<GetFlagAggregateType<T>>

    /**
     * Group by Flag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlagGroupByArgs['orderBy'] }
        : { orderBy?: FlagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Flag model
   */
  readonly fields: FlagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Flag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    report<T extends ScamReportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ScamReportDefaultArgs<ExtArgs>>): Prisma__ScamReportClient<$Result.GetResult<Prisma.$ScamReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Flag model
   */
  interface FlagFieldRefs {
    readonly id: FieldRef<"Flag", 'String'>
    readonly createdAt: FieldRef<"Flag", 'DateTime'>
    readonly reportId: FieldRef<"Flag", 'String'>
    readonly userId: FieldRef<"Flag", 'String'>
    readonly reason: FieldRef<"Flag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Flag findUnique
   */
  export type FlagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flag
     */
    select?: FlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flag
     */
    omit?: FlagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagInclude<ExtArgs> | null
    /**
     * Filter, which Flag to fetch.
     */
    where: FlagWhereUniqueInput
  }

  /**
   * Flag findUniqueOrThrow
   */
  export type FlagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flag
     */
    select?: FlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flag
     */
    omit?: FlagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagInclude<ExtArgs> | null
    /**
     * Filter, which Flag to fetch.
     */
    where: FlagWhereUniqueInput
  }

  /**
   * Flag findFirst
   */
  export type FlagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flag
     */
    select?: FlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flag
     */
    omit?: FlagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagInclude<ExtArgs> | null
    /**
     * Filter, which Flag to fetch.
     */
    where?: FlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flags to fetch.
     */
    orderBy?: FlagOrderByWithRelationInput | FlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Flags.
     */
    cursor?: FlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Flags.
     */
    distinct?: FlagScalarFieldEnum | FlagScalarFieldEnum[]
  }

  /**
   * Flag findFirstOrThrow
   */
  export type FlagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flag
     */
    select?: FlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flag
     */
    omit?: FlagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagInclude<ExtArgs> | null
    /**
     * Filter, which Flag to fetch.
     */
    where?: FlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flags to fetch.
     */
    orderBy?: FlagOrderByWithRelationInput | FlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Flags.
     */
    cursor?: FlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Flags.
     */
    distinct?: FlagScalarFieldEnum | FlagScalarFieldEnum[]
  }

  /**
   * Flag findMany
   */
  export type FlagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flag
     */
    select?: FlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flag
     */
    omit?: FlagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagInclude<ExtArgs> | null
    /**
     * Filter, which Flags to fetch.
     */
    where?: FlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flags to fetch.
     */
    orderBy?: FlagOrderByWithRelationInput | FlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Flags.
     */
    cursor?: FlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flags.
     */
    skip?: number
    distinct?: FlagScalarFieldEnum | FlagScalarFieldEnum[]
  }

  /**
   * Flag create
   */
  export type FlagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flag
     */
    select?: FlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flag
     */
    omit?: FlagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagInclude<ExtArgs> | null
    /**
     * The data needed to create a Flag.
     */
    data: XOR<FlagCreateInput, FlagUncheckedCreateInput>
  }

  /**
   * Flag createMany
   */
  export type FlagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Flags.
     */
    data: FlagCreateManyInput | FlagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Flag createManyAndReturn
   */
  export type FlagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flag
     */
    select?: FlagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Flag
     */
    omit?: FlagOmit<ExtArgs> | null
    /**
     * The data used to create many Flags.
     */
    data: FlagCreateManyInput | FlagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Flag update
   */
  export type FlagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flag
     */
    select?: FlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flag
     */
    omit?: FlagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagInclude<ExtArgs> | null
    /**
     * The data needed to update a Flag.
     */
    data: XOR<FlagUpdateInput, FlagUncheckedUpdateInput>
    /**
     * Choose, which Flag to update.
     */
    where: FlagWhereUniqueInput
  }

  /**
   * Flag updateMany
   */
  export type FlagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Flags.
     */
    data: XOR<FlagUpdateManyMutationInput, FlagUncheckedUpdateManyInput>
    /**
     * Filter which Flags to update
     */
    where?: FlagWhereInput
    /**
     * Limit how many Flags to update.
     */
    limit?: number
  }

  /**
   * Flag updateManyAndReturn
   */
  export type FlagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flag
     */
    select?: FlagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Flag
     */
    omit?: FlagOmit<ExtArgs> | null
    /**
     * The data used to update Flags.
     */
    data: XOR<FlagUpdateManyMutationInput, FlagUncheckedUpdateManyInput>
    /**
     * Filter which Flags to update
     */
    where?: FlagWhereInput
    /**
     * Limit how many Flags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Flag upsert
   */
  export type FlagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flag
     */
    select?: FlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flag
     */
    omit?: FlagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagInclude<ExtArgs> | null
    /**
     * The filter to search for the Flag to update in case it exists.
     */
    where: FlagWhereUniqueInput
    /**
     * In case the Flag found by the `where` argument doesn't exist, create a new Flag with this data.
     */
    create: XOR<FlagCreateInput, FlagUncheckedCreateInput>
    /**
     * In case the Flag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlagUpdateInput, FlagUncheckedUpdateInput>
  }

  /**
   * Flag delete
   */
  export type FlagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flag
     */
    select?: FlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flag
     */
    omit?: FlagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagInclude<ExtArgs> | null
    /**
     * Filter which Flag to delete.
     */
    where: FlagWhereUniqueInput
  }

  /**
   * Flag deleteMany
   */
  export type FlagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Flags to delete
     */
    where?: FlagWhereInput
    /**
     * Limit how many Flags to delete.
     */
    limit?: number
  }

  /**
   * Flag without action
   */
  export type FlagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flag
     */
    select?: FlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flag
     */
    omit?: FlagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    name: string | null
    image: string | null
    notificationSettings: string | null
    createdAt: Date | null
    updatedAt: Date | null
    role: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    name: string | null
    image: string | null
    notificationSettings: string | null
    createdAt: Date | null
    updatedAt: Date | null
    role: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    username: number
    name: number
    image: number
    notificationSettings: number
    createdAt: number
    updatedAt: number
    role: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    name?: true
    image?: true
    notificationSettings?: true
    createdAt?: true
    updatedAt?: true
    role?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    name?: true
    image?: true
    notificationSettings?: true
    createdAt?: true
    updatedAt?: true
    role?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    name?: true
    image?: true
    notificationSettings?: true
    createdAt?: true
    updatedAt?: true
    role?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    username: string
    name: string | null
    image: string | null
    notificationSettings: string
    createdAt: Date
    updatedAt: Date
    role: string
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    name?: boolean
    image?: boolean
    notificationSettings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean
    comments?: boolean | User$commentsArgs<ExtArgs>
    flags?: boolean | User$flagsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    votes?: boolean | User$votesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    name?: boolean
    image?: boolean
    notificationSettings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    name?: boolean
    image?: boolean
    notificationSettings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    name?: boolean
    image?: boolean
    notificationSettings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "username" | "name" | "image" | "notificationSettings" | "createdAt" | "updatedAt" | "role", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | User$commentsArgs<ExtArgs>
    flags?: boolean | User$flagsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    votes?: boolean | User$votesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      comments: Prisma.$CommentPayload<ExtArgs>[]
      flags: Prisma.$FlagPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      votes: Prisma.$VotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      username: string
      name: string | null
      image: string | null
      notificationSettings: string
      createdAt: Date
      updatedAt: Date
      role: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    flags<T extends User$flagsArgs<ExtArgs> = {}>(args?: Subset<T, User$flagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    votes<T extends User$votesArgs<ExtArgs> = {}>(args?: Subset<T, User$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly notificationSettings: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly role: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.flags
   */
  export type User$flagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flag
     */
    select?: FlagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flag
     */
    omit?: FlagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagInclude<ExtArgs> | null
    where?: FlagWhereInput
    orderBy?: FlagOrderByWithRelationInput | FlagOrderByWithRelationInput[]
    cursor?: FlagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlagScalarFieldEnum | FlagScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.votes
   */
  export type User$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vote
     */
    select?: VoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vote
     */
    omit?: VoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VoteInclude<ExtArgs> | null
    where?: VoteWhereInput
    orderBy?: VoteOrderByWithRelationInput | VoteOrderByWithRelationInput[]
    cursor?: VoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VoteScalarFieldEnum | VoteScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    data: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    data: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    data: number
    read: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    data?: true
    read?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    data?: true
    read?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    data?: true
    read?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: string
    data: string | null
    read: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    data?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    data?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    data?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    data?: boolean
    read?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "data" | "read" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      data: string | null
      read: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly data: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model OutcomeType
   */

  export type AggregateOutcomeType = {
    _count: OutcomeTypeCountAggregateOutputType | null
    _min: OutcomeTypeMinAggregateOutputType | null
    _max: OutcomeTypeMaxAggregateOutputType | null
  }

  export type OutcomeTypeMinAggregateOutputType = {
    id: string | null
    value: string | null
    label: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OutcomeTypeMaxAggregateOutputType = {
    id: string | null
    value: string | null
    label: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OutcomeTypeCountAggregateOutputType = {
    id: number
    value: number
    label: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OutcomeTypeMinAggregateInputType = {
    id?: true
    value?: true
    label?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OutcomeTypeMaxAggregateInputType = {
    id?: true
    value?: true
    label?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OutcomeTypeCountAggregateInputType = {
    id?: true
    value?: true
    label?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OutcomeTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutcomeType to aggregate.
     */
    where?: OutcomeTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutcomeTypes to fetch.
     */
    orderBy?: OutcomeTypeOrderByWithRelationInput | OutcomeTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OutcomeTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutcomeTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutcomeTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OutcomeTypes
    **/
    _count?: true | OutcomeTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OutcomeTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OutcomeTypeMaxAggregateInputType
  }

  export type GetOutcomeTypeAggregateType<T extends OutcomeTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateOutcomeType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOutcomeType[P]>
      : GetScalarType<T[P], AggregateOutcomeType[P]>
  }




  export type OutcomeTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutcomeTypeWhereInput
    orderBy?: OutcomeTypeOrderByWithAggregationInput | OutcomeTypeOrderByWithAggregationInput[]
    by: OutcomeTypeScalarFieldEnum[] | OutcomeTypeScalarFieldEnum
    having?: OutcomeTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OutcomeTypeCountAggregateInputType | true
    _min?: OutcomeTypeMinAggregateInputType
    _max?: OutcomeTypeMaxAggregateInputType
  }

  export type OutcomeTypeGroupByOutputType = {
    id: string
    value: string
    label: string
    createdAt: Date
    updatedAt: Date
    _count: OutcomeTypeCountAggregateOutputType | null
    _min: OutcomeTypeMinAggregateOutputType | null
    _max: OutcomeTypeMaxAggregateOutputType | null
  }

  type GetOutcomeTypeGroupByPayload<T extends OutcomeTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OutcomeTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OutcomeTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OutcomeTypeGroupByOutputType[P]>
            : GetScalarType<T[P], OutcomeTypeGroupByOutputType[P]>
        }
      >
    >


  export type OutcomeTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    label?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["outcomeType"]>

  export type OutcomeTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    label?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["outcomeType"]>

  export type OutcomeTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    label?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["outcomeType"]>

  export type OutcomeTypeSelectScalar = {
    id?: boolean
    value?: boolean
    label?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OutcomeTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "label" | "createdAt" | "updatedAt", ExtArgs["result"]["outcomeType"]>

  export type $OutcomeTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OutcomeType"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      value: string
      label: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["outcomeType"]>
    composites: {}
  }

  type OutcomeTypeGetPayload<S extends boolean | null | undefined | OutcomeTypeDefaultArgs> = $Result.GetResult<Prisma.$OutcomeTypePayload, S>

  type OutcomeTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OutcomeTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OutcomeTypeCountAggregateInputType | true
    }

  export interface OutcomeTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OutcomeType'], meta: { name: 'OutcomeType' } }
    /**
     * Find zero or one OutcomeType that matches the filter.
     * @param {OutcomeTypeFindUniqueArgs} args - Arguments to find a OutcomeType
     * @example
     * // Get one OutcomeType
     * const outcomeType = await prisma.outcomeType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OutcomeTypeFindUniqueArgs>(args: SelectSubset<T, OutcomeTypeFindUniqueArgs<ExtArgs>>): Prisma__OutcomeTypeClient<$Result.GetResult<Prisma.$OutcomeTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OutcomeType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OutcomeTypeFindUniqueOrThrowArgs} args - Arguments to find a OutcomeType
     * @example
     * // Get one OutcomeType
     * const outcomeType = await prisma.outcomeType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OutcomeTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, OutcomeTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OutcomeTypeClient<$Result.GetResult<Prisma.$OutcomeTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OutcomeType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutcomeTypeFindFirstArgs} args - Arguments to find a OutcomeType
     * @example
     * // Get one OutcomeType
     * const outcomeType = await prisma.outcomeType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OutcomeTypeFindFirstArgs>(args?: SelectSubset<T, OutcomeTypeFindFirstArgs<ExtArgs>>): Prisma__OutcomeTypeClient<$Result.GetResult<Prisma.$OutcomeTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OutcomeType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutcomeTypeFindFirstOrThrowArgs} args - Arguments to find a OutcomeType
     * @example
     * // Get one OutcomeType
     * const outcomeType = await prisma.outcomeType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OutcomeTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, OutcomeTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__OutcomeTypeClient<$Result.GetResult<Prisma.$OutcomeTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OutcomeTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutcomeTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OutcomeTypes
     * const outcomeTypes = await prisma.outcomeType.findMany()
     * 
     * // Get first 10 OutcomeTypes
     * const outcomeTypes = await prisma.outcomeType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const outcomeTypeWithIdOnly = await prisma.outcomeType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OutcomeTypeFindManyArgs>(args?: SelectSubset<T, OutcomeTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutcomeTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OutcomeType.
     * @param {OutcomeTypeCreateArgs} args - Arguments to create a OutcomeType.
     * @example
     * // Create one OutcomeType
     * const OutcomeType = await prisma.outcomeType.create({
     *   data: {
     *     // ... data to create a OutcomeType
     *   }
     * })
     * 
     */
    create<T extends OutcomeTypeCreateArgs>(args: SelectSubset<T, OutcomeTypeCreateArgs<ExtArgs>>): Prisma__OutcomeTypeClient<$Result.GetResult<Prisma.$OutcomeTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OutcomeTypes.
     * @param {OutcomeTypeCreateManyArgs} args - Arguments to create many OutcomeTypes.
     * @example
     * // Create many OutcomeTypes
     * const outcomeType = await prisma.outcomeType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OutcomeTypeCreateManyArgs>(args?: SelectSubset<T, OutcomeTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OutcomeTypes and returns the data saved in the database.
     * @param {OutcomeTypeCreateManyAndReturnArgs} args - Arguments to create many OutcomeTypes.
     * @example
     * // Create many OutcomeTypes
     * const outcomeType = await prisma.outcomeType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OutcomeTypes and only return the `id`
     * const outcomeTypeWithIdOnly = await prisma.outcomeType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OutcomeTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, OutcomeTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutcomeTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OutcomeType.
     * @param {OutcomeTypeDeleteArgs} args - Arguments to delete one OutcomeType.
     * @example
     * // Delete one OutcomeType
     * const OutcomeType = await prisma.outcomeType.delete({
     *   where: {
     *     // ... filter to delete one OutcomeType
     *   }
     * })
     * 
     */
    delete<T extends OutcomeTypeDeleteArgs>(args: SelectSubset<T, OutcomeTypeDeleteArgs<ExtArgs>>): Prisma__OutcomeTypeClient<$Result.GetResult<Prisma.$OutcomeTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OutcomeType.
     * @param {OutcomeTypeUpdateArgs} args - Arguments to update one OutcomeType.
     * @example
     * // Update one OutcomeType
     * const outcomeType = await prisma.outcomeType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OutcomeTypeUpdateArgs>(args: SelectSubset<T, OutcomeTypeUpdateArgs<ExtArgs>>): Prisma__OutcomeTypeClient<$Result.GetResult<Prisma.$OutcomeTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OutcomeTypes.
     * @param {OutcomeTypeDeleteManyArgs} args - Arguments to filter OutcomeTypes to delete.
     * @example
     * // Delete a few OutcomeTypes
     * const { count } = await prisma.outcomeType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OutcomeTypeDeleteManyArgs>(args?: SelectSubset<T, OutcomeTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OutcomeTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutcomeTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OutcomeTypes
     * const outcomeType = await prisma.outcomeType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OutcomeTypeUpdateManyArgs>(args: SelectSubset<T, OutcomeTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OutcomeTypes and returns the data updated in the database.
     * @param {OutcomeTypeUpdateManyAndReturnArgs} args - Arguments to update many OutcomeTypes.
     * @example
     * // Update many OutcomeTypes
     * const outcomeType = await prisma.outcomeType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OutcomeTypes and only return the `id`
     * const outcomeTypeWithIdOnly = await prisma.outcomeType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OutcomeTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, OutcomeTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutcomeTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OutcomeType.
     * @param {OutcomeTypeUpsertArgs} args - Arguments to update or create a OutcomeType.
     * @example
     * // Update or create a OutcomeType
     * const outcomeType = await prisma.outcomeType.upsert({
     *   create: {
     *     // ... data to create a OutcomeType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OutcomeType we want to update
     *   }
     * })
     */
    upsert<T extends OutcomeTypeUpsertArgs>(args: SelectSubset<T, OutcomeTypeUpsertArgs<ExtArgs>>): Prisma__OutcomeTypeClient<$Result.GetResult<Prisma.$OutcomeTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OutcomeTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutcomeTypeCountArgs} args - Arguments to filter OutcomeTypes to count.
     * @example
     * // Count the number of OutcomeTypes
     * const count = await prisma.outcomeType.count({
     *   where: {
     *     // ... the filter for the OutcomeTypes we want to count
     *   }
     * })
    **/
    count<T extends OutcomeTypeCountArgs>(
      args?: Subset<T, OutcomeTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OutcomeTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OutcomeType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutcomeTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OutcomeTypeAggregateArgs>(args: Subset<T, OutcomeTypeAggregateArgs>): Prisma.PrismaPromise<GetOutcomeTypeAggregateType<T>>

    /**
     * Group by OutcomeType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutcomeTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OutcomeTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OutcomeTypeGroupByArgs['orderBy'] }
        : { orderBy?: OutcomeTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OutcomeTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOutcomeTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OutcomeType model
   */
  readonly fields: OutcomeTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OutcomeType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OutcomeTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OutcomeType model
   */
  interface OutcomeTypeFieldRefs {
    readonly id: FieldRef<"OutcomeType", 'String'>
    readonly value: FieldRef<"OutcomeType", 'String'>
    readonly label: FieldRef<"OutcomeType", 'String'>
    readonly createdAt: FieldRef<"OutcomeType", 'DateTime'>
    readonly updatedAt: FieldRef<"OutcomeType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OutcomeType findUnique
   */
  export type OutcomeTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutcomeType
     */
    select?: OutcomeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutcomeType
     */
    omit?: OutcomeTypeOmit<ExtArgs> | null
    /**
     * Filter, which OutcomeType to fetch.
     */
    where: OutcomeTypeWhereUniqueInput
  }

  /**
   * OutcomeType findUniqueOrThrow
   */
  export type OutcomeTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutcomeType
     */
    select?: OutcomeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutcomeType
     */
    omit?: OutcomeTypeOmit<ExtArgs> | null
    /**
     * Filter, which OutcomeType to fetch.
     */
    where: OutcomeTypeWhereUniqueInput
  }

  /**
   * OutcomeType findFirst
   */
  export type OutcomeTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutcomeType
     */
    select?: OutcomeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutcomeType
     */
    omit?: OutcomeTypeOmit<ExtArgs> | null
    /**
     * Filter, which OutcomeType to fetch.
     */
    where?: OutcomeTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutcomeTypes to fetch.
     */
    orderBy?: OutcomeTypeOrderByWithRelationInput | OutcomeTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutcomeTypes.
     */
    cursor?: OutcomeTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutcomeTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutcomeTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutcomeTypes.
     */
    distinct?: OutcomeTypeScalarFieldEnum | OutcomeTypeScalarFieldEnum[]
  }

  /**
   * OutcomeType findFirstOrThrow
   */
  export type OutcomeTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutcomeType
     */
    select?: OutcomeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutcomeType
     */
    omit?: OutcomeTypeOmit<ExtArgs> | null
    /**
     * Filter, which OutcomeType to fetch.
     */
    where?: OutcomeTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutcomeTypes to fetch.
     */
    orderBy?: OutcomeTypeOrderByWithRelationInput | OutcomeTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutcomeTypes.
     */
    cursor?: OutcomeTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutcomeTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutcomeTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutcomeTypes.
     */
    distinct?: OutcomeTypeScalarFieldEnum | OutcomeTypeScalarFieldEnum[]
  }

  /**
   * OutcomeType findMany
   */
  export type OutcomeTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutcomeType
     */
    select?: OutcomeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutcomeType
     */
    omit?: OutcomeTypeOmit<ExtArgs> | null
    /**
     * Filter, which OutcomeTypes to fetch.
     */
    where?: OutcomeTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutcomeTypes to fetch.
     */
    orderBy?: OutcomeTypeOrderByWithRelationInput | OutcomeTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OutcomeTypes.
     */
    cursor?: OutcomeTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutcomeTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutcomeTypes.
     */
    skip?: number
    distinct?: OutcomeTypeScalarFieldEnum | OutcomeTypeScalarFieldEnum[]
  }

  /**
   * OutcomeType create
   */
  export type OutcomeTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutcomeType
     */
    select?: OutcomeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutcomeType
     */
    omit?: OutcomeTypeOmit<ExtArgs> | null
    /**
     * The data needed to create a OutcomeType.
     */
    data: XOR<OutcomeTypeCreateInput, OutcomeTypeUncheckedCreateInput>
  }

  /**
   * OutcomeType createMany
   */
  export type OutcomeTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OutcomeTypes.
     */
    data: OutcomeTypeCreateManyInput | OutcomeTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OutcomeType createManyAndReturn
   */
  export type OutcomeTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutcomeType
     */
    select?: OutcomeTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OutcomeType
     */
    omit?: OutcomeTypeOmit<ExtArgs> | null
    /**
     * The data used to create many OutcomeTypes.
     */
    data: OutcomeTypeCreateManyInput | OutcomeTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OutcomeType update
   */
  export type OutcomeTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutcomeType
     */
    select?: OutcomeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutcomeType
     */
    omit?: OutcomeTypeOmit<ExtArgs> | null
    /**
     * The data needed to update a OutcomeType.
     */
    data: XOR<OutcomeTypeUpdateInput, OutcomeTypeUncheckedUpdateInput>
    /**
     * Choose, which OutcomeType to update.
     */
    where: OutcomeTypeWhereUniqueInput
  }

  /**
   * OutcomeType updateMany
   */
  export type OutcomeTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OutcomeTypes.
     */
    data: XOR<OutcomeTypeUpdateManyMutationInput, OutcomeTypeUncheckedUpdateManyInput>
    /**
     * Filter which OutcomeTypes to update
     */
    where?: OutcomeTypeWhereInput
    /**
     * Limit how many OutcomeTypes to update.
     */
    limit?: number
  }

  /**
   * OutcomeType updateManyAndReturn
   */
  export type OutcomeTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutcomeType
     */
    select?: OutcomeTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OutcomeType
     */
    omit?: OutcomeTypeOmit<ExtArgs> | null
    /**
     * The data used to update OutcomeTypes.
     */
    data: XOR<OutcomeTypeUpdateManyMutationInput, OutcomeTypeUncheckedUpdateManyInput>
    /**
     * Filter which OutcomeTypes to update
     */
    where?: OutcomeTypeWhereInput
    /**
     * Limit how many OutcomeTypes to update.
     */
    limit?: number
  }

  /**
   * OutcomeType upsert
   */
  export type OutcomeTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutcomeType
     */
    select?: OutcomeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutcomeType
     */
    omit?: OutcomeTypeOmit<ExtArgs> | null
    /**
     * The filter to search for the OutcomeType to update in case it exists.
     */
    where: OutcomeTypeWhereUniqueInput
    /**
     * In case the OutcomeType found by the `where` argument doesn't exist, create a new OutcomeType with this data.
     */
    create: XOR<OutcomeTypeCreateInput, OutcomeTypeUncheckedCreateInput>
    /**
     * In case the OutcomeType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OutcomeTypeUpdateInput, OutcomeTypeUncheckedUpdateInput>
  }

  /**
   * OutcomeType delete
   */
  export type OutcomeTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutcomeType
     */
    select?: OutcomeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutcomeType
     */
    omit?: OutcomeTypeOmit<ExtArgs> | null
    /**
     * Filter which OutcomeType to delete.
     */
    where: OutcomeTypeWhereUniqueInput
  }

  /**
   * OutcomeType deleteMany
   */
  export type OutcomeTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutcomeTypes to delete
     */
    where?: OutcomeTypeWhereInput
    /**
     * Limit how many OutcomeTypes to delete.
     */
    limit?: number
  }

  /**
   * OutcomeType without action
   */
  export type OutcomeTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutcomeType
     */
    select?: OutcomeTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OutcomeType
     */
    omit?: OutcomeTypeOmit<ExtArgs> | null
  }


  /**
   * Model EducationPost
   */

  export type AggregateEducationPost = {
    _count: EducationPostCountAggregateOutputType | null
    _min: EducationPostMinAggregateOutputType | null
    _max: EducationPostMaxAggregateOutputType | null
  }

  export type EducationPostMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    slug: string | null
    title: string | null
    excerpt: string | null
    bodyMd: string | null
    status: $Enums.PostStatus | null
    publishedAt: Date | null
    category: $Enums.PostCategory | null
    heroImageUrl: string | null
    heroSvg: string | null
    heroAlt: string | null
    country: string | null
    region: string | null
    city: string | null
    canonicalUrl: string | null
    metaTitle: string | null
    metaDescription: string | null
    featured: boolean | null
    authorName: string | null
    sourceUrl: string | null
  }

  export type EducationPostMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    slug: string | null
    title: string | null
    excerpt: string | null
    bodyMd: string | null
    status: $Enums.PostStatus | null
    publishedAt: Date | null
    category: $Enums.PostCategory | null
    heroImageUrl: string | null
    heroSvg: string | null
    heroAlt: string | null
    country: string | null
    region: string | null
    city: string | null
    canonicalUrl: string | null
    metaTitle: string | null
    metaDescription: string | null
    featured: boolean | null
    authorName: string | null
    sourceUrl: string | null
  }

  export type EducationPostCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    slug: number
    title: number
    excerpt: number
    bodyMd: number
    status: number
    publishedAt: number
    category: number
    heroImageUrl: number
    heroSvg: number
    heroAlt: number
    country: number
    region: number
    city: number
    canonicalUrl: number
    metaTitle: number
    metaDescription: number
    featured: number
    authorName: number
    sourceUrl: number
    _all: number
  }


  export type EducationPostMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    slug?: true
    title?: true
    excerpt?: true
    bodyMd?: true
    status?: true
    publishedAt?: true
    category?: true
    heroImageUrl?: true
    heroSvg?: true
    heroAlt?: true
    country?: true
    region?: true
    city?: true
    canonicalUrl?: true
    metaTitle?: true
    metaDescription?: true
    featured?: true
    authorName?: true
    sourceUrl?: true
  }

  export type EducationPostMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    slug?: true
    title?: true
    excerpt?: true
    bodyMd?: true
    status?: true
    publishedAt?: true
    category?: true
    heroImageUrl?: true
    heroSvg?: true
    heroAlt?: true
    country?: true
    region?: true
    city?: true
    canonicalUrl?: true
    metaTitle?: true
    metaDescription?: true
    featured?: true
    authorName?: true
    sourceUrl?: true
  }

  export type EducationPostCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    slug?: true
    title?: true
    excerpt?: true
    bodyMd?: true
    status?: true
    publishedAt?: true
    category?: true
    heroImageUrl?: true
    heroSvg?: true
    heroAlt?: true
    country?: true
    region?: true
    city?: true
    canonicalUrl?: true
    metaTitle?: true
    metaDescription?: true
    featured?: true
    authorName?: true
    sourceUrl?: true
    _all?: true
  }

  export type EducationPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EducationPost to aggregate.
     */
    where?: EducationPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EducationPosts to fetch.
     */
    orderBy?: EducationPostOrderByWithRelationInput | EducationPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EducationPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EducationPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EducationPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EducationPosts
    **/
    _count?: true | EducationPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EducationPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EducationPostMaxAggregateInputType
  }

  export type GetEducationPostAggregateType<T extends EducationPostAggregateArgs> = {
        [P in keyof T & keyof AggregateEducationPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEducationPost[P]>
      : GetScalarType<T[P], AggregateEducationPost[P]>
  }




  export type EducationPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EducationPostWhereInput
    orderBy?: EducationPostOrderByWithAggregationInput | EducationPostOrderByWithAggregationInput[]
    by: EducationPostScalarFieldEnum[] | EducationPostScalarFieldEnum
    having?: EducationPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EducationPostCountAggregateInputType | true
    _min?: EducationPostMinAggregateInputType
    _max?: EducationPostMaxAggregateInputType
  }

  export type EducationPostGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    slug: string
    title: string
    excerpt: string | null
    bodyMd: string
    status: $Enums.PostStatus
    publishedAt: Date | null
    category: $Enums.PostCategory
    heroImageUrl: string | null
    heroSvg: string | null
    heroAlt: string | null
    country: string | null
    region: string | null
    city: string | null
    canonicalUrl: string | null
    metaTitle: string | null
    metaDescription: string | null
    featured: boolean
    authorName: string | null
    sourceUrl: string | null
    _count: EducationPostCountAggregateOutputType | null
    _min: EducationPostMinAggregateOutputType | null
    _max: EducationPostMaxAggregateOutputType | null
  }

  type GetEducationPostGroupByPayload<T extends EducationPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EducationPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EducationPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EducationPostGroupByOutputType[P]>
            : GetScalarType<T[P], EducationPostGroupByOutputType[P]>
        }
      >
    >


  export type EducationPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    slug?: boolean
    title?: boolean
    excerpt?: boolean
    bodyMd?: boolean
    status?: boolean
    publishedAt?: boolean
    category?: boolean
    heroImageUrl?: boolean
    heroSvg?: boolean
    heroAlt?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    canonicalUrl?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    featured?: boolean
    authorName?: boolean
    sourceUrl?: boolean
    scamTypes?: boolean | EducationPost$scamTypesArgs<ExtArgs>
    tags?: boolean | EducationPost$tagsArgs<ExtArgs>
    _count?: boolean | EducationPostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["educationPost"]>

  export type EducationPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    slug?: boolean
    title?: boolean
    excerpt?: boolean
    bodyMd?: boolean
    status?: boolean
    publishedAt?: boolean
    category?: boolean
    heroImageUrl?: boolean
    heroSvg?: boolean
    heroAlt?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    canonicalUrl?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    featured?: boolean
    authorName?: boolean
    sourceUrl?: boolean
  }, ExtArgs["result"]["educationPost"]>

  export type EducationPostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    slug?: boolean
    title?: boolean
    excerpt?: boolean
    bodyMd?: boolean
    status?: boolean
    publishedAt?: boolean
    category?: boolean
    heroImageUrl?: boolean
    heroSvg?: boolean
    heroAlt?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    canonicalUrl?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    featured?: boolean
    authorName?: boolean
    sourceUrl?: boolean
  }, ExtArgs["result"]["educationPost"]>

  export type EducationPostSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    slug?: boolean
    title?: boolean
    excerpt?: boolean
    bodyMd?: boolean
    status?: boolean
    publishedAt?: boolean
    category?: boolean
    heroImageUrl?: boolean
    heroSvg?: boolean
    heroAlt?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    canonicalUrl?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    featured?: boolean
    authorName?: boolean
    sourceUrl?: boolean
  }

  export type EducationPostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "slug" | "title" | "excerpt" | "bodyMd" | "status" | "publishedAt" | "category" | "heroImageUrl" | "heroSvg" | "heroAlt" | "country" | "region" | "city" | "canonicalUrl" | "metaTitle" | "metaDescription" | "featured" | "authorName" | "sourceUrl", ExtArgs["result"]["educationPost"]>
  export type EducationPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scamTypes?: boolean | EducationPost$scamTypesArgs<ExtArgs>
    tags?: boolean | EducationPost$tagsArgs<ExtArgs>
    _count?: boolean | EducationPostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EducationPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EducationPostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EducationPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EducationPost"
    objects: {
      scamTypes: Prisma.$EducationPostScamTypePayload<ExtArgs>[]
      tags: Prisma.$PostTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      slug: string
      title: string
      excerpt: string | null
      bodyMd: string
      status: $Enums.PostStatus
      publishedAt: Date | null
      category: $Enums.PostCategory
      heroImageUrl: string | null
      heroSvg: string | null
      heroAlt: string | null
      country: string | null
      region: string | null
      city: string | null
      canonicalUrl: string | null
      metaTitle: string | null
      metaDescription: string | null
      featured: boolean
      authorName: string | null
      sourceUrl: string | null
    }, ExtArgs["result"]["educationPost"]>
    composites: {}
  }

  type EducationPostGetPayload<S extends boolean | null | undefined | EducationPostDefaultArgs> = $Result.GetResult<Prisma.$EducationPostPayload, S>

  type EducationPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EducationPostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EducationPostCountAggregateInputType | true
    }

  export interface EducationPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EducationPost'], meta: { name: 'EducationPost' } }
    /**
     * Find zero or one EducationPost that matches the filter.
     * @param {EducationPostFindUniqueArgs} args - Arguments to find a EducationPost
     * @example
     * // Get one EducationPost
     * const educationPost = await prisma.educationPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EducationPostFindUniqueArgs>(args: SelectSubset<T, EducationPostFindUniqueArgs<ExtArgs>>): Prisma__EducationPostClient<$Result.GetResult<Prisma.$EducationPostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EducationPost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EducationPostFindUniqueOrThrowArgs} args - Arguments to find a EducationPost
     * @example
     * // Get one EducationPost
     * const educationPost = await prisma.educationPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EducationPostFindUniqueOrThrowArgs>(args: SelectSubset<T, EducationPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EducationPostClient<$Result.GetResult<Prisma.$EducationPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EducationPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationPostFindFirstArgs} args - Arguments to find a EducationPost
     * @example
     * // Get one EducationPost
     * const educationPost = await prisma.educationPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EducationPostFindFirstArgs>(args?: SelectSubset<T, EducationPostFindFirstArgs<ExtArgs>>): Prisma__EducationPostClient<$Result.GetResult<Prisma.$EducationPostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EducationPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationPostFindFirstOrThrowArgs} args - Arguments to find a EducationPost
     * @example
     * // Get one EducationPost
     * const educationPost = await prisma.educationPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EducationPostFindFirstOrThrowArgs>(args?: SelectSubset<T, EducationPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__EducationPostClient<$Result.GetResult<Prisma.$EducationPostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EducationPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EducationPosts
     * const educationPosts = await prisma.educationPost.findMany()
     * 
     * // Get first 10 EducationPosts
     * const educationPosts = await prisma.educationPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const educationPostWithIdOnly = await prisma.educationPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EducationPostFindManyArgs>(args?: SelectSubset<T, EducationPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EducationPost.
     * @param {EducationPostCreateArgs} args - Arguments to create a EducationPost.
     * @example
     * // Create one EducationPost
     * const EducationPost = await prisma.educationPost.create({
     *   data: {
     *     // ... data to create a EducationPost
     *   }
     * })
     * 
     */
    create<T extends EducationPostCreateArgs>(args: SelectSubset<T, EducationPostCreateArgs<ExtArgs>>): Prisma__EducationPostClient<$Result.GetResult<Prisma.$EducationPostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EducationPosts.
     * @param {EducationPostCreateManyArgs} args - Arguments to create many EducationPosts.
     * @example
     * // Create many EducationPosts
     * const educationPost = await prisma.educationPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EducationPostCreateManyArgs>(args?: SelectSubset<T, EducationPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EducationPosts and returns the data saved in the database.
     * @param {EducationPostCreateManyAndReturnArgs} args - Arguments to create many EducationPosts.
     * @example
     * // Create many EducationPosts
     * const educationPost = await prisma.educationPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EducationPosts and only return the `id`
     * const educationPostWithIdOnly = await prisma.educationPost.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EducationPostCreateManyAndReturnArgs>(args?: SelectSubset<T, EducationPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationPostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EducationPost.
     * @param {EducationPostDeleteArgs} args - Arguments to delete one EducationPost.
     * @example
     * // Delete one EducationPost
     * const EducationPost = await prisma.educationPost.delete({
     *   where: {
     *     // ... filter to delete one EducationPost
     *   }
     * })
     * 
     */
    delete<T extends EducationPostDeleteArgs>(args: SelectSubset<T, EducationPostDeleteArgs<ExtArgs>>): Prisma__EducationPostClient<$Result.GetResult<Prisma.$EducationPostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EducationPost.
     * @param {EducationPostUpdateArgs} args - Arguments to update one EducationPost.
     * @example
     * // Update one EducationPost
     * const educationPost = await prisma.educationPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EducationPostUpdateArgs>(args: SelectSubset<T, EducationPostUpdateArgs<ExtArgs>>): Prisma__EducationPostClient<$Result.GetResult<Prisma.$EducationPostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EducationPosts.
     * @param {EducationPostDeleteManyArgs} args - Arguments to filter EducationPosts to delete.
     * @example
     * // Delete a few EducationPosts
     * const { count } = await prisma.educationPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EducationPostDeleteManyArgs>(args?: SelectSubset<T, EducationPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EducationPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EducationPosts
     * const educationPost = await prisma.educationPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EducationPostUpdateManyArgs>(args: SelectSubset<T, EducationPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EducationPosts and returns the data updated in the database.
     * @param {EducationPostUpdateManyAndReturnArgs} args - Arguments to update many EducationPosts.
     * @example
     * // Update many EducationPosts
     * const educationPost = await prisma.educationPost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EducationPosts and only return the `id`
     * const educationPostWithIdOnly = await prisma.educationPost.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EducationPostUpdateManyAndReturnArgs>(args: SelectSubset<T, EducationPostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationPostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EducationPost.
     * @param {EducationPostUpsertArgs} args - Arguments to update or create a EducationPost.
     * @example
     * // Update or create a EducationPost
     * const educationPost = await prisma.educationPost.upsert({
     *   create: {
     *     // ... data to create a EducationPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EducationPost we want to update
     *   }
     * })
     */
    upsert<T extends EducationPostUpsertArgs>(args: SelectSubset<T, EducationPostUpsertArgs<ExtArgs>>): Prisma__EducationPostClient<$Result.GetResult<Prisma.$EducationPostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EducationPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationPostCountArgs} args - Arguments to filter EducationPosts to count.
     * @example
     * // Count the number of EducationPosts
     * const count = await prisma.educationPost.count({
     *   where: {
     *     // ... the filter for the EducationPosts we want to count
     *   }
     * })
    **/
    count<T extends EducationPostCountArgs>(
      args?: Subset<T, EducationPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EducationPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EducationPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EducationPostAggregateArgs>(args: Subset<T, EducationPostAggregateArgs>): Prisma.PrismaPromise<GetEducationPostAggregateType<T>>

    /**
     * Group by EducationPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EducationPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EducationPostGroupByArgs['orderBy'] }
        : { orderBy?: EducationPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EducationPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEducationPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EducationPost model
   */
  readonly fields: EducationPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EducationPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EducationPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    scamTypes<T extends EducationPost$scamTypesArgs<ExtArgs> = {}>(args?: Subset<T, EducationPost$scamTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationPostScamTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends EducationPost$tagsArgs<ExtArgs> = {}>(args?: Subset<T, EducationPost$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EducationPost model
   */
  interface EducationPostFieldRefs {
    readonly id: FieldRef<"EducationPost", 'String'>
    readonly createdAt: FieldRef<"EducationPost", 'DateTime'>
    readonly updatedAt: FieldRef<"EducationPost", 'DateTime'>
    readonly slug: FieldRef<"EducationPost", 'String'>
    readonly title: FieldRef<"EducationPost", 'String'>
    readonly excerpt: FieldRef<"EducationPost", 'String'>
    readonly bodyMd: FieldRef<"EducationPost", 'String'>
    readonly status: FieldRef<"EducationPost", 'PostStatus'>
    readonly publishedAt: FieldRef<"EducationPost", 'DateTime'>
    readonly category: FieldRef<"EducationPost", 'PostCategory'>
    readonly heroImageUrl: FieldRef<"EducationPost", 'String'>
    readonly heroSvg: FieldRef<"EducationPost", 'String'>
    readonly heroAlt: FieldRef<"EducationPost", 'String'>
    readonly country: FieldRef<"EducationPost", 'String'>
    readonly region: FieldRef<"EducationPost", 'String'>
    readonly city: FieldRef<"EducationPost", 'String'>
    readonly canonicalUrl: FieldRef<"EducationPost", 'String'>
    readonly metaTitle: FieldRef<"EducationPost", 'String'>
    readonly metaDescription: FieldRef<"EducationPost", 'String'>
    readonly featured: FieldRef<"EducationPost", 'Boolean'>
    readonly authorName: FieldRef<"EducationPost", 'String'>
    readonly sourceUrl: FieldRef<"EducationPost", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EducationPost findUnique
   */
  export type EducationPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationPost
     */
    select?: EducationPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationPost
     */
    omit?: EducationPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationPostInclude<ExtArgs> | null
    /**
     * Filter, which EducationPost to fetch.
     */
    where: EducationPostWhereUniqueInput
  }

  /**
   * EducationPost findUniqueOrThrow
   */
  export type EducationPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationPost
     */
    select?: EducationPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationPost
     */
    omit?: EducationPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationPostInclude<ExtArgs> | null
    /**
     * Filter, which EducationPost to fetch.
     */
    where: EducationPostWhereUniqueInput
  }

  /**
   * EducationPost findFirst
   */
  export type EducationPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationPost
     */
    select?: EducationPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationPost
     */
    omit?: EducationPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationPostInclude<ExtArgs> | null
    /**
     * Filter, which EducationPost to fetch.
     */
    where?: EducationPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EducationPosts to fetch.
     */
    orderBy?: EducationPostOrderByWithRelationInput | EducationPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EducationPosts.
     */
    cursor?: EducationPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EducationPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EducationPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EducationPosts.
     */
    distinct?: EducationPostScalarFieldEnum | EducationPostScalarFieldEnum[]
  }

  /**
   * EducationPost findFirstOrThrow
   */
  export type EducationPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationPost
     */
    select?: EducationPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationPost
     */
    omit?: EducationPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationPostInclude<ExtArgs> | null
    /**
     * Filter, which EducationPost to fetch.
     */
    where?: EducationPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EducationPosts to fetch.
     */
    orderBy?: EducationPostOrderByWithRelationInput | EducationPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EducationPosts.
     */
    cursor?: EducationPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EducationPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EducationPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EducationPosts.
     */
    distinct?: EducationPostScalarFieldEnum | EducationPostScalarFieldEnum[]
  }

  /**
   * EducationPost findMany
   */
  export type EducationPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationPost
     */
    select?: EducationPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationPost
     */
    omit?: EducationPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationPostInclude<ExtArgs> | null
    /**
     * Filter, which EducationPosts to fetch.
     */
    where?: EducationPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EducationPosts to fetch.
     */
    orderBy?: EducationPostOrderByWithRelationInput | EducationPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EducationPosts.
     */
    cursor?: EducationPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EducationPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EducationPosts.
     */
    skip?: number
    distinct?: EducationPostScalarFieldEnum | EducationPostScalarFieldEnum[]
  }

  /**
   * EducationPost create
   */
  export type EducationPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationPost
     */
    select?: EducationPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationPost
     */
    omit?: EducationPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationPostInclude<ExtArgs> | null
    /**
     * The data needed to create a EducationPost.
     */
    data: XOR<EducationPostCreateInput, EducationPostUncheckedCreateInput>
  }

  /**
   * EducationPost createMany
   */
  export type EducationPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EducationPosts.
     */
    data: EducationPostCreateManyInput | EducationPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EducationPost createManyAndReturn
   */
  export type EducationPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationPost
     */
    select?: EducationPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EducationPost
     */
    omit?: EducationPostOmit<ExtArgs> | null
    /**
     * The data used to create many EducationPosts.
     */
    data: EducationPostCreateManyInput | EducationPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EducationPost update
   */
  export type EducationPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationPost
     */
    select?: EducationPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationPost
     */
    omit?: EducationPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationPostInclude<ExtArgs> | null
    /**
     * The data needed to update a EducationPost.
     */
    data: XOR<EducationPostUpdateInput, EducationPostUncheckedUpdateInput>
    /**
     * Choose, which EducationPost to update.
     */
    where: EducationPostWhereUniqueInput
  }

  /**
   * EducationPost updateMany
   */
  export type EducationPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EducationPosts.
     */
    data: XOR<EducationPostUpdateManyMutationInput, EducationPostUncheckedUpdateManyInput>
    /**
     * Filter which EducationPosts to update
     */
    where?: EducationPostWhereInput
    /**
     * Limit how many EducationPosts to update.
     */
    limit?: number
  }

  /**
   * EducationPost updateManyAndReturn
   */
  export type EducationPostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationPost
     */
    select?: EducationPostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EducationPost
     */
    omit?: EducationPostOmit<ExtArgs> | null
    /**
     * The data used to update EducationPosts.
     */
    data: XOR<EducationPostUpdateManyMutationInput, EducationPostUncheckedUpdateManyInput>
    /**
     * Filter which EducationPosts to update
     */
    where?: EducationPostWhereInput
    /**
     * Limit how many EducationPosts to update.
     */
    limit?: number
  }

  /**
   * EducationPost upsert
   */
  export type EducationPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationPost
     */
    select?: EducationPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationPost
     */
    omit?: EducationPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationPostInclude<ExtArgs> | null
    /**
     * The filter to search for the EducationPost to update in case it exists.
     */
    where: EducationPostWhereUniqueInput
    /**
     * In case the EducationPost found by the `where` argument doesn't exist, create a new EducationPost with this data.
     */
    create: XOR<EducationPostCreateInput, EducationPostUncheckedCreateInput>
    /**
     * In case the EducationPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EducationPostUpdateInput, EducationPostUncheckedUpdateInput>
  }

  /**
   * EducationPost delete
   */
  export type EducationPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationPost
     */
    select?: EducationPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationPost
     */
    omit?: EducationPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationPostInclude<ExtArgs> | null
    /**
     * Filter which EducationPost to delete.
     */
    where: EducationPostWhereUniqueInput
  }

  /**
   * EducationPost deleteMany
   */
  export type EducationPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EducationPosts to delete
     */
    where?: EducationPostWhereInput
    /**
     * Limit how many EducationPosts to delete.
     */
    limit?: number
  }

  /**
   * EducationPost.scamTypes
   */
  export type EducationPost$scamTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationPostScamType
     */
    select?: EducationPostScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationPostScamType
     */
    omit?: EducationPostScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationPostScamTypeInclude<ExtArgs> | null
    where?: EducationPostScamTypeWhereInput
    orderBy?: EducationPostScamTypeOrderByWithRelationInput | EducationPostScamTypeOrderByWithRelationInput[]
    cursor?: EducationPostScamTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EducationPostScamTypeScalarFieldEnum | EducationPostScamTypeScalarFieldEnum[]
  }

  /**
   * EducationPost.tags
   */
  export type EducationPost$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    where?: PostTagWhereInput
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    cursor?: PostTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostTagScalarFieldEnum | PostTagScalarFieldEnum[]
  }

  /**
   * EducationPost without action
   */
  export type EducationPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationPost
     */
    select?: EducationPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationPost
     */
    omit?: EducationPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationPostInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    name: string
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contacts?: boolean | Tag$contactsArgs<ExtArgs>
    posts?: boolean | Tag$postsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contacts?: boolean | Tag$contactsArgs<ExtArgs>
    posts?: boolean | Tag$postsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      contacts: Prisma.$ContactTagPayload<ExtArgs>[]
      posts: Prisma.$PostTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contacts<T extends Tag$contactsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posts<T extends Tag$postsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.contacts
   */
  export type Tag$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
    where?: ContactTagWhereInput
    orderBy?: ContactTagOrderByWithRelationInput | ContactTagOrderByWithRelationInput[]
    cursor?: ContactTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactTagScalarFieldEnum | ContactTagScalarFieldEnum[]
  }

  /**
   * Tag.posts
   */
  export type Tag$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    where?: PostTagWhereInput
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    cursor?: PostTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostTagScalarFieldEnum | PostTagScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model PostTag
   */

  export type AggregatePostTag = {
    _count: PostTagCountAggregateOutputType | null
    _min: PostTagMinAggregateOutputType | null
    _max: PostTagMaxAggregateOutputType | null
  }

  export type PostTagMinAggregateOutputType = {
    postId: string | null
    tagId: string | null
  }

  export type PostTagMaxAggregateOutputType = {
    postId: string | null
    tagId: string | null
  }

  export type PostTagCountAggregateOutputType = {
    postId: number
    tagId: number
    _all: number
  }


  export type PostTagMinAggregateInputType = {
    postId?: true
    tagId?: true
  }

  export type PostTagMaxAggregateInputType = {
    postId?: true
    tagId?: true
  }

  export type PostTagCountAggregateInputType = {
    postId?: true
    tagId?: true
    _all?: true
  }

  export type PostTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostTag to aggregate.
     */
    where?: PostTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostTags to fetch.
     */
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostTags
    **/
    _count?: true | PostTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostTagMaxAggregateInputType
  }

  export type GetPostTagAggregateType<T extends PostTagAggregateArgs> = {
        [P in keyof T & keyof AggregatePostTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostTag[P]>
      : GetScalarType<T[P], AggregatePostTag[P]>
  }




  export type PostTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostTagWhereInput
    orderBy?: PostTagOrderByWithAggregationInput | PostTagOrderByWithAggregationInput[]
    by: PostTagScalarFieldEnum[] | PostTagScalarFieldEnum
    having?: PostTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostTagCountAggregateInputType | true
    _min?: PostTagMinAggregateInputType
    _max?: PostTagMaxAggregateInputType
  }

  export type PostTagGroupByOutputType = {
    postId: string
    tagId: string
    _count: PostTagCountAggregateOutputType | null
    _min: PostTagMinAggregateOutputType | null
    _max: PostTagMaxAggregateOutputType | null
  }

  type GetPostTagGroupByPayload<T extends PostTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostTagGroupByOutputType[P]>
            : GetScalarType<T[P], PostTagGroupByOutputType[P]>
        }
      >
    >


  export type PostTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postId?: boolean
    tagId?: boolean
    post?: boolean | EducationPostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postTag"]>

  export type PostTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postId?: boolean
    tagId?: boolean
    post?: boolean | EducationPostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postTag"]>

  export type PostTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postId?: boolean
    tagId?: boolean
    post?: boolean | EducationPostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postTag"]>

  export type PostTagSelectScalar = {
    postId?: boolean
    tagId?: boolean
  }

  export type PostTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"postId" | "tagId", ExtArgs["result"]["postTag"]>
  export type PostTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | EducationPostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type PostTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | EducationPostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type PostTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | EducationPostDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $PostTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostTag"
    objects: {
      post: Prisma.$EducationPostPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      postId: string
      tagId: string
    }, ExtArgs["result"]["postTag"]>
    composites: {}
  }

  type PostTagGetPayload<S extends boolean | null | undefined | PostTagDefaultArgs> = $Result.GetResult<Prisma.$PostTagPayload, S>

  type PostTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostTagCountAggregateInputType | true
    }

  export interface PostTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostTag'], meta: { name: 'PostTag' } }
    /**
     * Find zero or one PostTag that matches the filter.
     * @param {PostTagFindUniqueArgs} args - Arguments to find a PostTag
     * @example
     * // Get one PostTag
     * const postTag = await prisma.postTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostTagFindUniqueArgs>(args: SelectSubset<T, PostTagFindUniqueArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PostTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostTagFindUniqueOrThrowArgs} args - Arguments to find a PostTag
     * @example
     * // Get one PostTag
     * const postTag = await prisma.postTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostTagFindUniqueOrThrowArgs>(args: SelectSubset<T, PostTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagFindFirstArgs} args - Arguments to find a PostTag
     * @example
     * // Get one PostTag
     * const postTag = await prisma.postTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostTagFindFirstArgs>(args?: SelectSubset<T, PostTagFindFirstArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagFindFirstOrThrowArgs} args - Arguments to find a PostTag
     * @example
     * // Get one PostTag
     * const postTag = await prisma.postTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostTagFindFirstOrThrowArgs>(args?: SelectSubset<T, PostTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PostTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostTags
     * const postTags = await prisma.postTag.findMany()
     * 
     * // Get first 10 PostTags
     * const postTags = await prisma.postTag.findMany({ take: 10 })
     * 
     * // Only select the `postId`
     * const postTagWithPostIdOnly = await prisma.postTag.findMany({ select: { postId: true } })
     * 
     */
    findMany<T extends PostTagFindManyArgs>(args?: SelectSubset<T, PostTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PostTag.
     * @param {PostTagCreateArgs} args - Arguments to create a PostTag.
     * @example
     * // Create one PostTag
     * const PostTag = await prisma.postTag.create({
     *   data: {
     *     // ... data to create a PostTag
     *   }
     * })
     * 
     */
    create<T extends PostTagCreateArgs>(args: SelectSubset<T, PostTagCreateArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PostTags.
     * @param {PostTagCreateManyArgs} args - Arguments to create many PostTags.
     * @example
     * // Create many PostTags
     * const postTag = await prisma.postTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostTagCreateManyArgs>(args?: SelectSubset<T, PostTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostTags and returns the data saved in the database.
     * @param {PostTagCreateManyAndReturnArgs} args - Arguments to create many PostTags.
     * @example
     * // Create many PostTags
     * const postTag = await prisma.postTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostTags and only return the `postId`
     * const postTagWithPostIdOnly = await prisma.postTag.createManyAndReturn({
     *   select: { postId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostTagCreateManyAndReturnArgs>(args?: SelectSubset<T, PostTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PostTag.
     * @param {PostTagDeleteArgs} args - Arguments to delete one PostTag.
     * @example
     * // Delete one PostTag
     * const PostTag = await prisma.postTag.delete({
     *   where: {
     *     // ... filter to delete one PostTag
     *   }
     * })
     * 
     */
    delete<T extends PostTagDeleteArgs>(args: SelectSubset<T, PostTagDeleteArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PostTag.
     * @param {PostTagUpdateArgs} args - Arguments to update one PostTag.
     * @example
     * // Update one PostTag
     * const postTag = await prisma.postTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostTagUpdateArgs>(args: SelectSubset<T, PostTagUpdateArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PostTags.
     * @param {PostTagDeleteManyArgs} args - Arguments to filter PostTags to delete.
     * @example
     * // Delete a few PostTags
     * const { count } = await prisma.postTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostTagDeleteManyArgs>(args?: SelectSubset<T, PostTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostTags
     * const postTag = await prisma.postTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostTagUpdateManyArgs>(args: SelectSubset<T, PostTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostTags and returns the data updated in the database.
     * @param {PostTagUpdateManyAndReturnArgs} args - Arguments to update many PostTags.
     * @example
     * // Update many PostTags
     * const postTag = await prisma.postTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PostTags and only return the `postId`
     * const postTagWithPostIdOnly = await prisma.postTag.updateManyAndReturn({
     *   select: { postId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostTagUpdateManyAndReturnArgs>(args: SelectSubset<T, PostTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PostTag.
     * @param {PostTagUpsertArgs} args - Arguments to update or create a PostTag.
     * @example
     * // Update or create a PostTag
     * const postTag = await prisma.postTag.upsert({
     *   create: {
     *     // ... data to create a PostTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostTag we want to update
     *   }
     * })
     */
    upsert<T extends PostTagUpsertArgs>(args: SelectSubset<T, PostTagUpsertArgs<ExtArgs>>): Prisma__PostTagClient<$Result.GetResult<Prisma.$PostTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PostTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagCountArgs} args - Arguments to filter PostTags to count.
     * @example
     * // Count the number of PostTags
     * const count = await prisma.postTag.count({
     *   where: {
     *     // ... the filter for the PostTags we want to count
     *   }
     * })
    **/
    count<T extends PostTagCountArgs>(
      args?: Subset<T, PostTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostTagAggregateArgs>(args: Subset<T, PostTagAggregateArgs>): Prisma.PrismaPromise<GetPostTagAggregateType<T>>

    /**
     * Group by PostTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostTagGroupByArgs['orderBy'] }
        : { orderBy?: PostTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostTag model
   */
  readonly fields: PostTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends EducationPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EducationPostDefaultArgs<ExtArgs>>): Prisma__EducationPostClient<$Result.GetResult<Prisma.$EducationPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostTag model
   */
  interface PostTagFieldRefs {
    readonly postId: FieldRef<"PostTag", 'String'>
    readonly tagId: FieldRef<"PostTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PostTag findUnique
   */
  export type PostTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter, which PostTag to fetch.
     */
    where: PostTagWhereUniqueInput
  }

  /**
   * PostTag findUniqueOrThrow
   */
  export type PostTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter, which PostTag to fetch.
     */
    where: PostTagWhereUniqueInput
  }

  /**
   * PostTag findFirst
   */
  export type PostTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter, which PostTag to fetch.
     */
    where?: PostTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostTags to fetch.
     */
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostTags.
     */
    cursor?: PostTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostTags.
     */
    distinct?: PostTagScalarFieldEnum | PostTagScalarFieldEnum[]
  }

  /**
   * PostTag findFirstOrThrow
   */
  export type PostTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter, which PostTag to fetch.
     */
    where?: PostTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostTags to fetch.
     */
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostTags.
     */
    cursor?: PostTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostTags.
     */
    distinct?: PostTagScalarFieldEnum | PostTagScalarFieldEnum[]
  }

  /**
   * PostTag findMany
   */
  export type PostTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter, which PostTags to fetch.
     */
    where?: PostTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostTags to fetch.
     */
    orderBy?: PostTagOrderByWithRelationInput | PostTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostTags.
     */
    cursor?: PostTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostTags.
     */
    skip?: number
    distinct?: PostTagScalarFieldEnum | PostTagScalarFieldEnum[]
  }

  /**
   * PostTag create
   */
  export type PostTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * The data needed to create a PostTag.
     */
    data: XOR<PostTagCreateInput, PostTagUncheckedCreateInput>
  }

  /**
   * PostTag createMany
   */
  export type PostTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostTags.
     */
    data: PostTagCreateManyInput | PostTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostTag createManyAndReturn
   */
  export type PostTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * The data used to create many PostTags.
     */
    data: PostTagCreateManyInput | PostTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostTag update
   */
  export type PostTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * The data needed to update a PostTag.
     */
    data: XOR<PostTagUpdateInput, PostTagUncheckedUpdateInput>
    /**
     * Choose, which PostTag to update.
     */
    where: PostTagWhereUniqueInput
  }

  /**
   * PostTag updateMany
   */
  export type PostTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostTags.
     */
    data: XOR<PostTagUpdateManyMutationInput, PostTagUncheckedUpdateManyInput>
    /**
     * Filter which PostTags to update
     */
    where?: PostTagWhereInput
    /**
     * Limit how many PostTags to update.
     */
    limit?: number
  }

  /**
   * PostTag updateManyAndReturn
   */
  export type PostTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * The data used to update PostTags.
     */
    data: XOR<PostTagUpdateManyMutationInput, PostTagUncheckedUpdateManyInput>
    /**
     * Filter which PostTags to update
     */
    where?: PostTagWhereInput
    /**
     * Limit how many PostTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostTag upsert
   */
  export type PostTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * The filter to search for the PostTag to update in case it exists.
     */
    where: PostTagWhereUniqueInput
    /**
     * In case the PostTag found by the `where` argument doesn't exist, create a new PostTag with this data.
     */
    create: XOR<PostTagCreateInput, PostTagUncheckedCreateInput>
    /**
     * In case the PostTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostTagUpdateInput, PostTagUncheckedUpdateInput>
  }

  /**
   * PostTag delete
   */
  export type PostTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
    /**
     * Filter which PostTag to delete.
     */
    where: PostTagWhereUniqueInput
  }

  /**
   * PostTag deleteMany
   */
  export type PostTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostTags to delete
     */
    where?: PostTagWhereInput
    /**
     * Limit how many PostTags to delete.
     */
    limit?: number
  }

  /**
   * PostTag without action
   */
  export type PostTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostTag
     */
    select?: PostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostTag
     */
    omit?: PostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostTagInclude<ExtArgs> | null
  }


  /**
   * Model EducationPostScamType
   */

  export type AggregateEducationPostScamType = {
    _count: EducationPostScamTypeCountAggregateOutputType | null
    _min: EducationPostScamTypeMinAggregateOutputType | null
    _max: EducationPostScamTypeMaxAggregateOutputType | null
  }

  export type EducationPostScamTypeMinAggregateOutputType = {
    postId: string | null
    scamTypeId: string | null
  }

  export type EducationPostScamTypeMaxAggregateOutputType = {
    postId: string | null
    scamTypeId: string | null
  }

  export type EducationPostScamTypeCountAggregateOutputType = {
    postId: number
    scamTypeId: number
    _all: number
  }


  export type EducationPostScamTypeMinAggregateInputType = {
    postId?: true
    scamTypeId?: true
  }

  export type EducationPostScamTypeMaxAggregateInputType = {
    postId?: true
    scamTypeId?: true
  }

  export type EducationPostScamTypeCountAggregateInputType = {
    postId?: true
    scamTypeId?: true
    _all?: true
  }

  export type EducationPostScamTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EducationPostScamType to aggregate.
     */
    where?: EducationPostScamTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EducationPostScamTypes to fetch.
     */
    orderBy?: EducationPostScamTypeOrderByWithRelationInput | EducationPostScamTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EducationPostScamTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EducationPostScamTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EducationPostScamTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EducationPostScamTypes
    **/
    _count?: true | EducationPostScamTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EducationPostScamTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EducationPostScamTypeMaxAggregateInputType
  }

  export type GetEducationPostScamTypeAggregateType<T extends EducationPostScamTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateEducationPostScamType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEducationPostScamType[P]>
      : GetScalarType<T[P], AggregateEducationPostScamType[P]>
  }




  export type EducationPostScamTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EducationPostScamTypeWhereInput
    orderBy?: EducationPostScamTypeOrderByWithAggregationInput | EducationPostScamTypeOrderByWithAggregationInput[]
    by: EducationPostScamTypeScalarFieldEnum[] | EducationPostScamTypeScalarFieldEnum
    having?: EducationPostScamTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EducationPostScamTypeCountAggregateInputType | true
    _min?: EducationPostScamTypeMinAggregateInputType
    _max?: EducationPostScamTypeMaxAggregateInputType
  }

  export type EducationPostScamTypeGroupByOutputType = {
    postId: string
    scamTypeId: string
    _count: EducationPostScamTypeCountAggregateOutputType | null
    _min: EducationPostScamTypeMinAggregateOutputType | null
    _max: EducationPostScamTypeMaxAggregateOutputType | null
  }

  type GetEducationPostScamTypeGroupByPayload<T extends EducationPostScamTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EducationPostScamTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EducationPostScamTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EducationPostScamTypeGroupByOutputType[P]>
            : GetScalarType<T[P], EducationPostScamTypeGroupByOutputType[P]>
        }
      >
    >


  export type EducationPostScamTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postId?: boolean
    scamTypeId?: boolean
    post?: boolean | EducationPostDefaultArgs<ExtArgs>
    scamType?: boolean | ScamTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["educationPostScamType"]>

  export type EducationPostScamTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postId?: boolean
    scamTypeId?: boolean
    post?: boolean | EducationPostDefaultArgs<ExtArgs>
    scamType?: boolean | ScamTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["educationPostScamType"]>

  export type EducationPostScamTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    postId?: boolean
    scamTypeId?: boolean
    post?: boolean | EducationPostDefaultArgs<ExtArgs>
    scamType?: boolean | ScamTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["educationPostScamType"]>

  export type EducationPostScamTypeSelectScalar = {
    postId?: boolean
    scamTypeId?: boolean
  }

  export type EducationPostScamTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"postId" | "scamTypeId", ExtArgs["result"]["educationPostScamType"]>
  export type EducationPostScamTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | EducationPostDefaultArgs<ExtArgs>
    scamType?: boolean | ScamTypeDefaultArgs<ExtArgs>
  }
  export type EducationPostScamTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | EducationPostDefaultArgs<ExtArgs>
    scamType?: boolean | ScamTypeDefaultArgs<ExtArgs>
  }
  export type EducationPostScamTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | EducationPostDefaultArgs<ExtArgs>
    scamType?: boolean | ScamTypeDefaultArgs<ExtArgs>
  }

  export type $EducationPostScamTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EducationPostScamType"
    objects: {
      post: Prisma.$EducationPostPayload<ExtArgs>
      scamType: Prisma.$ScamTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      postId: string
      scamTypeId: string
    }, ExtArgs["result"]["educationPostScamType"]>
    composites: {}
  }

  type EducationPostScamTypeGetPayload<S extends boolean | null | undefined | EducationPostScamTypeDefaultArgs> = $Result.GetResult<Prisma.$EducationPostScamTypePayload, S>

  type EducationPostScamTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EducationPostScamTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EducationPostScamTypeCountAggregateInputType | true
    }

  export interface EducationPostScamTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EducationPostScamType'], meta: { name: 'EducationPostScamType' } }
    /**
     * Find zero or one EducationPostScamType that matches the filter.
     * @param {EducationPostScamTypeFindUniqueArgs} args - Arguments to find a EducationPostScamType
     * @example
     * // Get one EducationPostScamType
     * const educationPostScamType = await prisma.educationPostScamType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EducationPostScamTypeFindUniqueArgs>(args: SelectSubset<T, EducationPostScamTypeFindUniqueArgs<ExtArgs>>): Prisma__EducationPostScamTypeClient<$Result.GetResult<Prisma.$EducationPostScamTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EducationPostScamType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EducationPostScamTypeFindUniqueOrThrowArgs} args - Arguments to find a EducationPostScamType
     * @example
     * // Get one EducationPostScamType
     * const educationPostScamType = await prisma.educationPostScamType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EducationPostScamTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, EducationPostScamTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EducationPostScamTypeClient<$Result.GetResult<Prisma.$EducationPostScamTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EducationPostScamType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationPostScamTypeFindFirstArgs} args - Arguments to find a EducationPostScamType
     * @example
     * // Get one EducationPostScamType
     * const educationPostScamType = await prisma.educationPostScamType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EducationPostScamTypeFindFirstArgs>(args?: SelectSubset<T, EducationPostScamTypeFindFirstArgs<ExtArgs>>): Prisma__EducationPostScamTypeClient<$Result.GetResult<Prisma.$EducationPostScamTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EducationPostScamType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationPostScamTypeFindFirstOrThrowArgs} args - Arguments to find a EducationPostScamType
     * @example
     * // Get one EducationPostScamType
     * const educationPostScamType = await prisma.educationPostScamType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EducationPostScamTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, EducationPostScamTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EducationPostScamTypeClient<$Result.GetResult<Prisma.$EducationPostScamTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EducationPostScamTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationPostScamTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EducationPostScamTypes
     * const educationPostScamTypes = await prisma.educationPostScamType.findMany()
     * 
     * // Get first 10 EducationPostScamTypes
     * const educationPostScamTypes = await prisma.educationPostScamType.findMany({ take: 10 })
     * 
     * // Only select the `postId`
     * const educationPostScamTypeWithPostIdOnly = await prisma.educationPostScamType.findMany({ select: { postId: true } })
     * 
     */
    findMany<T extends EducationPostScamTypeFindManyArgs>(args?: SelectSubset<T, EducationPostScamTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationPostScamTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EducationPostScamType.
     * @param {EducationPostScamTypeCreateArgs} args - Arguments to create a EducationPostScamType.
     * @example
     * // Create one EducationPostScamType
     * const EducationPostScamType = await prisma.educationPostScamType.create({
     *   data: {
     *     // ... data to create a EducationPostScamType
     *   }
     * })
     * 
     */
    create<T extends EducationPostScamTypeCreateArgs>(args: SelectSubset<T, EducationPostScamTypeCreateArgs<ExtArgs>>): Prisma__EducationPostScamTypeClient<$Result.GetResult<Prisma.$EducationPostScamTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EducationPostScamTypes.
     * @param {EducationPostScamTypeCreateManyArgs} args - Arguments to create many EducationPostScamTypes.
     * @example
     * // Create many EducationPostScamTypes
     * const educationPostScamType = await prisma.educationPostScamType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EducationPostScamTypeCreateManyArgs>(args?: SelectSubset<T, EducationPostScamTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EducationPostScamTypes and returns the data saved in the database.
     * @param {EducationPostScamTypeCreateManyAndReturnArgs} args - Arguments to create many EducationPostScamTypes.
     * @example
     * // Create many EducationPostScamTypes
     * const educationPostScamType = await prisma.educationPostScamType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EducationPostScamTypes and only return the `postId`
     * const educationPostScamTypeWithPostIdOnly = await prisma.educationPostScamType.createManyAndReturn({
     *   select: { postId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EducationPostScamTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, EducationPostScamTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationPostScamTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EducationPostScamType.
     * @param {EducationPostScamTypeDeleteArgs} args - Arguments to delete one EducationPostScamType.
     * @example
     * // Delete one EducationPostScamType
     * const EducationPostScamType = await prisma.educationPostScamType.delete({
     *   where: {
     *     // ... filter to delete one EducationPostScamType
     *   }
     * })
     * 
     */
    delete<T extends EducationPostScamTypeDeleteArgs>(args: SelectSubset<T, EducationPostScamTypeDeleteArgs<ExtArgs>>): Prisma__EducationPostScamTypeClient<$Result.GetResult<Prisma.$EducationPostScamTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EducationPostScamType.
     * @param {EducationPostScamTypeUpdateArgs} args - Arguments to update one EducationPostScamType.
     * @example
     * // Update one EducationPostScamType
     * const educationPostScamType = await prisma.educationPostScamType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EducationPostScamTypeUpdateArgs>(args: SelectSubset<T, EducationPostScamTypeUpdateArgs<ExtArgs>>): Prisma__EducationPostScamTypeClient<$Result.GetResult<Prisma.$EducationPostScamTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EducationPostScamTypes.
     * @param {EducationPostScamTypeDeleteManyArgs} args - Arguments to filter EducationPostScamTypes to delete.
     * @example
     * // Delete a few EducationPostScamTypes
     * const { count } = await prisma.educationPostScamType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EducationPostScamTypeDeleteManyArgs>(args?: SelectSubset<T, EducationPostScamTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EducationPostScamTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationPostScamTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EducationPostScamTypes
     * const educationPostScamType = await prisma.educationPostScamType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EducationPostScamTypeUpdateManyArgs>(args: SelectSubset<T, EducationPostScamTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EducationPostScamTypes and returns the data updated in the database.
     * @param {EducationPostScamTypeUpdateManyAndReturnArgs} args - Arguments to update many EducationPostScamTypes.
     * @example
     * // Update many EducationPostScamTypes
     * const educationPostScamType = await prisma.educationPostScamType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EducationPostScamTypes and only return the `postId`
     * const educationPostScamTypeWithPostIdOnly = await prisma.educationPostScamType.updateManyAndReturn({
     *   select: { postId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EducationPostScamTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, EducationPostScamTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationPostScamTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EducationPostScamType.
     * @param {EducationPostScamTypeUpsertArgs} args - Arguments to update or create a EducationPostScamType.
     * @example
     * // Update or create a EducationPostScamType
     * const educationPostScamType = await prisma.educationPostScamType.upsert({
     *   create: {
     *     // ... data to create a EducationPostScamType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EducationPostScamType we want to update
     *   }
     * })
     */
    upsert<T extends EducationPostScamTypeUpsertArgs>(args: SelectSubset<T, EducationPostScamTypeUpsertArgs<ExtArgs>>): Prisma__EducationPostScamTypeClient<$Result.GetResult<Prisma.$EducationPostScamTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EducationPostScamTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationPostScamTypeCountArgs} args - Arguments to filter EducationPostScamTypes to count.
     * @example
     * // Count the number of EducationPostScamTypes
     * const count = await prisma.educationPostScamType.count({
     *   where: {
     *     // ... the filter for the EducationPostScamTypes we want to count
     *   }
     * })
    **/
    count<T extends EducationPostScamTypeCountArgs>(
      args?: Subset<T, EducationPostScamTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EducationPostScamTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EducationPostScamType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationPostScamTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EducationPostScamTypeAggregateArgs>(args: Subset<T, EducationPostScamTypeAggregateArgs>): Prisma.PrismaPromise<GetEducationPostScamTypeAggregateType<T>>

    /**
     * Group by EducationPostScamType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationPostScamTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EducationPostScamTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EducationPostScamTypeGroupByArgs['orderBy'] }
        : { orderBy?: EducationPostScamTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EducationPostScamTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEducationPostScamTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EducationPostScamType model
   */
  readonly fields: EducationPostScamTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EducationPostScamType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EducationPostScamTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends EducationPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EducationPostDefaultArgs<ExtArgs>>): Prisma__EducationPostClient<$Result.GetResult<Prisma.$EducationPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    scamType<T extends ScamTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ScamTypeDefaultArgs<ExtArgs>>): Prisma__ScamTypeClient<$Result.GetResult<Prisma.$ScamTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EducationPostScamType model
   */
  interface EducationPostScamTypeFieldRefs {
    readonly postId: FieldRef<"EducationPostScamType", 'String'>
    readonly scamTypeId: FieldRef<"EducationPostScamType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EducationPostScamType findUnique
   */
  export type EducationPostScamTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationPostScamType
     */
    select?: EducationPostScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationPostScamType
     */
    omit?: EducationPostScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationPostScamTypeInclude<ExtArgs> | null
    /**
     * Filter, which EducationPostScamType to fetch.
     */
    where: EducationPostScamTypeWhereUniqueInput
  }

  /**
   * EducationPostScamType findUniqueOrThrow
   */
  export type EducationPostScamTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationPostScamType
     */
    select?: EducationPostScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationPostScamType
     */
    omit?: EducationPostScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationPostScamTypeInclude<ExtArgs> | null
    /**
     * Filter, which EducationPostScamType to fetch.
     */
    where: EducationPostScamTypeWhereUniqueInput
  }

  /**
   * EducationPostScamType findFirst
   */
  export type EducationPostScamTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationPostScamType
     */
    select?: EducationPostScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationPostScamType
     */
    omit?: EducationPostScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationPostScamTypeInclude<ExtArgs> | null
    /**
     * Filter, which EducationPostScamType to fetch.
     */
    where?: EducationPostScamTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EducationPostScamTypes to fetch.
     */
    orderBy?: EducationPostScamTypeOrderByWithRelationInput | EducationPostScamTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EducationPostScamTypes.
     */
    cursor?: EducationPostScamTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EducationPostScamTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EducationPostScamTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EducationPostScamTypes.
     */
    distinct?: EducationPostScamTypeScalarFieldEnum | EducationPostScamTypeScalarFieldEnum[]
  }

  /**
   * EducationPostScamType findFirstOrThrow
   */
  export type EducationPostScamTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationPostScamType
     */
    select?: EducationPostScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationPostScamType
     */
    omit?: EducationPostScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationPostScamTypeInclude<ExtArgs> | null
    /**
     * Filter, which EducationPostScamType to fetch.
     */
    where?: EducationPostScamTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EducationPostScamTypes to fetch.
     */
    orderBy?: EducationPostScamTypeOrderByWithRelationInput | EducationPostScamTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EducationPostScamTypes.
     */
    cursor?: EducationPostScamTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EducationPostScamTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EducationPostScamTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EducationPostScamTypes.
     */
    distinct?: EducationPostScamTypeScalarFieldEnum | EducationPostScamTypeScalarFieldEnum[]
  }

  /**
   * EducationPostScamType findMany
   */
  export type EducationPostScamTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationPostScamType
     */
    select?: EducationPostScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationPostScamType
     */
    omit?: EducationPostScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationPostScamTypeInclude<ExtArgs> | null
    /**
     * Filter, which EducationPostScamTypes to fetch.
     */
    where?: EducationPostScamTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EducationPostScamTypes to fetch.
     */
    orderBy?: EducationPostScamTypeOrderByWithRelationInput | EducationPostScamTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EducationPostScamTypes.
     */
    cursor?: EducationPostScamTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EducationPostScamTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EducationPostScamTypes.
     */
    skip?: number
    distinct?: EducationPostScamTypeScalarFieldEnum | EducationPostScamTypeScalarFieldEnum[]
  }

  /**
   * EducationPostScamType create
   */
  export type EducationPostScamTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationPostScamType
     */
    select?: EducationPostScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationPostScamType
     */
    omit?: EducationPostScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationPostScamTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a EducationPostScamType.
     */
    data: XOR<EducationPostScamTypeCreateInput, EducationPostScamTypeUncheckedCreateInput>
  }

  /**
   * EducationPostScamType createMany
   */
  export type EducationPostScamTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EducationPostScamTypes.
     */
    data: EducationPostScamTypeCreateManyInput | EducationPostScamTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EducationPostScamType createManyAndReturn
   */
  export type EducationPostScamTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationPostScamType
     */
    select?: EducationPostScamTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EducationPostScamType
     */
    omit?: EducationPostScamTypeOmit<ExtArgs> | null
    /**
     * The data used to create many EducationPostScamTypes.
     */
    data: EducationPostScamTypeCreateManyInput | EducationPostScamTypeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationPostScamTypeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EducationPostScamType update
   */
  export type EducationPostScamTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationPostScamType
     */
    select?: EducationPostScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationPostScamType
     */
    omit?: EducationPostScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationPostScamTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a EducationPostScamType.
     */
    data: XOR<EducationPostScamTypeUpdateInput, EducationPostScamTypeUncheckedUpdateInput>
    /**
     * Choose, which EducationPostScamType to update.
     */
    where: EducationPostScamTypeWhereUniqueInput
  }

  /**
   * EducationPostScamType updateMany
   */
  export type EducationPostScamTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EducationPostScamTypes.
     */
    data: XOR<EducationPostScamTypeUpdateManyMutationInput, EducationPostScamTypeUncheckedUpdateManyInput>
    /**
     * Filter which EducationPostScamTypes to update
     */
    where?: EducationPostScamTypeWhereInput
    /**
     * Limit how many EducationPostScamTypes to update.
     */
    limit?: number
  }

  /**
   * EducationPostScamType updateManyAndReturn
   */
  export type EducationPostScamTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationPostScamType
     */
    select?: EducationPostScamTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EducationPostScamType
     */
    omit?: EducationPostScamTypeOmit<ExtArgs> | null
    /**
     * The data used to update EducationPostScamTypes.
     */
    data: XOR<EducationPostScamTypeUpdateManyMutationInput, EducationPostScamTypeUncheckedUpdateManyInput>
    /**
     * Filter which EducationPostScamTypes to update
     */
    where?: EducationPostScamTypeWhereInput
    /**
     * Limit how many EducationPostScamTypes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationPostScamTypeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EducationPostScamType upsert
   */
  export type EducationPostScamTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationPostScamType
     */
    select?: EducationPostScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationPostScamType
     */
    omit?: EducationPostScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationPostScamTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the EducationPostScamType to update in case it exists.
     */
    where: EducationPostScamTypeWhereUniqueInput
    /**
     * In case the EducationPostScamType found by the `where` argument doesn't exist, create a new EducationPostScamType with this data.
     */
    create: XOR<EducationPostScamTypeCreateInput, EducationPostScamTypeUncheckedCreateInput>
    /**
     * In case the EducationPostScamType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EducationPostScamTypeUpdateInput, EducationPostScamTypeUncheckedUpdateInput>
  }

  /**
   * EducationPostScamType delete
   */
  export type EducationPostScamTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationPostScamType
     */
    select?: EducationPostScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationPostScamType
     */
    omit?: EducationPostScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationPostScamTypeInclude<ExtArgs> | null
    /**
     * Filter which EducationPostScamType to delete.
     */
    where: EducationPostScamTypeWhereUniqueInput
  }

  /**
   * EducationPostScamType deleteMany
   */
  export type EducationPostScamTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EducationPostScamTypes to delete
     */
    where?: EducationPostScamTypeWhereInput
    /**
     * Limit how many EducationPostScamTypes to delete.
     */
    limit?: number
  }

  /**
   * EducationPostScamType without action
   */
  export type EducationPostScamTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationPostScamType
     */
    select?: EducationPostScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EducationPostScamType
     */
    omit?: EducationPostScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationPostScamTypeInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    orgName: string | null
    category: $Enums.ContactCategory | null
    description: string | null
    website: string | null
    phone: string | null
    email: string | null
    submitUrl: string | null
    country: string | null
    region: string | null
    city: string | null
    status: $Enums.ContactStatus | null
    verified: boolean | null
    source: string | null
    lastVerifiedAt: Date | null
    createdById: string | null
  }

  export type ContactMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    orgName: string | null
    category: $Enums.ContactCategory | null
    description: string | null
    website: string | null
    phone: string | null
    email: string | null
    submitUrl: string | null
    country: string | null
    region: string | null
    city: string | null
    status: $Enums.ContactStatus | null
    verified: boolean | null
    source: string | null
    lastVerifiedAt: Date | null
    createdById: string | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    orgName: number
    category: number
    description: number
    website: number
    phone: number
    email: number
    submitUrl: number
    languageCodes: number
    country: number
    region: number
    city: number
    status: number
    verified: number
    source: number
    lastVerifiedAt: number
    createdById: number
    _all: number
  }


  export type ContactMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    orgName?: true
    category?: true
    description?: true
    website?: true
    phone?: true
    email?: true
    submitUrl?: true
    country?: true
    region?: true
    city?: true
    status?: true
    verified?: true
    source?: true
    lastVerifiedAt?: true
    createdById?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    orgName?: true
    category?: true
    description?: true
    website?: true
    phone?: true
    email?: true
    submitUrl?: true
    country?: true
    region?: true
    city?: true
    status?: true
    verified?: true
    source?: true
    lastVerifiedAt?: true
    createdById?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    orgName?: true
    category?: true
    description?: true
    website?: true
    phone?: true
    email?: true
    submitUrl?: true
    languageCodes?: true
    country?: true
    region?: true
    city?: true
    status?: true
    verified?: true
    source?: true
    lastVerifiedAt?: true
    createdById?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    orgName: string
    category: $Enums.ContactCategory
    description: string | null
    website: string | null
    phone: string | null
    email: string | null
    submitUrl: string | null
    languageCodes: string[]
    country: string | null
    region: string | null
    city: string | null
    status: $Enums.ContactStatus
    verified: boolean
    source: string | null
    lastVerifiedAt: Date | null
    createdById: string | null
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orgName?: boolean
    category?: boolean
    description?: boolean
    website?: boolean
    phone?: boolean
    email?: boolean
    submitUrl?: boolean
    languageCodes?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    status?: boolean
    verified?: boolean
    source?: boolean
    lastVerifiedAt?: boolean
    createdById?: boolean
    scamTypes?: boolean | Contact$scamTypesArgs<ExtArgs>
    tags?: boolean | Contact$tagsArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orgName?: boolean
    category?: boolean
    description?: boolean
    website?: boolean
    phone?: boolean
    email?: boolean
    submitUrl?: boolean
    languageCodes?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    status?: boolean
    verified?: boolean
    source?: boolean
    lastVerifiedAt?: boolean
    createdById?: boolean
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orgName?: boolean
    category?: boolean
    description?: boolean
    website?: boolean
    phone?: boolean
    email?: boolean
    submitUrl?: boolean
    languageCodes?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    status?: boolean
    verified?: boolean
    source?: boolean
    lastVerifiedAt?: boolean
    createdById?: boolean
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orgName?: boolean
    category?: boolean
    description?: boolean
    website?: boolean
    phone?: boolean
    email?: boolean
    submitUrl?: boolean
    languageCodes?: boolean
    country?: boolean
    region?: boolean
    city?: boolean
    status?: boolean
    verified?: boolean
    source?: boolean
    lastVerifiedAt?: boolean
    createdById?: boolean
  }

  export type ContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "orgName" | "category" | "description" | "website" | "phone" | "email" | "submitUrl" | "languageCodes" | "country" | "region" | "city" | "status" | "verified" | "source" | "lastVerifiedAt" | "createdById", ExtArgs["result"]["contact"]>
  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scamTypes?: boolean | Contact$scamTypesArgs<ExtArgs>
    tags?: boolean | Contact$tagsArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      scamTypes: Prisma.$ContactScamTypePayload<ExtArgs>[]
      tags: Prisma.$ContactTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      orgName: string
      category: $Enums.ContactCategory
      description: string | null
      website: string | null
      phone: string | null
      email: string | null
      submitUrl: string | null
      languageCodes: string[]
      country: string | null
      region: string | null
      city: string | null
      status: $Enums.ContactStatus
      verified: boolean
      source: string | null
      lastVerifiedAt: Date | null
      createdById: string | null
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts and returns the data updated in the database.
     * @param {ContactUpdateManyAndReturnArgs} args - Arguments to update many Contacts.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    scamTypes<T extends Contact$scamTypesArgs<ExtArgs> = {}>(args?: Subset<T, Contact$scamTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactScamTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Contact$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'String'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
    readonly updatedAt: FieldRef<"Contact", 'DateTime'>
    readonly orgName: FieldRef<"Contact", 'String'>
    readonly category: FieldRef<"Contact", 'ContactCategory'>
    readonly description: FieldRef<"Contact", 'String'>
    readonly website: FieldRef<"Contact", 'String'>
    readonly phone: FieldRef<"Contact", 'String'>
    readonly email: FieldRef<"Contact", 'String'>
    readonly submitUrl: FieldRef<"Contact", 'String'>
    readonly languageCodes: FieldRef<"Contact", 'String[]'>
    readonly country: FieldRef<"Contact", 'String'>
    readonly region: FieldRef<"Contact", 'String'>
    readonly city: FieldRef<"Contact", 'String'>
    readonly status: FieldRef<"Contact", 'ContactStatus'>
    readonly verified: FieldRef<"Contact", 'Boolean'>
    readonly source: FieldRef<"Contact", 'String'>
    readonly lastVerifiedAt: FieldRef<"Contact", 'DateTime'>
    readonly createdById: FieldRef<"Contact", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact createManyAndReturn
   */
  export type ContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contact updateManyAndReturn
   */
  export type ContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to delete.
     */
    limit?: number
  }

  /**
   * Contact.scamTypes
   */
  export type Contact$scamTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactScamType
     */
    select?: ContactScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactScamType
     */
    omit?: ContactScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactScamTypeInclude<ExtArgs> | null
    where?: ContactScamTypeWhereInput
    orderBy?: ContactScamTypeOrderByWithRelationInput | ContactScamTypeOrderByWithRelationInput[]
    cursor?: ContactScamTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScamTypeScalarFieldEnum | ContactScamTypeScalarFieldEnum[]
  }

  /**
   * Contact.tags
   */
  export type Contact$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
    where?: ContactTagWhereInput
    orderBy?: ContactTagOrderByWithRelationInput | ContactTagOrderByWithRelationInput[]
    cursor?: ContactTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactTagScalarFieldEnum | ContactTagScalarFieldEnum[]
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model ContactScamType
   */

  export type AggregateContactScamType = {
    _count: ContactScamTypeCountAggregateOutputType | null
    _min: ContactScamTypeMinAggregateOutputType | null
    _max: ContactScamTypeMaxAggregateOutputType | null
  }

  export type ContactScamTypeMinAggregateOutputType = {
    contactId: string | null
    scamTypeId: string | null
  }

  export type ContactScamTypeMaxAggregateOutputType = {
    contactId: string | null
    scamTypeId: string | null
  }

  export type ContactScamTypeCountAggregateOutputType = {
    contactId: number
    scamTypeId: number
    _all: number
  }


  export type ContactScamTypeMinAggregateInputType = {
    contactId?: true
    scamTypeId?: true
  }

  export type ContactScamTypeMaxAggregateInputType = {
    contactId?: true
    scamTypeId?: true
  }

  export type ContactScamTypeCountAggregateInputType = {
    contactId?: true
    scamTypeId?: true
    _all?: true
  }

  export type ContactScamTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactScamType to aggregate.
     */
    where?: ContactScamTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactScamTypes to fetch.
     */
    orderBy?: ContactScamTypeOrderByWithRelationInput | ContactScamTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactScamTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactScamTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactScamTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactScamTypes
    **/
    _count?: true | ContactScamTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactScamTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactScamTypeMaxAggregateInputType
  }

  export type GetContactScamTypeAggregateType<T extends ContactScamTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateContactScamType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactScamType[P]>
      : GetScalarType<T[P], AggregateContactScamType[P]>
  }




  export type ContactScamTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactScamTypeWhereInput
    orderBy?: ContactScamTypeOrderByWithAggregationInput | ContactScamTypeOrderByWithAggregationInput[]
    by: ContactScamTypeScalarFieldEnum[] | ContactScamTypeScalarFieldEnum
    having?: ContactScamTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactScamTypeCountAggregateInputType | true
    _min?: ContactScamTypeMinAggregateInputType
    _max?: ContactScamTypeMaxAggregateInputType
  }

  export type ContactScamTypeGroupByOutputType = {
    contactId: string
    scamTypeId: string
    _count: ContactScamTypeCountAggregateOutputType | null
    _min: ContactScamTypeMinAggregateOutputType | null
    _max: ContactScamTypeMaxAggregateOutputType | null
  }

  type GetContactScamTypeGroupByPayload<T extends ContactScamTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactScamTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactScamTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactScamTypeGroupByOutputType[P]>
            : GetScalarType<T[P], ContactScamTypeGroupByOutputType[P]>
        }
      >
    >


  export type ContactScamTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contactId?: boolean
    scamTypeId?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    scamType?: boolean | ScamTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactScamType"]>

  export type ContactScamTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contactId?: boolean
    scamTypeId?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    scamType?: boolean | ScamTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactScamType"]>

  export type ContactScamTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contactId?: boolean
    scamTypeId?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    scamType?: boolean | ScamTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactScamType"]>

  export type ContactScamTypeSelectScalar = {
    contactId?: boolean
    scamTypeId?: boolean
  }

  export type ContactScamTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"contactId" | "scamTypeId", ExtArgs["result"]["contactScamType"]>
  export type ContactScamTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    scamType?: boolean | ScamTypeDefaultArgs<ExtArgs>
  }
  export type ContactScamTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    scamType?: boolean | ScamTypeDefaultArgs<ExtArgs>
  }
  export type ContactScamTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    scamType?: boolean | ScamTypeDefaultArgs<ExtArgs>
  }

  export type $ContactScamTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactScamType"
    objects: {
      contact: Prisma.$ContactPayload<ExtArgs>
      scamType: Prisma.$ScamTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      contactId: string
      scamTypeId: string
    }, ExtArgs["result"]["contactScamType"]>
    composites: {}
  }

  type ContactScamTypeGetPayload<S extends boolean | null | undefined | ContactScamTypeDefaultArgs> = $Result.GetResult<Prisma.$ContactScamTypePayload, S>

  type ContactScamTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactScamTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactScamTypeCountAggregateInputType | true
    }

  export interface ContactScamTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactScamType'], meta: { name: 'ContactScamType' } }
    /**
     * Find zero or one ContactScamType that matches the filter.
     * @param {ContactScamTypeFindUniqueArgs} args - Arguments to find a ContactScamType
     * @example
     * // Get one ContactScamType
     * const contactScamType = await prisma.contactScamType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactScamTypeFindUniqueArgs>(args: SelectSubset<T, ContactScamTypeFindUniqueArgs<ExtArgs>>): Prisma__ContactScamTypeClient<$Result.GetResult<Prisma.$ContactScamTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactScamType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactScamTypeFindUniqueOrThrowArgs} args - Arguments to find a ContactScamType
     * @example
     * // Get one ContactScamType
     * const contactScamType = await prisma.contactScamType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactScamTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactScamTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactScamTypeClient<$Result.GetResult<Prisma.$ContactScamTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactScamType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactScamTypeFindFirstArgs} args - Arguments to find a ContactScamType
     * @example
     * // Get one ContactScamType
     * const contactScamType = await prisma.contactScamType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactScamTypeFindFirstArgs>(args?: SelectSubset<T, ContactScamTypeFindFirstArgs<ExtArgs>>): Prisma__ContactScamTypeClient<$Result.GetResult<Prisma.$ContactScamTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactScamType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactScamTypeFindFirstOrThrowArgs} args - Arguments to find a ContactScamType
     * @example
     * // Get one ContactScamType
     * const contactScamType = await prisma.contactScamType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactScamTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactScamTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactScamTypeClient<$Result.GetResult<Prisma.$ContactScamTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactScamTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactScamTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactScamTypes
     * const contactScamTypes = await prisma.contactScamType.findMany()
     * 
     * // Get first 10 ContactScamTypes
     * const contactScamTypes = await prisma.contactScamType.findMany({ take: 10 })
     * 
     * // Only select the `contactId`
     * const contactScamTypeWithContactIdOnly = await prisma.contactScamType.findMany({ select: { contactId: true } })
     * 
     */
    findMany<T extends ContactScamTypeFindManyArgs>(args?: SelectSubset<T, ContactScamTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactScamTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactScamType.
     * @param {ContactScamTypeCreateArgs} args - Arguments to create a ContactScamType.
     * @example
     * // Create one ContactScamType
     * const ContactScamType = await prisma.contactScamType.create({
     *   data: {
     *     // ... data to create a ContactScamType
     *   }
     * })
     * 
     */
    create<T extends ContactScamTypeCreateArgs>(args: SelectSubset<T, ContactScamTypeCreateArgs<ExtArgs>>): Prisma__ContactScamTypeClient<$Result.GetResult<Prisma.$ContactScamTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactScamTypes.
     * @param {ContactScamTypeCreateManyArgs} args - Arguments to create many ContactScamTypes.
     * @example
     * // Create many ContactScamTypes
     * const contactScamType = await prisma.contactScamType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactScamTypeCreateManyArgs>(args?: SelectSubset<T, ContactScamTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactScamTypes and returns the data saved in the database.
     * @param {ContactScamTypeCreateManyAndReturnArgs} args - Arguments to create many ContactScamTypes.
     * @example
     * // Create many ContactScamTypes
     * const contactScamType = await prisma.contactScamType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactScamTypes and only return the `contactId`
     * const contactScamTypeWithContactIdOnly = await prisma.contactScamType.createManyAndReturn({
     *   select: { contactId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactScamTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactScamTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactScamTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContactScamType.
     * @param {ContactScamTypeDeleteArgs} args - Arguments to delete one ContactScamType.
     * @example
     * // Delete one ContactScamType
     * const ContactScamType = await prisma.contactScamType.delete({
     *   where: {
     *     // ... filter to delete one ContactScamType
     *   }
     * })
     * 
     */
    delete<T extends ContactScamTypeDeleteArgs>(args: SelectSubset<T, ContactScamTypeDeleteArgs<ExtArgs>>): Prisma__ContactScamTypeClient<$Result.GetResult<Prisma.$ContactScamTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactScamType.
     * @param {ContactScamTypeUpdateArgs} args - Arguments to update one ContactScamType.
     * @example
     * // Update one ContactScamType
     * const contactScamType = await prisma.contactScamType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactScamTypeUpdateArgs>(args: SelectSubset<T, ContactScamTypeUpdateArgs<ExtArgs>>): Prisma__ContactScamTypeClient<$Result.GetResult<Prisma.$ContactScamTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactScamTypes.
     * @param {ContactScamTypeDeleteManyArgs} args - Arguments to filter ContactScamTypes to delete.
     * @example
     * // Delete a few ContactScamTypes
     * const { count } = await prisma.contactScamType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactScamTypeDeleteManyArgs>(args?: SelectSubset<T, ContactScamTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactScamTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactScamTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactScamTypes
     * const contactScamType = await prisma.contactScamType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactScamTypeUpdateManyArgs>(args: SelectSubset<T, ContactScamTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactScamTypes and returns the data updated in the database.
     * @param {ContactScamTypeUpdateManyAndReturnArgs} args - Arguments to update many ContactScamTypes.
     * @example
     * // Update many ContactScamTypes
     * const contactScamType = await prisma.contactScamType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContactScamTypes and only return the `contactId`
     * const contactScamTypeWithContactIdOnly = await prisma.contactScamType.updateManyAndReturn({
     *   select: { contactId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactScamTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactScamTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactScamTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContactScamType.
     * @param {ContactScamTypeUpsertArgs} args - Arguments to update or create a ContactScamType.
     * @example
     * // Update or create a ContactScamType
     * const contactScamType = await prisma.contactScamType.upsert({
     *   create: {
     *     // ... data to create a ContactScamType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactScamType we want to update
     *   }
     * })
     */
    upsert<T extends ContactScamTypeUpsertArgs>(args: SelectSubset<T, ContactScamTypeUpsertArgs<ExtArgs>>): Prisma__ContactScamTypeClient<$Result.GetResult<Prisma.$ContactScamTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContactScamTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactScamTypeCountArgs} args - Arguments to filter ContactScamTypes to count.
     * @example
     * // Count the number of ContactScamTypes
     * const count = await prisma.contactScamType.count({
     *   where: {
     *     // ... the filter for the ContactScamTypes we want to count
     *   }
     * })
    **/
    count<T extends ContactScamTypeCountArgs>(
      args?: Subset<T, ContactScamTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactScamTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactScamType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactScamTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactScamTypeAggregateArgs>(args: Subset<T, ContactScamTypeAggregateArgs>): Prisma.PrismaPromise<GetContactScamTypeAggregateType<T>>

    /**
     * Group by ContactScamType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactScamTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactScamTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactScamTypeGroupByArgs['orderBy'] }
        : { orderBy?: ContactScamTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactScamTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactScamTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactScamType model
   */
  readonly fields: ContactScamTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactScamType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactScamTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    scamType<T extends ScamTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ScamTypeDefaultArgs<ExtArgs>>): Prisma__ScamTypeClient<$Result.GetResult<Prisma.$ScamTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactScamType model
   */
  interface ContactScamTypeFieldRefs {
    readonly contactId: FieldRef<"ContactScamType", 'String'>
    readonly scamTypeId: FieldRef<"ContactScamType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ContactScamType findUnique
   */
  export type ContactScamTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactScamType
     */
    select?: ContactScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactScamType
     */
    omit?: ContactScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactScamTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContactScamType to fetch.
     */
    where: ContactScamTypeWhereUniqueInput
  }

  /**
   * ContactScamType findUniqueOrThrow
   */
  export type ContactScamTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactScamType
     */
    select?: ContactScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactScamType
     */
    omit?: ContactScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactScamTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContactScamType to fetch.
     */
    where: ContactScamTypeWhereUniqueInput
  }

  /**
   * ContactScamType findFirst
   */
  export type ContactScamTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactScamType
     */
    select?: ContactScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactScamType
     */
    omit?: ContactScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactScamTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContactScamType to fetch.
     */
    where?: ContactScamTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactScamTypes to fetch.
     */
    orderBy?: ContactScamTypeOrderByWithRelationInput | ContactScamTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactScamTypes.
     */
    cursor?: ContactScamTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactScamTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactScamTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactScamTypes.
     */
    distinct?: ContactScamTypeScalarFieldEnum | ContactScamTypeScalarFieldEnum[]
  }

  /**
   * ContactScamType findFirstOrThrow
   */
  export type ContactScamTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactScamType
     */
    select?: ContactScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactScamType
     */
    omit?: ContactScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactScamTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContactScamType to fetch.
     */
    where?: ContactScamTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactScamTypes to fetch.
     */
    orderBy?: ContactScamTypeOrderByWithRelationInput | ContactScamTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactScamTypes.
     */
    cursor?: ContactScamTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactScamTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactScamTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactScamTypes.
     */
    distinct?: ContactScamTypeScalarFieldEnum | ContactScamTypeScalarFieldEnum[]
  }

  /**
   * ContactScamType findMany
   */
  export type ContactScamTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactScamType
     */
    select?: ContactScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactScamType
     */
    omit?: ContactScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactScamTypeInclude<ExtArgs> | null
    /**
     * Filter, which ContactScamTypes to fetch.
     */
    where?: ContactScamTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactScamTypes to fetch.
     */
    orderBy?: ContactScamTypeOrderByWithRelationInput | ContactScamTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactScamTypes.
     */
    cursor?: ContactScamTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactScamTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactScamTypes.
     */
    skip?: number
    distinct?: ContactScamTypeScalarFieldEnum | ContactScamTypeScalarFieldEnum[]
  }

  /**
   * ContactScamType create
   */
  export type ContactScamTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactScamType
     */
    select?: ContactScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactScamType
     */
    omit?: ContactScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactScamTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactScamType.
     */
    data: XOR<ContactScamTypeCreateInput, ContactScamTypeUncheckedCreateInput>
  }

  /**
   * ContactScamType createMany
   */
  export type ContactScamTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactScamTypes.
     */
    data: ContactScamTypeCreateManyInput | ContactScamTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactScamType createManyAndReturn
   */
  export type ContactScamTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactScamType
     */
    select?: ContactScamTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactScamType
     */
    omit?: ContactScamTypeOmit<ExtArgs> | null
    /**
     * The data used to create many ContactScamTypes.
     */
    data: ContactScamTypeCreateManyInput | ContactScamTypeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactScamTypeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactScamType update
   */
  export type ContactScamTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactScamType
     */
    select?: ContactScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactScamType
     */
    omit?: ContactScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactScamTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactScamType.
     */
    data: XOR<ContactScamTypeUpdateInput, ContactScamTypeUncheckedUpdateInput>
    /**
     * Choose, which ContactScamType to update.
     */
    where: ContactScamTypeWhereUniqueInput
  }

  /**
   * ContactScamType updateMany
   */
  export type ContactScamTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactScamTypes.
     */
    data: XOR<ContactScamTypeUpdateManyMutationInput, ContactScamTypeUncheckedUpdateManyInput>
    /**
     * Filter which ContactScamTypes to update
     */
    where?: ContactScamTypeWhereInput
    /**
     * Limit how many ContactScamTypes to update.
     */
    limit?: number
  }

  /**
   * ContactScamType updateManyAndReturn
   */
  export type ContactScamTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactScamType
     */
    select?: ContactScamTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactScamType
     */
    omit?: ContactScamTypeOmit<ExtArgs> | null
    /**
     * The data used to update ContactScamTypes.
     */
    data: XOR<ContactScamTypeUpdateManyMutationInput, ContactScamTypeUncheckedUpdateManyInput>
    /**
     * Filter which ContactScamTypes to update
     */
    where?: ContactScamTypeWhereInput
    /**
     * Limit how many ContactScamTypes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactScamTypeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactScamType upsert
   */
  export type ContactScamTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactScamType
     */
    select?: ContactScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactScamType
     */
    omit?: ContactScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactScamTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactScamType to update in case it exists.
     */
    where: ContactScamTypeWhereUniqueInput
    /**
     * In case the ContactScamType found by the `where` argument doesn't exist, create a new ContactScamType with this data.
     */
    create: XOR<ContactScamTypeCreateInput, ContactScamTypeUncheckedCreateInput>
    /**
     * In case the ContactScamType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactScamTypeUpdateInput, ContactScamTypeUncheckedUpdateInput>
  }

  /**
   * ContactScamType delete
   */
  export type ContactScamTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactScamType
     */
    select?: ContactScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactScamType
     */
    omit?: ContactScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactScamTypeInclude<ExtArgs> | null
    /**
     * Filter which ContactScamType to delete.
     */
    where: ContactScamTypeWhereUniqueInput
  }

  /**
   * ContactScamType deleteMany
   */
  export type ContactScamTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactScamTypes to delete
     */
    where?: ContactScamTypeWhereInput
    /**
     * Limit how many ContactScamTypes to delete.
     */
    limit?: number
  }

  /**
   * ContactScamType without action
   */
  export type ContactScamTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactScamType
     */
    select?: ContactScamTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactScamType
     */
    omit?: ContactScamTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactScamTypeInclude<ExtArgs> | null
  }


  /**
   * Model ContactTag
   */

  export type AggregateContactTag = {
    _count: ContactTagCountAggregateOutputType | null
    _min: ContactTagMinAggregateOutputType | null
    _max: ContactTagMaxAggregateOutputType | null
  }

  export type ContactTagMinAggregateOutputType = {
    contactId: string | null
    tagId: string | null
  }

  export type ContactTagMaxAggregateOutputType = {
    contactId: string | null
    tagId: string | null
  }

  export type ContactTagCountAggregateOutputType = {
    contactId: number
    tagId: number
    _all: number
  }


  export type ContactTagMinAggregateInputType = {
    contactId?: true
    tagId?: true
  }

  export type ContactTagMaxAggregateInputType = {
    contactId?: true
    tagId?: true
  }

  export type ContactTagCountAggregateInputType = {
    contactId?: true
    tagId?: true
    _all?: true
  }

  export type ContactTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactTag to aggregate.
     */
    where?: ContactTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactTags to fetch.
     */
    orderBy?: ContactTagOrderByWithRelationInput | ContactTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactTags
    **/
    _count?: true | ContactTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactTagMaxAggregateInputType
  }

  export type GetContactTagAggregateType<T extends ContactTagAggregateArgs> = {
        [P in keyof T & keyof AggregateContactTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactTag[P]>
      : GetScalarType<T[P], AggregateContactTag[P]>
  }




  export type ContactTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactTagWhereInput
    orderBy?: ContactTagOrderByWithAggregationInput | ContactTagOrderByWithAggregationInput[]
    by: ContactTagScalarFieldEnum[] | ContactTagScalarFieldEnum
    having?: ContactTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactTagCountAggregateInputType | true
    _min?: ContactTagMinAggregateInputType
    _max?: ContactTagMaxAggregateInputType
  }

  export type ContactTagGroupByOutputType = {
    contactId: string
    tagId: string
    _count: ContactTagCountAggregateOutputType | null
    _min: ContactTagMinAggregateOutputType | null
    _max: ContactTagMaxAggregateOutputType | null
  }

  type GetContactTagGroupByPayload<T extends ContactTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactTagGroupByOutputType[P]>
            : GetScalarType<T[P], ContactTagGroupByOutputType[P]>
        }
      >
    >


  export type ContactTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contactId?: boolean
    tagId?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactTag"]>

  export type ContactTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contactId?: boolean
    tagId?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactTag"]>

  export type ContactTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    contactId?: boolean
    tagId?: boolean
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactTag"]>

  export type ContactTagSelectScalar = {
    contactId?: boolean
    tagId?: boolean
  }

  export type ContactTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"contactId" | "tagId", ExtArgs["result"]["contactTag"]>
  export type ContactTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type ContactTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type ContactTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $ContactTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactTag"
    objects: {
      contact: Prisma.$ContactPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      contactId: string
      tagId: string
    }, ExtArgs["result"]["contactTag"]>
    composites: {}
  }

  type ContactTagGetPayload<S extends boolean | null | undefined | ContactTagDefaultArgs> = $Result.GetResult<Prisma.$ContactTagPayload, S>

  type ContactTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactTagCountAggregateInputType | true
    }

  export interface ContactTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactTag'], meta: { name: 'ContactTag' } }
    /**
     * Find zero or one ContactTag that matches the filter.
     * @param {ContactTagFindUniqueArgs} args - Arguments to find a ContactTag
     * @example
     * // Get one ContactTag
     * const contactTag = await prisma.contactTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactTagFindUniqueArgs>(args: SelectSubset<T, ContactTagFindUniqueArgs<ExtArgs>>): Prisma__ContactTagClient<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactTagFindUniqueOrThrowArgs} args - Arguments to find a ContactTag
     * @example
     * // Get one ContactTag
     * const contactTag = await prisma.contactTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactTagFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactTagClient<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTagFindFirstArgs} args - Arguments to find a ContactTag
     * @example
     * // Get one ContactTag
     * const contactTag = await prisma.contactTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactTagFindFirstArgs>(args?: SelectSubset<T, ContactTagFindFirstArgs<ExtArgs>>): Prisma__ContactTagClient<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTagFindFirstOrThrowArgs} args - Arguments to find a ContactTag
     * @example
     * // Get one ContactTag
     * const contactTag = await prisma.contactTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactTagFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactTagClient<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactTags
     * const contactTags = await prisma.contactTag.findMany()
     * 
     * // Get first 10 ContactTags
     * const contactTags = await prisma.contactTag.findMany({ take: 10 })
     * 
     * // Only select the `contactId`
     * const contactTagWithContactIdOnly = await prisma.contactTag.findMany({ select: { contactId: true } })
     * 
     */
    findMany<T extends ContactTagFindManyArgs>(args?: SelectSubset<T, ContactTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactTag.
     * @param {ContactTagCreateArgs} args - Arguments to create a ContactTag.
     * @example
     * // Create one ContactTag
     * const ContactTag = await prisma.contactTag.create({
     *   data: {
     *     // ... data to create a ContactTag
     *   }
     * })
     * 
     */
    create<T extends ContactTagCreateArgs>(args: SelectSubset<T, ContactTagCreateArgs<ExtArgs>>): Prisma__ContactTagClient<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactTags.
     * @param {ContactTagCreateManyArgs} args - Arguments to create many ContactTags.
     * @example
     * // Create many ContactTags
     * const contactTag = await prisma.contactTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactTagCreateManyArgs>(args?: SelectSubset<T, ContactTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactTags and returns the data saved in the database.
     * @param {ContactTagCreateManyAndReturnArgs} args - Arguments to create many ContactTags.
     * @example
     * // Create many ContactTags
     * const contactTag = await prisma.contactTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactTags and only return the `contactId`
     * const contactTagWithContactIdOnly = await prisma.contactTag.createManyAndReturn({
     *   select: { contactId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactTagCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContactTag.
     * @param {ContactTagDeleteArgs} args - Arguments to delete one ContactTag.
     * @example
     * // Delete one ContactTag
     * const ContactTag = await prisma.contactTag.delete({
     *   where: {
     *     // ... filter to delete one ContactTag
     *   }
     * })
     * 
     */
    delete<T extends ContactTagDeleteArgs>(args: SelectSubset<T, ContactTagDeleteArgs<ExtArgs>>): Prisma__ContactTagClient<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactTag.
     * @param {ContactTagUpdateArgs} args - Arguments to update one ContactTag.
     * @example
     * // Update one ContactTag
     * const contactTag = await prisma.contactTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactTagUpdateArgs>(args: SelectSubset<T, ContactTagUpdateArgs<ExtArgs>>): Prisma__ContactTagClient<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactTags.
     * @param {ContactTagDeleteManyArgs} args - Arguments to filter ContactTags to delete.
     * @example
     * // Delete a few ContactTags
     * const { count } = await prisma.contactTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactTagDeleteManyArgs>(args?: SelectSubset<T, ContactTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactTags
     * const contactTag = await prisma.contactTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactTagUpdateManyArgs>(args: SelectSubset<T, ContactTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactTags and returns the data updated in the database.
     * @param {ContactTagUpdateManyAndReturnArgs} args - Arguments to update many ContactTags.
     * @example
     * // Update many ContactTags
     * const contactTag = await prisma.contactTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContactTags and only return the `contactId`
     * const contactTagWithContactIdOnly = await prisma.contactTag.updateManyAndReturn({
     *   select: { contactId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactTagUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContactTag.
     * @param {ContactTagUpsertArgs} args - Arguments to update or create a ContactTag.
     * @example
     * // Update or create a ContactTag
     * const contactTag = await prisma.contactTag.upsert({
     *   create: {
     *     // ... data to create a ContactTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactTag we want to update
     *   }
     * })
     */
    upsert<T extends ContactTagUpsertArgs>(args: SelectSubset<T, ContactTagUpsertArgs<ExtArgs>>): Prisma__ContactTagClient<$Result.GetResult<Prisma.$ContactTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContactTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTagCountArgs} args - Arguments to filter ContactTags to count.
     * @example
     * // Count the number of ContactTags
     * const count = await prisma.contactTag.count({
     *   where: {
     *     // ... the filter for the ContactTags we want to count
     *   }
     * })
    **/
    count<T extends ContactTagCountArgs>(
      args?: Subset<T, ContactTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactTagAggregateArgs>(args: Subset<T, ContactTagAggregateArgs>): Prisma.PrismaPromise<GetContactTagAggregateType<T>>

    /**
     * Group by ContactTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactTagGroupByArgs['orderBy'] }
        : { orderBy?: ContactTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactTag model
   */
  readonly fields: ContactTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactTag model
   */
  interface ContactTagFieldRefs {
    readonly contactId: FieldRef<"ContactTag", 'String'>
    readonly tagId: FieldRef<"ContactTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ContactTag findUnique
   */
  export type ContactTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
    /**
     * Filter, which ContactTag to fetch.
     */
    where: ContactTagWhereUniqueInput
  }

  /**
   * ContactTag findUniqueOrThrow
   */
  export type ContactTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
    /**
     * Filter, which ContactTag to fetch.
     */
    where: ContactTagWhereUniqueInput
  }

  /**
   * ContactTag findFirst
   */
  export type ContactTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
    /**
     * Filter, which ContactTag to fetch.
     */
    where?: ContactTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactTags to fetch.
     */
    orderBy?: ContactTagOrderByWithRelationInput | ContactTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactTags.
     */
    cursor?: ContactTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactTags.
     */
    distinct?: ContactTagScalarFieldEnum | ContactTagScalarFieldEnum[]
  }

  /**
   * ContactTag findFirstOrThrow
   */
  export type ContactTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
    /**
     * Filter, which ContactTag to fetch.
     */
    where?: ContactTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactTags to fetch.
     */
    orderBy?: ContactTagOrderByWithRelationInput | ContactTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactTags.
     */
    cursor?: ContactTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactTags.
     */
    distinct?: ContactTagScalarFieldEnum | ContactTagScalarFieldEnum[]
  }

  /**
   * ContactTag findMany
   */
  export type ContactTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
    /**
     * Filter, which ContactTags to fetch.
     */
    where?: ContactTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactTags to fetch.
     */
    orderBy?: ContactTagOrderByWithRelationInput | ContactTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactTags.
     */
    cursor?: ContactTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactTags.
     */
    skip?: number
    distinct?: ContactTagScalarFieldEnum | ContactTagScalarFieldEnum[]
  }

  /**
   * ContactTag create
   */
  export type ContactTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactTag.
     */
    data: XOR<ContactTagCreateInput, ContactTagUncheckedCreateInput>
  }

  /**
   * ContactTag createMany
   */
  export type ContactTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactTags.
     */
    data: ContactTagCreateManyInput | ContactTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactTag createManyAndReturn
   */
  export type ContactTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * The data used to create many ContactTags.
     */
    data: ContactTagCreateManyInput | ContactTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactTag update
   */
  export type ContactTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactTag.
     */
    data: XOR<ContactTagUpdateInput, ContactTagUncheckedUpdateInput>
    /**
     * Choose, which ContactTag to update.
     */
    where: ContactTagWhereUniqueInput
  }

  /**
   * ContactTag updateMany
   */
  export type ContactTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactTags.
     */
    data: XOR<ContactTagUpdateManyMutationInput, ContactTagUncheckedUpdateManyInput>
    /**
     * Filter which ContactTags to update
     */
    where?: ContactTagWhereInput
    /**
     * Limit how many ContactTags to update.
     */
    limit?: number
  }

  /**
   * ContactTag updateManyAndReturn
   */
  export type ContactTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * The data used to update ContactTags.
     */
    data: XOR<ContactTagUpdateManyMutationInput, ContactTagUncheckedUpdateManyInput>
    /**
     * Filter which ContactTags to update
     */
    where?: ContactTagWhereInput
    /**
     * Limit how many ContactTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactTag upsert
   */
  export type ContactTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactTag to update in case it exists.
     */
    where: ContactTagWhereUniqueInput
    /**
     * In case the ContactTag found by the `where` argument doesn't exist, create a new ContactTag with this data.
     */
    create: XOR<ContactTagCreateInput, ContactTagUncheckedCreateInput>
    /**
     * In case the ContactTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactTagUpdateInput, ContactTagUncheckedUpdateInput>
  }

  /**
   * ContactTag delete
   */
  export type ContactTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
    /**
     * Filter which ContactTag to delete.
     */
    where: ContactTagWhereUniqueInput
  }

  /**
   * ContactTag deleteMany
   */
  export type ContactTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactTags to delete
     */
    where?: ContactTagWhereInput
    /**
     * Limit how many ContactTags to delete.
     */
    limit?: number
  }

  /**
   * ContactTag without action
   */
  export type ContactTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactTag
     */
    select?: ContactTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactTag
     */
    omit?: ContactTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactTagInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ScamReportScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    description: 'description',
    scammerDetails: 'scammerDetails',
    city: 'city',
    country: 'country',
    region: 'region',
    ipHash: 'ipHash',
    latitude: 'latitude',
    longitude: 'longitude',
    verified: 'verified',
    trustScore: 'trustScore',
    reportCount: 'reportCount',
    reporterName: 'reporterName',
    reporterEmail: 'reporterEmail',
    anonymous: 'anonymous',
    outcome: 'outcome',
    screenshots: 'screenshots',
    evidence: 'evidence',
    scamTypeId: 'scamTypeId',
    source: 'source'
  };

  export type ScamReportScalarFieldEnum = (typeof ScamReportScalarFieldEnum)[keyof typeof ScamReportScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    content: 'content',
    reportId: 'reportId',
    parentId: 'parentId',
    userId: 'userId'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const VoteScalarFieldEnum: {
    id: 'id',
    reportId: 'reportId',
    userId: 'userId',
    voteType: 'voteType'
  };

  export type VoteScalarFieldEnum = (typeof VoteScalarFieldEnum)[keyof typeof VoteScalarFieldEnum]


  export const WikiPageScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    title: 'title',
    slug: 'slug',
    content: 'content',
    category: 'category',
    country: 'country',
    views: 'views',
    featured: 'featured'
  };

  export type WikiPageScalarFieldEnum = (typeof WikiPageScalarFieldEnum)[keyof typeof WikiPageScalarFieldEnum]


  export const SearchCacheScalarFieldEnum: {
    id: 'id',
    query: 'query',
    results: 'results',
    lastUpdated: 'lastUpdated',
    hitCount: 'hitCount'
  };

  export type SearchCacheScalarFieldEnum = (typeof SearchCacheScalarFieldEnum)[keyof typeof SearchCacheScalarFieldEnum]


  export const AIScamReportScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    summary: 'summary',
    averageRiskLevel: 'averageRiskLevel',
    averageFinancialImpact: 'averageFinancialImpact',
    category: 'category'
  };

  export type AIScamReportScalarFieldEnum = (typeof AIScamReportScalarFieldEnum)[keyof typeof AIScamReportScalarFieldEnum]


  export const ScamTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    isApproved: 'isApproved',
    isUserCreated: 'isUserCreated',
    moderatedAt: 'moderatedAt',
    moderatedBy: 'moderatedBy'
  };

  export type ScamTypeScalarFieldEnum = (typeof ScamTypeScalarFieldEnum)[keyof typeof ScamTypeScalarFieldEnum]


  export const SeverityScalarFieldEnum: {
    id: 'id',
    scamTypeId: 'scamTypeId',
    country: 'country',
    region: 'region',
    city: 'city',
    score: 'score',
    level: 'level',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type SeverityScalarFieldEnum = (typeof SeverityScalarFieldEnum)[keyof typeof SeverityScalarFieldEnum]


  export const FlagScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    reportId: 'reportId',
    userId: 'userId',
    reason: 'reason'
  };

  export type FlagScalarFieldEnum = (typeof FlagScalarFieldEnum)[keyof typeof FlagScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    name: 'name',
    image: 'image',
    notificationSettings: 'notificationSettings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    role: 'role'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    data: 'data',
    read: 'read',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const OutcomeTypeScalarFieldEnum: {
    id: 'id',
    value: 'value',
    label: 'label',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OutcomeTypeScalarFieldEnum = (typeof OutcomeTypeScalarFieldEnum)[keyof typeof OutcomeTypeScalarFieldEnum]


  export const EducationPostScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    slug: 'slug',
    title: 'title',
    excerpt: 'excerpt',
    bodyMd: 'bodyMd',
    status: 'status',
    publishedAt: 'publishedAt',
    category: 'category',
    heroImageUrl: 'heroImageUrl',
    heroSvg: 'heroSvg',
    heroAlt: 'heroAlt',
    country: 'country',
    region: 'region',
    city: 'city',
    canonicalUrl: 'canonicalUrl',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    featured: 'featured',
    authorName: 'authorName',
    sourceUrl: 'sourceUrl'
  };

  export type EducationPostScalarFieldEnum = (typeof EducationPostScalarFieldEnum)[keyof typeof EducationPostScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const PostTagScalarFieldEnum: {
    postId: 'postId',
    tagId: 'tagId'
  };

  export type PostTagScalarFieldEnum = (typeof PostTagScalarFieldEnum)[keyof typeof PostTagScalarFieldEnum]


  export const EducationPostScamTypeScalarFieldEnum: {
    postId: 'postId',
    scamTypeId: 'scamTypeId'
  };

  export type EducationPostScamTypeScalarFieldEnum = (typeof EducationPostScamTypeScalarFieldEnum)[keyof typeof EducationPostScamTypeScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    orgName: 'orgName',
    category: 'category',
    description: 'description',
    website: 'website',
    phone: 'phone',
    email: 'email',
    submitUrl: 'submitUrl',
    languageCodes: 'languageCodes',
    country: 'country',
    region: 'region',
    city: 'city',
    status: 'status',
    verified: 'verified',
    source: 'source',
    lastVerifiedAt: 'lastVerifiedAt',
    createdById: 'createdById'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const ContactScamTypeScalarFieldEnum: {
    contactId: 'contactId',
    scamTypeId: 'scamTypeId'
  };

  export type ContactScamTypeScalarFieldEnum = (typeof ContactScamTypeScalarFieldEnum)[keyof typeof ContactScamTypeScalarFieldEnum]


  export const ContactTagScalarFieldEnum: {
    contactId: 'contactId',
    tagId: 'tagId'
  };

  export type ContactTagScalarFieldEnum = (typeof ContactTagScalarFieldEnum)[keyof typeof ContactTagScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'PostStatus'
   */
  export type EnumPostStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostStatus'>
    


  /**
   * Reference to a field of type 'PostStatus[]'
   */
  export type ListEnumPostStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostStatus[]'>
    


  /**
   * Reference to a field of type 'PostCategory'
   */
  export type EnumPostCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostCategory'>
    


  /**
   * Reference to a field of type 'PostCategory[]'
   */
  export type ListEnumPostCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostCategory[]'>
    


  /**
   * Reference to a field of type 'ContactCategory'
   */
  export type EnumContactCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactCategory'>
    


  /**
   * Reference to a field of type 'ContactCategory[]'
   */
  export type ListEnumContactCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactCategory[]'>
    


  /**
   * Reference to a field of type 'ContactStatus'
   */
  export type EnumContactStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactStatus'>
    


  /**
   * Reference to a field of type 'ContactStatus[]'
   */
  export type ListEnumContactStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type ScamReportWhereInput = {
    AND?: ScamReportWhereInput | ScamReportWhereInput[]
    OR?: ScamReportWhereInput[]
    NOT?: ScamReportWhereInput | ScamReportWhereInput[]
    id?: StringFilter<"ScamReport"> | string
    createdAt?: DateTimeFilter<"ScamReport"> | Date | string
    updatedAt?: DateTimeFilter<"ScamReport"> | Date | string
    description?: StringFilter<"ScamReport"> | string
    scammerDetails?: JsonNullableFilter<"ScamReport">
    city?: StringNullableFilter<"ScamReport"> | string | null
    country?: StringNullableFilter<"ScamReport"> | string | null
    region?: StringNullableFilter<"ScamReport"> | string | null
    ipHash?: StringNullableFilter<"ScamReport"> | string | null
    latitude?: FloatNullableFilter<"ScamReport"> | number | null
    longitude?: FloatNullableFilter<"ScamReport"> | number | null
    verified?: BoolFilter<"ScamReport"> | boolean
    trustScore?: IntFilter<"ScamReport"> | number
    reportCount?: IntFilter<"ScamReport"> | number
    reporterName?: StringNullableFilter<"ScamReport"> | string | null
    reporterEmail?: StringNullableFilter<"ScamReport"> | string | null
    anonymous?: BoolFilter<"ScamReport"> | boolean
    outcome?: JsonNullableFilter<"ScamReport">
    screenshots?: StringNullableFilter<"ScamReport"> | string | null
    evidence?: StringNullableFilter<"ScamReport"> | string | null
    scamTypeId?: StringNullableFilter<"ScamReport"> | string | null
    source?: StringNullableFilter<"ScamReport"> | string | null
    comments?: CommentListRelationFilter
    flags?: FlagListRelationFilter
    scamType?: XOR<ScamTypeNullableScalarRelationFilter, ScamTypeWhereInput> | null
    votes?: VoteListRelationFilter
  }

  export type ScamReportOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    scammerDetails?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    ipHash?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    verified?: SortOrder
    trustScore?: SortOrder
    reportCount?: SortOrder
    reporterName?: SortOrderInput | SortOrder
    reporterEmail?: SortOrderInput | SortOrder
    anonymous?: SortOrder
    outcome?: SortOrderInput | SortOrder
    screenshots?: SortOrderInput | SortOrder
    evidence?: SortOrderInput | SortOrder
    scamTypeId?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    comments?: CommentOrderByRelationAggregateInput
    flags?: FlagOrderByRelationAggregateInput
    scamType?: ScamTypeOrderByWithRelationInput
    votes?: VoteOrderByRelationAggregateInput
  }

  export type ScamReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScamReportWhereInput | ScamReportWhereInput[]
    OR?: ScamReportWhereInput[]
    NOT?: ScamReportWhereInput | ScamReportWhereInput[]
    createdAt?: DateTimeFilter<"ScamReport"> | Date | string
    updatedAt?: DateTimeFilter<"ScamReport"> | Date | string
    description?: StringFilter<"ScamReport"> | string
    scammerDetails?: JsonNullableFilter<"ScamReport">
    city?: StringNullableFilter<"ScamReport"> | string | null
    country?: StringNullableFilter<"ScamReport"> | string | null
    region?: StringNullableFilter<"ScamReport"> | string | null
    ipHash?: StringNullableFilter<"ScamReport"> | string | null
    latitude?: FloatNullableFilter<"ScamReport"> | number | null
    longitude?: FloatNullableFilter<"ScamReport"> | number | null
    verified?: BoolFilter<"ScamReport"> | boolean
    trustScore?: IntFilter<"ScamReport"> | number
    reportCount?: IntFilter<"ScamReport"> | number
    reporterName?: StringNullableFilter<"ScamReport"> | string | null
    reporterEmail?: StringNullableFilter<"ScamReport"> | string | null
    anonymous?: BoolFilter<"ScamReport"> | boolean
    outcome?: JsonNullableFilter<"ScamReport">
    screenshots?: StringNullableFilter<"ScamReport"> | string | null
    evidence?: StringNullableFilter<"ScamReport"> | string | null
    scamTypeId?: StringNullableFilter<"ScamReport"> | string | null
    source?: StringNullableFilter<"ScamReport"> | string | null
    comments?: CommentListRelationFilter
    flags?: FlagListRelationFilter
    scamType?: XOR<ScamTypeNullableScalarRelationFilter, ScamTypeWhereInput> | null
    votes?: VoteListRelationFilter
  }, "id">

  export type ScamReportOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    scammerDetails?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    ipHash?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    verified?: SortOrder
    trustScore?: SortOrder
    reportCount?: SortOrder
    reporterName?: SortOrderInput | SortOrder
    reporterEmail?: SortOrderInput | SortOrder
    anonymous?: SortOrder
    outcome?: SortOrderInput | SortOrder
    screenshots?: SortOrderInput | SortOrder
    evidence?: SortOrderInput | SortOrder
    scamTypeId?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    _count?: ScamReportCountOrderByAggregateInput
    _avg?: ScamReportAvgOrderByAggregateInput
    _max?: ScamReportMaxOrderByAggregateInput
    _min?: ScamReportMinOrderByAggregateInput
    _sum?: ScamReportSumOrderByAggregateInput
  }

  export type ScamReportScalarWhereWithAggregatesInput = {
    AND?: ScamReportScalarWhereWithAggregatesInput | ScamReportScalarWhereWithAggregatesInput[]
    OR?: ScamReportScalarWhereWithAggregatesInput[]
    NOT?: ScamReportScalarWhereWithAggregatesInput | ScamReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScamReport"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ScamReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ScamReport"> | Date | string
    description?: StringWithAggregatesFilter<"ScamReport"> | string
    scammerDetails?: JsonNullableWithAggregatesFilter<"ScamReport">
    city?: StringNullableWithAggregatesFilter<"ScamReport"> | string | null
    country?: StringNullableWithAggregatesFilter<"ScamReport"> | string | null
    region?: StringNullableWithAggregatesFilter<"ScamReport"> | string | null
    ipHash?: StringNullableWithAggregatesFilter<"ScamReport"> | string | null
    latitude?: FloatNullableWithAggregatesFilter<"ScamReport"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"ScamReport"> | number | null
    verified?: BoolWithAggregatesFilter<"ScamReport"> | boolean
    trustScore?: IntWithAggregatesFilter<"ScamReport"> | number
    reportCount?: IntWithAggregatesFilter<"ScamReport"> | number
    reporterName?: StringNullableWithAggregatesFilter<"ScamReport"> | string | null
    reporterEmail?: StringNullableWithAggregatesFilter<"ScamReport"> | string | null
    anonymous?: BoolWithAggregatesFilter<"ScamReport"> | boolean
    outcome?: JsonNullableWithAggregatesFilter<"ScamReport">
    screenshots?: StringNullableWithAggregatesFilter<"ScamReport"> | string | null
    evidence?: StringNullableWithAggregatesFilter<"ScamReport"> | string | null
    scamTypeId?: StringNullableWithAggregatesFilter<"ScamReport"> | string | null
    source?: StringNullableWithAggregatesFilter<"ScamReport"> | string | null
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    content?: StringFilter<"Comment"> | string
    reportId?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    userId?: StringNullableFilter<"Comment"> | string | null
    parent?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    replies?: CommentListRelationFilter
    report?: XOR<ScamReportScalarRelationFilter, ScamReportWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    content?: SortOrder
    reportId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    parent?: CommentOrderByWithRelationInput
    replies?: CommentOrderByRelationAggregateInput
    report?: ScamReportOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    content?: StringFilter<"Comment"> | string
    reportId?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    userId?: StringNullableFilter<"Comment"> | string | null
    parent?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    replies?: CommentListRelationFilter
    report?: XOR<ScamReportScalarRelationFilter, ScamReportWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    content?: SortOrder
    reportId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    reportId?: StringWithAggregatesFilter<"Comment"> | string
    parentId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    userId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
  }

  export type VoteWhereInput = {
    AND?: VoteWhereInput | VoteWhereInput[]
    OR?: VoteWhereInput[]
    NOT?: VoteWhereInput | VoteWhereInput[]
    id?: StringFilter<"Vote"> | string
    reportId?: StringFilter<"Vote"> | string
    userId?: StringFilter<"Vote"> | string
    voteType?: StringFilter<"Vote"> | string
    report?: XOR<ScamReportScalarRelationFilter, ScamReportWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type VoteOrderByWithRelationInput = {
    id?: SortOrder
    reportId?: SortOrder
    userId?: SortOrder
    voteType?: SortOrder
    report?: ScamReportOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type VoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    reportId_userId?: VoteReportIdUserIdCompoundUniqueInput
    AND?: VoteWhereInput | VoteWhereInput[]
    OR?: VoteWhereInput[]
    NOT?: VoteWhereInput | VoteWhereInput[]
    reportId?: StringFilter<"Vote"> | string
    userId?: StringFilter<"Vote"> | string
    voteType?: StringFilter<"Vote"> | string
    report?: XOR<ScamReportScalarRelationFilter, ScamReportWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "reportId_userId">

  export type VoteOrderByWithAggregationInput = {
    id?: SortOrder
    reportId?: SortOrder
    userId?: SortOrder
    voteType?: SortOrder
    _count?: VoteCountOrderByAggregateInput
    _max?: VoteMaxOrderByAggregateInput
    _min?: VoteMinOrderByAggregateInput
  }

  export type VoteScalarWhereWithAggregatesInput = {
    AND?: VoteScalarWhereWithAggregatesInput | VoteScalarWhereWithAggregatesInput[]
    OR?: VoteScalarWhereWithAggregatesInput[]
    NOT?: VoteScalarWhereWithAggregatesInput | VoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vote"> | string
    reportId?: StringWithAggregatesFilter<"Vote"> | string
    userId?: StringWithAggregatesFilter<"Vote"> | string
    voteType?: StringWithAggregatesFilter<"Vote"> | string
  }

  export type WikiPageWhereInput = {
    AND?: WikiPageWhereInput | WikiPageWhereInput[]
    OR?: WikiPageWhereInput[]
    NOT?: WikiPageWhereInput | WikiPageWhereInput[]
    id?: StringFilter<"WikiPage"> | string
    createdAt?: DateTimeFilter<"WikiPage"> | Date | string
    updatedAt?: DateTimeFilter<"WikiPage"> | Date | string
    title?: StringFilter<"WikiPage"> | string
    slug?: StringFilter<"WikiPage"> | string
    content?: StringFilter<"WikiPage"> | string
    category?: StringFilter<"WikiPage"> | string
    country?: StringNullableFilter<"WikiPage"> | string | null
    views?: IntFilter<"WikiPage"> | number
    featured?: BoolFilter<"WikiPage"> | boolean
  }

  export type WikiPageOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    category?: SortOrder
    country?: SortOrderInput | SortOrder
    views?: SortOrder
    featured?: SortOrder
  }

  export type WikiPageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    title?: string
    slug?: string
    AND?: WikiPageWhereInput | WikiPageWhereInput[]
    OR?: WikiPageWhereInput[]
    NOT?: WikiPageWhereInput | WikiPageWhereInput[]
    createdAt?: DateTimeFilter<"WikiPage"> | Date | string
    updatedAt?: DateTimeFilter<"WikiPage"> | Date | string
    content?: StringFilter<"WikiPage"> | string
    category?: StringFilter<"WikiPage"> | string
    country?: StringNullableFilter<"WikiPage"> | string | null
    views?: IntFilter<"WikiPage"> | number
    featured?: BoolFilter<"WikiPage"> | boolean
  }, "id" | "title" | "slug">

  export type WikiPageOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    category?: SortOrder
    country?: SortOrderInput | SortOrder
    views?: SortOrder
    featured?: SortOrder
    _count?: WikiPageCountOrderByAggregateInput
    _avg?: WikiPageAvgOrderByAggregateInput
    _max?: WikiPageMaxOrderByAggregateInput
    _min?: WikiPageMinOrderByAggregateInput
    _sum?: WikiPageSumOrderByAggregateInput
  }

  export type WikiPageScalarWhereWithAggregatesInput = {
    AND?: WikiPageScalarWhereWithAggregatesInput | WikiPageScalarWhereWithAggregatesInput[]
    OR?: WikiPageScalarWhereWithAggregatesInput[]
    NOT?: WikiPageScalarWhereWithAggregatesInput | WikiPageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WikiPage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WikiPage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WikiPage"> | Date | string
    title?: StringWithAggregatesFilter<"WikiPage"> | string
    slug?: StringWithAggregatesFilter<"WikiPage"> | string
    content?: StringWithAggregatesFilter<"WikiPage"> | string
    category?: StringWithAggregatesFilter<"WikiPage"> | string
    country?: StringNullableWithAggregatesFilter<"WikiPage"> | string | null
    views?: IntWithAggregatesFilter<"WikiPage"> | number
    featured?: BoolWithAggregatesFilter<"WikiPage"> | boolean
  }

  export type SearchCacheWhereInput = {
    AND?: SearchCacheWhereInput | SearchCacheWhereInput[]
    OR?: SearchCacheWhereInput[]
    NOT?: SearchCacheWhereInput | SearchCacheWhereInput[]
    id?: StringFilter<"SearchCache"> | string
    query?: StringFilter<"SearchCache"> | string
    results?: StringFilter<"SearchCache"> | string
    lastUpdated?: DateTimeFilter<"SearchCache"> | Date | string
    hitCount?: IntFilter<"SearchCache"> | number
  }

  export type SearchCacheOrderByWithRelationInput = {
    id?: SortOrder
    query?: SortOrder
    results?: SortOrder
    lastUpdated?: SortOrder
    hitCount?: SortOrder
  }

  export type SearchCacheWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    query?: string
    AND?: SearchCacheWhereInput | SearchCacheWhereInput[]
    OR?: SearchCacheWhereInput[]
    NOT?: SearchCacheWhereInput | SearchCacheWhereInput[]
    results?: StringFilter<"SearchCache"> | string
    lastUpdated?: DateTimeFilter<"SearchCache"> | Date | string
    hitCount?: IntFilter<"SearchCache"> | number
  }, "id" | "query">

  export type SearchCacheOrderByWithAggregationInput = {
    id?: SortOrder
    query?: SortOrder
    results?: SortOrder
    lastUpdated?: SortOrder
    hitCount?: SortOrder
    _count?: SearchCacheCountOrderByAggregateInput
    _avg?: SearchCacheAvgOrderByAggregateInput
    _max?: SearchCacheMaxOrderByAggregateInput
    _min?: SearchCacheMinOrderByAggregateInput
    _sum?: SearchCacheSumOrderByAggregateInput
  }

  export type SearchCacheScalarWhereWithAggregatesInput = {
    AND?: SearchCacheScalarWhereWithAggregatesInput | SearchCacheScalarWhereWithAggregatesInput[]
    OR?: SearchCacheScalarWhereWithAggregatesInput[]
    NOT?: SearchCacheScalarWhereWithAggregatesInput | SearchCacheScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SearchCache"> | string
    query?: StringWithAggregatesFilter<"SearchCache"> | string
    results?: StringWithAggregatesFilter<"SearchCache"> | string
    lastUpdated?: DateTimeWithAggregatesFilter<"SearchCache"> | Date | string
    hitCount?: IntWithAggregatesFilter<"SearchCache"> | number
  }

  export type AIScamReportWhereInput = {
    AND?: AIScamReportWhereInput | AIScamReportWhereInput[]
    OR?: AIScamReportWhereInput[]
    NOT?: AIScamReportWhereInput | AIScamReportWhereInput[]
    id?: StringFilter<"AIScamReport"> | string
    createdAt?: DateTimeFilter<"AIScamReport"> | Date | string
    updatedAt?: DateTimeFilter<"AIScamReport"> | Date | string
    summary?: StringFilter<"AIScamReport"> | string
    averageRiskLevel?: StringFilter<"AIScamReport"> | string
    averageFinancialImpact?: FloatFilter<"AIScamReport"> | number
    category?: StringFilter<"AIScamReport"> | string
  }

  export type AIScamReportOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    summary?: SortOrder
    averageRiskLevel?: SortOrder
    averageFinancialImpact?: SortOrder
    category?: SortOrder
  }

  export type AIScamReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIScamReportWhereInput | AIScamReportWhereInput[]
    OR?: AIScamReportWhereInput[]
    NOT?: AIScamReportWhereInput | AIScamReportWhereInput[]
    createdAt?: DateTimeFilter<"AIScamReport"> | Date | string
    updatedAt?: DateTimeFilter<"AIScamReport"> | Date | string
    summary?: StringFilter<"AIScamReport"> | string
    averageRiskLevel?: StringFilter<"AIScamReport"> | string
    averageFinancialImpact?: FloatFilter<"AIScamReport"> | number
    category?: StringFilter<"AIScamReport"> | string
  }, "id">

  export type AIScamReportOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    summary?: SortOrder
    averageRiskLevel?: SortOrder
    averageFinancialImpact?: SortOrder
    category?: SortOrder
    _count?: AIScamReportCountOrderByAggregateInput
    _avg?: AIScamReportAvgOrderByAggregateInput
    _max?: AIScamReportMaxOrderByAggregateInput
    _min?: AIScamReportMinOrderByAggregateInput
    _sum?: AIScamReportSumOrderByAggregateInput
  }

  export type AIScamReportScalarWhereWithAggregatesInput = {
    AND?: AIScamReportScalarWhereWithAggregatesInput | AIScamReportScalarWhereWithAggregatesInput[]
    OR?: AIScamReportScalarWhereWithAggregatesInput[]
    NOT?: AIScamReportScalarWhereWithAggregatesInput | AIScamReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIScamReport"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AIScamReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AIScamReport"> | Date | string
    summary?: StringWithAggregatesFilter<"AIScamReport"> | string
    averageRiskLevel?: StringWithAggregatesFilter<"AIScamReport"> | string
    averageFinancialImpact?: FloatWithAggregatesFilter<"AIScamReport"> | number
    category?: StringWithAggregatesFilter<"AIScamReport"> | string
  }

  export type ScamTypeWhereInput = {
    AND?: ScamTypeWhereInput | ScamTypeWhereInput[]
    OR?: ScamTypeWhereInput[]
    NOT?: ScamTypeWhereInput | ScamTypeWhereInput[]
    id?: StringFilter<"ScamType"> | string
    name?: StringFilter<"ScamType"> | string
    createdAt?: DateTimeFilter<"ScamType"> | Date | string
    createdBy?: StringNullableFilter<"ScamType"> | string | null
    isApproved?: BoolFilter<"ScamType"> | boolean
    isUserCreated?: BoolFilter<"ScamType"> | boolean
    moderatedAt?: DateTimeNullableFilter<"ScamType"> | Date | string | null
    moderatedBy?: StringNullableFilter<"ScamType"> | string | null
    contactLinks?: ContactScamTypeListRelationFilter
    postLinks?: EducationPostScamTypeListRelationFilter
    reports?: ScamReportListRelationFilter
    severityRecords?: SeverityListRelationFilter
  }

  export type ScamTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    isApproved?: SortOrder
    isUserCreated?: SortOrder
    moderatedAt?: SortOrderInput | SortOrder
    moderatedBy?: SortOrderInput | SortOrder
    contactLinks?: ContactScamTypeOrderByRelationAggregateInput
    postLinks?: EducationPostScamTypeOrderByRelationAggregateInput
    reports?: ScamReportOrderByRelationAggregateInput
    severityRecords?: SeverityOrderByRelationAggregateInput
  }

  export type ScamTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ScamTypeWhereInput | ScamTypeWhereInput[]
    OR?: ScamTypeWhereInput[]
    NOT?: ScamTypeWhereInput | ScamTypeWhereInput[]
    createdAt?: DateTimeFilter<"ScamType"> | Date | string
    createdBy?: StringNullableFilter<"ScamType"> | string | null
    isApproved?: BoolFilter<"ScamType"> | boolean
    isUserCreated?: BoolFilter<"ScamType"> | boolean
    moderatedAt?: DateTimeNullableFilter<"ScamType"> | Date | string | null
    moderatedBy?: StringNullableFilter<"ScamType"> | string | null
    contactLinks?: ContactScamTypeListRelationFilter
    postLinks?: EducationPostScamTypeListRelationFilter
    reports?: ScamReportListRelationFilter
    severityRecords?: SeverityListRelationFilter
  }, "id" | "name">

  export type ScamTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    isApproved?: SortOrder
    isUserCreated?: SortOrder
    moderatedAt?: SortOrderInput | SortOrder
    moderatedBy?: SortOrderInput | SortOrder
    _count?: ScamTypeCountOrderByAggregateInput
    _max?: ScamTypeMaxOrderByAggregateInput
    _min?: ScamTypeMinOrderByAggregateInput
  }

  export type ScamTypeScalarWhereWithAggregatesInput = {
    AND?: ScamTypeScalarWhereWithAggregatesInput | ScamTypeScalarWhereWithAggregatesInput[]
    OR?: ScamTypeScalarWhereWithAggregatesInput[]
    NOT?: ScamTypeScalarWhereWithAggregatesInput | ScamTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScamType"> | string
    name?: StringWithAggregatesFilter<"ScamType"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ScamType"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"ScamType"> | string | null
    isApproved?: BoolWithAggregatesFilter<"ScamType"> | boolean
    isUserCreated?: BoolWithAggregatesFilter<"ScamType"> | boolean
    moderatedAt?: DateTimeNullableWithAggregatesFilter<"ScamType"> | Date | string | null
    moderatedBy?: StringNullableWithAggregatesFilter<"ScamType"> | string | null
  }

  export type SeverityWhereInput = {
    AND?: SeverityWhereInput | SeverityWhereInput[]
    OR?: SeverityWhereInput[]
    NOT?: SeverityWhereInput | SeverityWhereInput[]
    id?: StringFilter<"Severity"> | string
    scamTypeId?: StringFilter<"Severity"> | string
    country?: StringNullableFilter<"Severity"> | string | null
    region?: StringNullableFilter<"Severity"> | string | null
    city?: StringNullableFilter<"Severity"> | string | null
    score?: IntFilter<"Severity"> | number
    level?: StringFilter<"Severity"> | string
    updatedAt?: DateTimeFilter<"Severity"> | Date | string
    createdAt?: DateTimeFilter<"Severity"> | Date | string
    scamType?: XOR<ScamTypeScalarRelationFilter, ScamTypeWhereInput>
  }

  export type SeverityOrderByWithRelationInput = {
    id?: SortOrder
    scamTypeId?: SortOrder
    country?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    score?: SortOrder
    level?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    scamType?: ScamTypeOrderByWithRelationInput
  }

  export type SeverityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SeverityWhereInput | SeverityWhereInput[]
    OR?: SeverityWhereInput[]
    NOT?: SeverityWhereInput | SeverityWhereInput[]
    scamTypeId?: StringFilter<"Severity"> | string
    country?: StringNullableFilter<"Severity"> | string | null
    region?: StringNullableFilter<"Severity"> | string | null
    city?: StringNullableFilter<"Severity"> | string | null
    score?: IntFilter<"Severity"> | number
    level?: StringFilter<"Severity"> | string
    updatedAt?: DateTimeFilter<"Severity"> | Date | string
    createdAt?: DateTimeFilter<"Severity"> | Date | string
    scamType?: XOR<ScamTypeScalarRelationFilter, ScamTypeWhereInput>
  }, "id">

  export type SeverityOrderByWithAggregationInput = {
    id?: SortOrder
    scamTypeId?: SortOrder
    country?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    score?: SortOrder
    level?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: SeverityCountOrderByAggregateInput
    _avg?: SeverityAvgOrderByAggregateInput
    _max?: SeverityMaxOrderByAggregateInput
    _min?: SeverityMinOrderByAggregateInput
    _sum?: SeveritySumOrderByAggregateInput
  }

  export type SeverityScalarWhereWithAggregatesInput = {
    AND?: SeverityScalarWhereWithAggregatesInput | SeverityScalarWhereWithAggregatesInput[]
    OR?: SeverityScalarWhereWithAggregatesInput[]
    NOT?: SeverityScalarWhereWithAggregatesInput | SeverityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Severity"> | string
    scamTypeId?: StringWithAggregatesFilter<"Severity"> | string
    country?: StringNullableWithAggregatesFilter<"Severity"> | string | null
    region?: StringNullableWithAggregatesFilter<"Severity"> | string | null
    city?: StringNullableWithAggregatesFilter<"Severity"> | string | null
    score?: IntWithAggregatesFilter<"Severity"> | number
    level?: StringWithAggregatesFilter<"Severity"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Severity"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Severity"> | Date | string
  }

  export type FlagWhereInput = {
    AND?: FlagWhereInput | FlagWhereInput[]
    OR?: FlagWhereInput[]
    NOT?: FlagWhereInput | FlagWhereInput[]
    id?: StringFilter<"Flag"> | string
    createdAt?: DateTimeFilter<"Flag"> | Date | string
    reportId?: StringFilter<"Flag"> | string
    userId?: StringFilter<"Flag"> | string
    reason?: StringNullableFilter<"Flag"> | string | null
    report?: XOR<ScamReportScalarRelationFilter, ScamReportWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FlagOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    reportId?: SortOrder
    userId?: SortOrder
    reason?: SortOrderInput | SortOrder
    report?: ScamReportOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type FlagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    reportId_userId?: FlagReportIdUserIdCompoundUniqueInput
    AND?: FlagWhereInput | FlagWhereInput[]
    OR?: FlagWhereInput[]
    NOT?: FlagWhereInput | FlagWhereInput[]
    createdAt?: DateTimeFilter<"Flag"> | Date | string
    reportId?: StringFilter<"Flag"> | string
    userId?: StringFilter<"Flag"> | string
    reason?: StringNullableFilter<"Flag"> | string | null
    report?: XOR<ScamReportScalarRelationFilter, ScamReportWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "reportId_userId">

  export type FlagOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    reportId?: SortOrder
    userId?: SortOrder
    reason?: SortOrderInput | SortOrder
    _count?: FlagCountOrderByAggregateInput
    _max?: FlagMaxOrderByAggregateInput
    _min?: FlagMinOrderByAggregateInput
  }

  export type FlagScalarWhereWithAggregatesInput = {
    AND?: FlagScalarWhereWithAggregatesInput | FlagScalarWhereWithAggregatesInput[]
    OR?: FlagScalarWhereWithAggregatesInput[]
    NOT?: FlagScalarWhereWithAggregatesInput | FlagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Flag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Flag"> | Date | string
    reportId?: StringWithAggregatesFilter<"Flag"> | string
    userId?: StringWithAggregatesFilter<"Flag"> | string
    reason?: StringNullableWithAggregatesFilter<"Flag"> | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    notificationSettings?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    role?: StringFilter<"User"> | string
    comments?: CommentListRelationFilter
    flags?: FlagListRelationFilter
    notifications?: NotificationListRelationFilter
    votes?: VoteListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    name?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    notificationSettings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
    comments?: CommentOrderByRelationAggregateInput
    flags?: FlagOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    votes?: VoteOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    notificationSettings?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    role?: StringFilter<"User"> | string
    comments?: CommentListRelationFilter
    flags?: FlagListRelationFilter
    notifications?: NotificationListRelationFilter
    votes?: VoteListRelationFilter
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    name?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    notificationSettings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    notificationSettings?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    role?: StringWithAggregatesFilter<"User"> | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    data?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    data?: SortOrderInput | SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    data?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    data?: SortOrderInput | SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    data?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type OutcomeTypeWhereInput = {
    AND?: OutcomeTypeWhereInput | OutcomeTypeWhereInput[]
    OR?: OutcomeTypeWhereInput[]
    NOT?: OutcomeTypeWhereInput | OutcomeTypeWhereInput[]
    id?: StringFilter<"OutcomeType"> | string
    value?: StringFilter<"OutcomeType"> | string
    label?: StringFilter<"OutcomeType"> | string
    createdAt?: DateTimeFilter<"OutcomeType"> | Date | string
    updatedAt?: DateTimeFilter<"OutcomeType"> | Date | string
  }

  export type OutcomeTypeOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutcomeTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    value?: string
    AND?: OutcomeTypeWhereInput | OutcomeTypeWhereInput[]
    OR?: OutcomeTypeWhereInput[]
    NOT?: OutcomeTypeWhereInput | OutcomeTypeWhereInput[]
    label?: StringFilter<"OutcomeType"> | string
    createdAt?: DateTimeFilter<"OutcomeType"> | Date | string
    updatedAt?: DateTimeFilter<"OutcomeType"> | Date | string
  }, "id" | "value">

  export type OutcomeTypeOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OutcomeTypeCountOrderByAggregateInput
    _max?: OutcomeTypeMaxOrderByAggregateInput
    _min?: OutcomeTypeMinOrderByAggregateInput
  }

  export type OutcomeTypeScalarWhereWithAggregatesInput = {
    AND?: OutcomeTypeScalarWhereWithAggregatesInput | OutcomeTypeScalarWhereWithAggregatesInput[]
    OR?: OutcomeTypeScalarWhereWithAggregatesInput[]
    NOT?: OutcomeTypeScalarWhereWithAggregatesInput | OutcomeTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OutcomeType"> | string
    value?: StringWithAggregatesFilter<"OutcomeType"> | string
    label?: StringWithAggregatesFilter<"OutcomeType"> | string
    createdAt?: DateTimeWithAggregatesFilter<"OutcomeType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OutcomeType"> | Date | string
  }

  export type EducationPostWhereInput = {
    AND?: EducationPostWhereInput | EducationPostWhereInput[]
    OR?: EducationPostWhereInput[]
    NOT?: EducationPostWhereInput | EducationPostWhereInput[]
    id?: StringFilter<"EducationPost"> | string
    createdAt?: DateTimeFilter<"EducationPost"> | Date | string
    updatedAt?: DateTimeFilter<"EducationPost"> | Date | string
    slug?: StringFilter<"EducationPost"> | string
    title?: StringFilter<"EducationPost"> | string
    excerpt?: StringNullableFilter<"EducationPost"> | string | null
    bodyMd?: StringFilter<"EducationPost"> | string
    status?: EnumPostStatusFilter<"EducationPost"> | $Enums.PostStatus
    publishedAt?: DateTimeNullableFilter<"EducationPost"> | Date | string | null
    category?: EnumPostCategoryFilter<"EducationPost"> | $Enums.PostCategory
    heroImageUrl?: StringNullableFilter<"EducationPost"> | string | null
    heroSvg?: StringNullableFilter<"EducationPost"> | string | null
    heroAlt?: StringNullableFilter<"EducationPost"> | string | null
    country?: StringNullableFilter<"EducationPost"> | string | null
    region?: StringNullableFilter<"EducationPost"> | string | null
    city?: StringNullableFilter<"EducationPost"> | string | null
    canonicalUrl?: StringNullableFilter<"EducationPost"> | string | null
    metaTitle?: StringNullableFilter<"EducationPost"> | string | null
    metaDescription?: StringNullableFilter<"EducationPost"> | string | null
    featured?: BoolFilter<"EducationPost"> | boolean
    authorName?: StringNullableFilter<"EducationPost"> | string | null
    sourceUrl?: StringNullableFilter<"EducationPost"> | string | null
    scamTypes?: EducationPostScamTypeListRelationFilter
    tags?: PostTagListRelationFilter
  }

  export type EducationPostOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    bodyMd?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    category?: SortOrder
    heroImageUrl?: SortOrderInput | SortOrder
    heroSvg?: SortOrderInput | SortOrder
    heroAlt?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    canonicalUrl?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    featured?: SortOrder
    authorName?: SortOrderInput | SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    scamTypes?: EducationPostScamTypeOrderByRelationAggregateInput
    tags?: PostTagOrderByRelationAggregateInput
  }

  export type EducationPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: EducationPostWhereInput | EducationPostWhereInput[]
    OR?: EducationPostWhereInput[]
    NOT?: EducationPostWhereInput | EducationPostWhereInput[]
    createdAt?: DateTimeFilter<"EducationPost"> | Date | string
    updatedAt?: DateTimeFilter<"EducationPost"> | Date | string
    title?: StringFilter<"EducationPost"> | string
    excerpt?: StringNullableFilter<"EducationPost"> | string | null
    bodyMd?: StringFilter<"EducationPost"> | string
    status?: EnumPostStatusFilter<"EducationPost"> | $Enums.PostStatus
    publishedAt?: DateTimeNullableFilter<"EducationPost"> | Date | string | null
    category?: EnumPostCategoryFilter<"EducationPost"> | $Enums.PostCategory
    heroImageUrl?: StringNullableFilter<"EducationPost"> | string | null
    heroSvg?: StringNullableFilter<"EducationPost"> | string | null
    heroAlt?: StringNullableFilter<"EducationPost"> | string | null
    country?: StringNullableFilter<"EducationPost"> | string | null
    region?: StringNullableFilter<"EducationPost"> | string | null
    city?: StringNullableFilter<"EducationPost"> | string | null
    canonicalUrl?: StringNullableFilter<"EducationPost"> | string | null
    metaTitle?: StringNullableFilter<"EducationPost"> | string | null
    metaDescription?: StringNullableFilter<"EducationPost"> | string | null
    featured?: BoolFilter<"EducationPost"> | boolean
    authorName?: StringNullableFilter<"EducationPost"> | string | null
    sourceUrl?: StringNullableFilter<"EducationPost"> | string | null
    scamTypes?: EducationPostScamTypeListRelationFilter
    tags?: PostTagListRelationFilter
  }, "id" | "slug">

  export type EducationPostOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    excerpt?: SortOrderInput | SortOrder
    bodyMd?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    category?: SortOrder
    heroImageUrl?: SortOrderInput | SortOrder
    heroSvg?: SortOrderInput | SortOrder
    heroAlt?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    canonicalUrl?: SortOrderInput | SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    featured?: SortOrder
    authorName?: SortOrderInput | SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    _count?: EducationPostCountOrderByAggregateInput
    _max?: EducationPostMaxOrderByAggregateInput
    _min?: EducationPostMinOrderByAggregateInput
  }

  export type EducationPostScalarWhereWithAggregatesInput = {
    AND?: EducationPostScalarWhereWithAggregatesInput | EducationPostScalarWhereWithAggregatesInput[]
    OR?: EducationPostScalarWhereWithAggregatesInput[]
    NOT?: EducationPostScalarWhereWithAggregatesInput | EducationPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EducationPost"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EducationPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EducationPost"> | Date | string
    slug?: StringWithAggregatesFilter<"EducationPost"> | string
    title?: StringWithAggregatesFilter<"EducationPost"> | string
    excerpt?: StringNullableWithAggregatesFilter<"EducationPost"> | string | null
    bodyMd?: StringWithAggregatesFilter<"EducationPost"> | string
    status?: EnumPostStatusWithAggregatesFilter<"EducationPost"> | $Enums.PostStatus
    publishedAt?: DateTimeNullableWithAggregatesFilter<"EducationPost"> | Date | string | null
    category?: EnumPostCategoryWithAggregatesFilter<"EducationPost"> | $Enums.PostCategory
    heroImageUrl?: StringNullableWithAggregatesFilter<"EducationPost"> | string | null
    heroSvg?: StringNullableWithAggregatesFilter<"EducationPost"> | string | null
    heroAlt?: StringNullableWithAggregatesFilter<"EducationPost"> | string | null
    country?: StringNullableWithAggregatesFilter<"EducationPost"> | string | null
    region?: StringNullableWithAggregatesFilter<"EducationPost"> | string | null
    city?: StringNullableWithAggregatesFilter<"EducationPost"> | string | null
    canonicalUrl?: StringNullableWithAggregatesFilter<"EducationPost"> | string | null
    metaTitle?: StringNullableWithAggregatesFilter<"EducationPost"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"EducationPost"> | string | null
    featured?: BoolWithAggregatesFilter<"EducationPost"> | boolean
    authorName?: StringNullableWithAggregatesFilter<"EducationPost"> | string | null
    sourceUrl?: StringNullableWithAggregatesFilter<"EducationPost"> | string | null
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    contacts?: ContactTagListRelationFilter
    posts?: PostTagListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    contacts?: ContactTagOrderByRelationAggregateInput
    posts?: PostTagOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    contacts?: ContactTagListRelationFilter
    posts?: PostTagListRelationFilter
  }, "id" | "name">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
  }

  export type PostTagWhereInput = {
    AND?: PostTagWhereInput | PostTagWhereInput[]
    OR?: PostTagWhereInput[]
    NOT?: PostTagWhereInput | PostTagWhereInput[]
    postId?: StringFilter<"PostTag"> | string
    tagId?: StringFilter<"PostTag"> | string
    post?: XOR<EducationPostScalarRelationFilter, EducationPostWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type PostTagOrderByWithRelationInput = {
    postId?: SortOrder
    tagId?: SortOrder
    post?: EducationPostOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type PostTagWhereUniqueInput = Prisma.AtLeast<{
    postId_tagId?: PostTagPostIdTagIdCompoundUniqueInput
    AND?: PostTagWhereInput | PostTagWhereInput[]
    OR?: PostTagWhereInput[]
    NOT?: PostTagWhereInput | PostTagWhereInput[]
    postId?: StringFilter<"PostTag"> | string
    tagId?: StringFilter<"PostTag"> | string
    post?: XOR<EducationPostScalarRelationFilter, EducationPostWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "postId_tagId">

  export type PostTagOrderByWithAggregationInput = {
    postId?: SortOrder
    tagId?: SortOrder
    _count?: PostTagCountOrderByAggregateInput
    _max?: PostTagMaxOrderByAggregateInput
    _min?: PostTagMinOrderByAggregateInput
  }

  export type PostTagScalarWhereWithAggregatesInput = {
    AND?: PostTagScalarWhereWithAggregatesInput | PostTagScalarWhereWithAggregatesInput[]
    OR?: PostTagScalarWhereWithAggregatesInput[]
    NOT?: PostTagScalarWhereWithAggregatesInput | PostTagScalarWhereWithAggregatesInput[]
    postId?: StringWithAggregatesFilter<"PostTag"> | string
    tagId?: StringWithAggregatesFilter<"PostTag"> | string
  }

  export type EducationPostScamTypeWhereInput = {
    AND?: EducationPostScamTypeWhereInput | EducationPostScamTypeWhereInput[]
    OR?: EducationPostScamTypeWhereInput[]
    NOT?: EducationPostScamTypeWhereInput | EducationPostScamTypeWhereInput[]
    postId?: StringFilter<"EducationPostScamType"> | string
    scamTypeId?: StringFilter<"EducationPostScamType"> | string
    post?: XOR<EducationPostScalarRelationFilter, EducationPostWhereInput>
    scamType?: XOR<ScamTypeScalarRelationFilter, ScamTypeWhereInput>
  }

  export type EducationPostScamTypeOrderByWithRelationInput = {
    postId?: SortOrder
    scamTypeId?: SortOrder
    post?: EducationPostOrderByWithRelationInput
    scamType?: ScamTypeOrderByWithRelationInput
  }

  export type EducationPostScamTypeWhereUniqueInput = Prisma.AtLeast<{
    postId_scamTypeId?: EducationPostScamTypePostIdScamTypeIdCompoundUniqueInput
    AND?: EducationPostScamTypeWhereInput | EducationPostScamTypeWhereInput[]
    OR?: EducationPostScamTypeWhereInput[]
    NOT?: EducationPostScamTypeWhereInput | EducationPostScamTypeWhereInput[]
    postId?: StringFilter<"EducationPostScamType"> | string
    scamTypeId?: StringFilter<"EducationPostScamType"> | string
    post?: XOR<EducationPostScalarRelationFilter, EducationPostWhereInput>
    scamType?: XOR<ScamTypeScalarRelationFilter, ScamTypeWhereInput>
  }, "postId_scamTypeId">

  export type EducationPostScamTypeOrderByWithAggregationInput = {
    postId?: SortOrder
    scamTypeId?: SortOrder
    _count?: EducationPostScamTypeCountOrderByAggregateInput
    _max?: EducationPostScamTypeMaxOrderByAggregateInput
    _min?: EducationPostScamTypeMinOrderByAggregateInput
  }

  export type EducationPostScamTypeScalarWhereWithAggregatesInput = {
    AND?: EducationPostScamTypeScalarWhereWithAggregatesInput | EducationPostScamTypeScalarWhereWithAggregatesInput[]
    OR?: EducationPostScamTypeScalarWhereWithAggregatesInput[]
    NOT?: EducationPostScamTypeScalarWhereWithAggregatesInput | EducationPostScamTypeScalarWhereWithAggregatesInput[]
    postId?: StringWithAggregatesFilter<"EducationPostScamType"> | string
    scamTypeId?: StringWithAggregatesFilter<"EducationPostScamType"> | string
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: StringFilter<"Contact"> | string
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    orgName?: StringFilter<"Contact"> | string
    category?: EnumContactCategoryFilter<"Contact"> | $Enums.ContactCategory
    description?: StringNullableFilter<"Contact"> | string | null
    website?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    email?: StringNullableFilter<"Contact"> | string | null
    submitUrl?: StringNullableFilter<"Contact"> | string | null
    languageCodes?: StringNullableListFilter<"Contact">
    country?: StringNullableFilter<"Contact"> | string | null
    region?: StringNullableFilter<"Contact"> | string | null
    city?: StringNullableFilter<"Contact"> | string | null
    status?: EnumContactStatusFilter<"Contact"> | $Enums.ContactStatus
    verified?: BoolFilter<"Contact"> | boolean
    source?: StringNullableFilter<"Contact"> | string | null
    lastVerifiedAt?: DateTimeNullableFilter<"Contact"> | Date | string | null
    createdById?: StringNullableFilter<"Contact"> | string | null
    scamTypes?: ContactScamTypeListRelationFilter
    tags?: ContactTagListRelationFilter
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orgName?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    submitUrl?: SortOrderInput | SortOrder
    languageCodes?: SortOrder
    country?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    status?: SortOrder
    verified?: SortOrder
    source?: SortOrderInput | SortOrder
    lastVerifiedAt?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    scamTypes?: ContactScamTypeOrderByRelationAggregateInput
    tags?: ContactTagOrderByRelationAggregateInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    orgName?: StringFilter<"Contact"> | string
    category?: EnumContactCategoryFilter<"Contact"> | $Enums.ContactCategory
    description?: StringNullableFilter<"Contact"> | string | null
    website?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    email?: StringNullableFilter<"Contact"> | string | null
    submitUrl?: StringNullableFilter<"Contact"> | string | null
    languageCodes?: StringNullableListFilter<"Contact">
    country?: StringNullableFilter<"Contact"> | string | null
    region?: StringNullableFilter<"Contact"> | string | null
    city?: StringNullableFilter<"Contact"> | string | null
    status?: EnumContactStatusFilter<"Contact"> | $Enums.ContactStatus
    verified?: BoolFilter<"Contact"> | boolean
    source?: StringNullableFilter<"Contact"> | string | null
    lastVerifiedAt?: DateTimeNullableFilter<"Contact"> | Date | string | null
    createdById?: StringNullableFilter<"Contact"> | string | null
    scamTypes?: ContactScamTypeListRelationFilter
    tags?: ContactTagListRelationFilter
  }, "id">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orgName?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    submitUrl?: SortOrderInput | SortOrder
    languageCodes?: SortOrder
    country?: SortOrderInput | SortOrder
    region?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    status?: SortOrder
    verified?: SortOrder
    source?: SortOrderInput | SortOrder
    lastVerifiedAt?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    _count?: ContactCountOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contact"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    orgName?: StringWithAggregatesFilter<"Contact"> | string
    category?: EnumContactCategoryWithAggregatesFilter<"Contact"> | $Enums.ContactCategory
    description?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    website?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    email?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    submitUrl?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    languageCodes?: StringNullableListFilter<"Contact">
    country?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    region?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    city?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    status?: EnumContactStatusWithAggregatesFilter<"Contact"> | $Enums.ContactStatus
    verified?: BoolWithAggregatesFilter<"Contact"> | boolean
    source?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    lastVerifiedAt?: DateTimeNullableWithAggregatesFilter<"Contact"> | Date | string | null
    createdById?: StringNullableWithAggregatesFilter<"Contact"> | string | null
  }

  export type ContactScamTypeWhereInput = {
    AND?: ContactScamTypeWhereInput | ContactScamTypeWhereInput[]
    OR?: ContactScamTypeWhereInput[]
    NOT?: ContactScamTypeWhereInput | ContactScamTypeWhereInput[]
    contactId?: StringFilter<"ContactScamType"> | string
    scamTypeId?: StringFilter<"ContactScamType"> | string
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    scamType?: XOR<ScamTypeScalarRelationFilter, ScamTypeWhereInput>
  }

  export type ContactScamTypeOrderByWithRelationInput = {
    contactId?: SortOrder
    scamTypeId?: SortOrder
    contact?: ContactOrderByWithRelationInput
    scamType?: ScamTypeOrderByWithRelationInput
  }

  export type ContactScamTypeWhereUniqueInput = Prisma.AtLeast<{
    contactId_scamTypeId?: ContactScamTypeContactIdScamTypeIdCompoundUniqueInput
    AND?: ContactScamTypeWhereInput | ContactScamTypeWhereInput[]
    OR?: ContactScamTypeWhereInput[]
    NOT?: ContactScamTypeWhereInput | ContactScamTypeWhereInput[]
    contactId?: StringFilter<"ContactScamType"> | string
    scamTypeId?: StringFilter<"ContactScamType"> | string
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    scamType?: XOR<ScamTypeScalarRelationFilter, ScamTypeWhereInput>
  }, "contactId_scamTypeId">

  export type ContactScamTypeOrderByWithAggregationInput = {
    contactId?: SortOrder
    scamTypeId?: SortOrder
    _count?: ContactScamTypeCountOrderByAggregateInput
    _max?: ContactScamTypeMaxOrderByAggregateInput
    _min?: ContactScamTypeMinOrderByAggregateInput
  }

  export type ContactScamTypeScalarWhereWithAggregatesInput = {
    AND?: ContactScamTypeScalarWhereWithAggregatesInput | ContactScamTypeScalarWhereWithAggregatesInput[]
    OR?: ContactScamTypeScalarWhereWithAggregatesInput[]
    NOT?: ContactScamTypeScalarWhereWithAggregatesInput | ContactScamTypeScalarWhereWithAggregatesInput[]
    contactId?: StringWithAggregatesFilter<"ContactScamType"> | string
    scamTypeId?: StringWithAggregatesFilter<"ContactScamType"> | string
  }

  export type ContactTagWhereInput = {
    AND?: ContactTagWhereInput | ContactTagWhereInput[]
    OR?: ContactTagWhereInput[]
    NOT?: ContactTagWhereInput | ContactTagWhereInput[]
    contactId?: StringFilter<"ContactTag"> | string
    tagId?: StringFilter<"ContactTag"> | string
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type ContactTagOrderByWithRelationInput = {
    contactId?: SortOrder
    tagId?: SortOrder
    contact?: ContactOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type ContactTagWhereUniqueInput = Prisma.AtLeast<{
    contactId_tagId?: ContactTagContactIdTagIdCompoundUniqueInput
    AND?: ContactTagWhereInput | ContactTagWhereInput[]
    OR?: ContactTagWhereInput[]
    NOT?: ContactTagWhereInput | ContactTagWhereInput[]
    contactId?: StringFilter<"ContactTag"> | string
    tagId?: StringFilter<"ContactTag"> | string
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "contactId_tagId">

  export type ContactTagOrderByWithAggregationInput = {
    contactId?: SortOrder
    tagId?: SortOrder
    _count?: ContactTagCountOrderByAggregateInput
    _max?: ContactTagMaxOrderByAggregateInput
    _min?: ContactTagMinOrderByAggregateInput
  }

  export type ContactTagScalarWhereWithAggregatesInput = {
    AND?: ContactTagScalarWhereWithAggregatesInput | ContactTagScalarWhereWithAggregatesInput[]
    OR?: ContactTagScalarWhereWithAggregatesInput[]
    NOT?: ContactTagScalarWhereWithAggregatesInput | ContactTagScalarWhereWithAggregatesInput[]
    contactId?: StringWithAggregatesFilter<"ContactTag"> | string
    tagId?: StringWithAggregatesFilter<"ContactTag"> | string
  }

  export type ScamReportCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    scammerDetails?: NullableJsonNullValueInput | InputJsonValue
    city?: string | null
    country?: string | null
    region?: string | null
    ipHash?: string | null
    latitude?: number | null
    longitude?: number | null
    verified?: boolean
    trustScore?: number
    reportCount?: number
    reporterName?: string | null
    reporterEmail?: string | null
    anonymous?: boolean
    outcome?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: string | null
    evidence?: string | null
    source?: string | null
    comments?: CommentCreateNestedManyWithoutReportInput
    flags?: FlagCreateNestedManyWithoutReportInput
    scamType?: ScamTypeCreateNestedOneWithoutReportsInput
    votes?: VoteCreateNestedManyWithoutReportInput
  }

  export type ScamReportUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    scammerDetails?: NullableJsonNullValueInput | InputJsonValue
    city?: string | null
    country?: string | null
    region?: string | null
    ipHash?: string | null
    latitude?: number | null
    longitude?: number | null
    verified?: boolean
    trustScore?: number
    reportCount?: number
    reporterName?: string | null
    reporterEmail?: string | null
    anonymous?: boolean
    outcome?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: string | null
    evidence?: string | null
    scamTypeId?: string | null
    source?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutReportInput
    flags?: FlagUncheckedCreateNestedManyWithoutReportInput
    votes?: VoteUncheckedCreateNestedManyWithoutReportInput
  }

  export type ScamReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    scammerDetails?: NullableJsonNullValueInput | InputJsonValue
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    trustScore?: IntFieldUpdateOperationsInput | number
    reportCount?: IntFieldUpdateOperationsInput | number
    reporterName?: NullableStringFieldUpdateOperationsInput | string | null
    reporterEmail?: NullableStringFieldUpdateOperationsInput | string | null
    anonymous?: BoolFieldUpdateOperationsInput | boolean
    outcome?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUpdateManyWithoutReportNestedInput
    flags?: FlagUpdateManyWithoutReportNestedInput
    scamType?: ScamTypeUpdateOneWithoutReportsNestedInput
    votes?: VoteUpdateManyWithoutReportNestedInput
  }

  export type ScamReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    scammerDetails?: NullableJsonNullValueInput | InputJsonValue
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    trustScore?: IntFieldUpdateOperationsInput | number
    reportCount?: IntFieldUpdateOperationsInput | number
    reporterName?: NullableStringFieldUpdateOperationsInput | string | null
    reporterEmail?: NullableStringFieldUpdateOperationsInput | string | null
    anonymous?: BoolFieldUpdateOperationsInput | boolean
    outcome?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    scamTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutReportNestedInput
    flags?: FlagUncheckedUpdateManyWithoutReportNestedInput
    votes?: VoteUncheckedUpdateManyWithoutReportNestedInput
  }

  export type ScamReportCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    scammerDetails?: NullableJsonNullValueInput | InputJsonValue
    city?: string | null
    country?: string | null
    region?: string | null
    ipHash?: string | null
    latitude?: number | null
    longitude?: number | null
    verified?: boolean
    trustScore?: number
    reportCount?: number
    reporterName?: string | null
    reporterEmail?: string | null
    anonymous?: boolean
    outcome?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: string | null
    evidence?: string | null
    scamTypeId?: string | null
    source?: string | null
  }

  export type ScamReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    scammerDetails?: NullableJsonNullValueInput | InputJsonValue
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    trustScore?: IntFieldUpdateOperationsInput | number
    reportCount?: IntFieldUpdateOperationsInput | number
    reporterName?: NullableStringFieldUpdateOperationsInput | string | null
    reporterEmail?: NullableStringFieldUpdateOperationsInput | string | null
    anonymous?: BoolFieldUpdateOperationsInput | boolean
    outcome?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScamReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    scammerDetails?: NullableJsonNullValueInput | InputJsonValue
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    trustScore?: IntFieldUpdateOperationsInput | number
    reportCount?: IntFieldUpdateOperationsInput | number
    reporterName?: NullableStringFieldUpdateOperationsInput | string | null
    reporterEmail?: NullableStringFieldUpdateOperationsInput | string | null
    anonymous?: BoolFieldUpdateOperationsInput | boolean
    outcome?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    scamTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentCreateInput = {
    id?: string
    createdAt?: Date | string
    content: string
    parent?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentInput
    report: ScamReportCreateNestedOneWithoutCommentsInput
    user?: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    content: string
    reportId: string
    parentId?: string | null
    userId?: string | null
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    parent?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
    report?: ScamReportUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: string
    createdAt?: Date | string
    content: string
    reportId: string
    parentId?: string | null
    userId?: string | null
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VoteCreateInput = {
    id?: string
    voteType: string
    report: ScamReportCreateNestedOneWithoutVotesInput
    user: UserCreateNestedOneWithoutVotesInput
  }

  export type VoteUncheckedCreateInput = {
    id?: string
    reportId: string
    userId: string
    voteType: string
  }

  export type VoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    voteType?: StringFieldUpdateOperationsInput | string
    report?: ScamReportUpdateOneRequiredWithoutVotesNestedInput
    user?: UserUpdateOneRequiredWithoutVotesNestedInput
  }

  export type VoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    voteType?: StringFieldUpdateOperationsInput | string
  }

  export type VoteCreateManyInput = {
    id?: string
    reportId: string
    userId: string
    voteType: string
  }

  export type VoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    voteType?: StringFieldUpdateOperationsInput | string
  }

  export type VoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    voteType?: StringFieldUpdateOperationsInput | string
  }

  export type WikiPageCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    content: string
    category: string
    country?: string | null
    views?: number
    featured?: boolean
  }

  export type WikiPageUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    content: string
    category: string
    country?: string | null
    views?: number
    featured?: boolean
  }

  export type WikiPageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    featured?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WikiPageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    featured?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WikiPageCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    title: string
    slug: string
    content: string
    category: string
    country?: string | null
    views?: number
    featured?: boolean
  }

  export type WikiPageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    featured?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WikiPageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    views?: IntFieldUpdateOperationsInput | number
    featured?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SearchCacheCreateInput = {
    id?: string
    query: string
    results: string
    lastUpdated?: Date | string
    hitCount?: number
  }

  export type SearchCacheUncheckedCreateInput = {
    id?: string
    query: string
    results: string
    lastUpdated?: Date | string
    hitCount?: number
  }

  export type SearchCacheUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    results?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    hitCount?: IntFieldUpdateOperationsInput | number
  }

  export type SearchCacheUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    results?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    hitCount?: IntFieldUpdateOperationsInput | number
  }

  export type SearchCacheCreateManyInput = {
    id?: string
    query: string
    results: string
    lastUpdated?: Date | string
    hitCount?: number
  }

  export type SearchCacheUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    results?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    hitCount?: IntFieldUpdateOperationsInput | number
  }

  export type SearchCacheUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    query?: StringFieldUpdateOperationsInput | string
    results?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    hitCount?: IntFieldUpdateOperationsInput | number
  }

  export type AIScamReportCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    summary: string
    averageRiskLevel: string
    averageFinancialImpact: number
    category: string
  }

  export type AIScamReportUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    summary: string
    averageRiskLevel: string
    averageFinancialImpact: number
    category: string
  }

  export type AIScamReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    averageRiskLevel?: StringFieldUpdateOperationsInput | string
    averageFinancialImpact?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
  }

  export type AIScamReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    averageRiskLevel?: StringFieldUpdateOperationsInput | string
    averageFinancialImpact?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
  }

  export type AIScamReportCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    summary: string
    averageRiskLevel: string
    averageFinancialImpact: number
    category: string
  }

  export type AIScamReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    averageRiskLevel?: StringFieldUpdateOperationsInput | string
    averageFinancialImpact?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
  }

  export type AIScamReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: StringFieldUpdateOperationsInput | string
    averageRiskLevel?: StringFieldUpdateOperationsInput | string
    averageFinancialImpact?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
  }

  export type ScamTypeCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    createdBy?: string | null
    isApproved?: boolean
    isUserCreated?: boolean
    moderatedAt?: Date | string | null
    moderatedBy?: string | null
    contactLinks?: ContactScamTypeCreateNestedManyWithoutScamTypeInput
    postLinks?: EducationPostScamTypeCreateNestedManyWithoutScamTypeInput
    reports?: ScamReportCreateNestedManyWithoutScamTypeInput
    severityRecords?: SeverityCreateNestedManyWithoutScamTypeInput
  }

  export type ScamTypeUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    createdBy?: string | null
    isApproved?: boolean
    isUserCreated?: boolean
    moderatedAt?: Date | string | null
    moderatedBy?: string | null
    contactLinks?: ContactScamTypeUncheckedCreateNestedManyWithoutScamTypeInput
    postLinks?: EducationPostScamTypeUncheckedCreateNestedManyWithoutScamTypeInput
    reports?: ScamReportUncheckedCreateNestedManyWithoutScamTypeInput
    severityRecords?: SeverityUncheckedCreateNestedManyWithoutScamTypeInput
  }

  export type ScamTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isUserCreated?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    contactLinks?: ContactScamTypeUpdateManyWithoutScamTypeNestedInput
    postLinks?: EducationPostScamTypeUpdateManyWithoutScamTypeNestedInput
    reports?: ScamReportUpdateManyWithoutScamTypeNestedInput
    severityRecords?: SeverityUpdateManyWithoutScamTypeNestedInput
  }

  export type ScamTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isUserCreated?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    contactLinks?: ContactScamTypeUncheckedUpdateManyWithoutScamTypeNestedInput
    postLinks?: EducationPostScamTypeUncheckedUpdateManyWithoutScamTypeNestedInput
    reports?: ScamReportUncheckedUpdateManyWithoutScamTypeNestedInput
    severityRecords?: SeverityUncheckedUpdateManyWithoutScamTypeNestedInput
  }

  export type ScamTypeCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    createdBy?: string | null
    isApproved?: boolean
    isUserCreated?: boolean
    moderatedAt?: Date | string | null
    moderatedBy?: string | null
  }

  export type ScamTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isUserCreated?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScamTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isUserCreated?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SeverityCreateInput = {
    id?: string
    country?: string | null
    region?: string | null
    city?: string | null
    score: number
    level: string
    updatedAt?: Date | string
    createdAt?: Date | string
    scamType: ScamTypeCreateNestedOneWithoutSeverityRecordsInput
  }

  export type SeverityUncheckedCreateInput = {
    id?: string
    scamTypeId: string
    country?: string | null
    region?: string | null
    city?: string | null
    score: number
    level: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type SeverityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scamType?: ScamTypeUpdateOneRequiredWithoutSeverityRecordsNestedInput
  }

  export type SeverityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scamTypeId?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeverityCreateManyInput = {
    id?: string
    scamTypeId: string
    country?: string | null
    region?: string | null
    city?: string | null
    score: number
    level: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type SeverityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeverityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    scamTypeId?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlagCreateInput = {
    id?: string
    createdAt?: Date | string
    reason?: string | null
    report: ScamReportCreateNestedOneWithoutFlagsInput
    user: UserCreateNestedOneWithoutFlagsInput
  }

  export type FlagUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    reportId: string
    userId: string
    reason?: string | null
  }

  export type FlagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    report?: ScamReportUpdateOneRequiredWithoutFlagsNestedInput
    user?: UserUpdateOneRequiredWithoutFlagsNestedInput
  }

  export type FlagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FlagCreateManyInput = {
    id?: string
    createdAt?: Date | string
    reportId: string
    userId: string
    reason?: string | null
  }

  export type FlagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FlagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateInput = {
    id?: string
    email: string
    username: string
    name?: string | null
    image?: string | null
    notificationSettings?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: string
    comments?: CommentCreateNestedManyWithoutUserInput
    flags?: FlagCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    votes?: VoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    username: string
    name?: string | null
    image?: string | null
    notificationSettings?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: string
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    flags?: FlagUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    notificationSettings?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    comments?: CommentUpdateManyWithoutUserNestedInput
    flags?: FlagUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    votes?: VoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    notificationSettings?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    flags?: FlagUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    username: string
    name?: string | null
    image?: string | null
    notificationSettings?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    notificationSettings?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    notificationSettings?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    data?: string | null
    read?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    data?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: string
    data?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutcomeTypeCreateInput = {
    id?: string
    value: string
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutcomeTypeUncheckedCreateInput = {
    id?: string
    value: string
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutcomeTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutcomeTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutcomeTypeCreateManyInput = {
    id?: string
    value: string
    label: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutcomeTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutcomeTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EducationPostCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    title: string
    excerpt?: string | null
    bodyMd: string
    status?: $Enums.PostStatus
    publishedAt?: Date | string | null
    category: $Enums.PostCategory
    heroImageUrl?: string | null
    heroSvg?: string | null
    heroAlt?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    canonicalUrl?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    featured?: boolean
    authorName?: string | null
    sourceUrl?: string | null
    scamTypes?: EducationPostScamTypeCreateNestedManyWithoutPostInput
    tags?: PostTagCreateNestedManyWithoutPostInput
  }

  export type EducationPostUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    title: string
    excerpt?: string | null
    bodyMd: string
    status?: $Enums.PostStatus
    publishedAt?: Date | string | null
    category: $Enums.PostCategory
    heroImageUrl?: string | null
    heroSvg?: string | null
    heroAlt?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    canonicalUrl?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    featured?: boolean
    authorName?: string | null
    sourceUrl?: string | null
    scamTypes?: EducationPostScamTypeUncheckedCreateNestedManyWithoutPostInput
    tags?: PostTagUncheckedCreateNestedManyWithoutPostInput
  }

  export type EducationPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    bodyMd?: StringFieldUpdateOperationsInput | string
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPostCategoryFieldUpdateOperationsInput | $Enums.PostCategory
    heroImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    heroSvg?: NullableStringFieldUpdateOperationsInput | string | null
    heroAlt?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scamTypes?: EducationPostScamTypeUpdateManyWithoutPostNestedInput
    tags?: PostTagUpdateManyWithoutPostNestedInput
  }

  export type EducationPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    bodyMd?: StringFieldUpdateOperationsInput | string
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPostCategoryFieldUpdateOperationsInput | $Enums.PostCategory
    heroImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    heroSvg?: NullableStringFieldUpdateOperationsInput | string | null
    heroAlt?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scamTypes?: EducationPostScamTypeUncheckedUpdateManyWithoutPostNestedInput
    tags?: PostTagUncheckedUpdateManyWithoutPostNestedInput
  }

  export type EducationPostCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    title: string
    excerpt?: string | null
    bodyMd: string
    status?: $Enums.PostStatus
    publishedAt?: Date | string | null
    category: $Enums.PostCategory
    heroImageUrl?: string | null
    heroSvg?: string | null
    heroAlt?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    canonicalUrl?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    featured?: boolean
    authorName?: string | null
    sourceUrl?: string | null
  }

  export type EducationPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    bodyMd?: StringFieldUpdateOperationsInput | string
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPostCategoryFieldUpdateOperationsInput | $Enums.PostCategory
    heroImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    heroSvg?: NullableStringFieldUpdateOperationsInput | string | null
    heroAlt?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EducationPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    bodyMd?: StringFieldUpdateOperationsInput | string
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPostCategoryFieldUpdateOperationsInput | $Enums.PostCategory
    heroImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    heroSvg?: NullableStringFieldUpdateOperationsInput | string | null
    heroAlt?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TagCreateInput = {
    id?: string
    name: string
    contacts?: ContactTagCreateNestedManyWithoutTagInput
    posts?: PostTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    contacts?: ContactTagUncheckedCreateNestedManyWithoutTagInput
    posts?: PostTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contacts?: ContactTagUpdateManyWithoutTagNestedInput
    posts?: PostTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contacts?: ContactTagUncheckedUpdateManyWithoutTagNestedInput
    posts?: PostTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PostTagCreateInput = {
    post: EducationPostCreateNestedOneWithoutTagsInput
    tag: TagCreateNestedOneWithoutPostsInput
  }

  export type PostTagUncheckedCreateInput = {
    postId: string
    tagId: string
  }

  export type PostTagUpdateInput = {
    post?: EducationPostUpdateOneRequiredWithoutTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostTagUncheckedUpdateInput = {
    postId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type PostTagCreateManyInput = {
    postId: string
    tagId: string
  }

  export type PostTagUpdateManyMutationInput = {

  }

  export type PostTagUncheckedUpdateManyInput = {
    postId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type EducationPostScamTypeCreateInput = {
    post: EducationPostCreateNestedOneWithoutScamTypesInput
    scamType: ScamTypeCreateNestedOneWithoutPostLinksInput
  }

  export type EducationPostScamTypeUncheckedCreateInput = {
    postId: string
    scamTypeId: string
  }

  export type EducationPostScamTypeUpdateInput = {
    post?: EducationPostUpdateOneRequiredWithoutScamTypesNestedInput
    scamType?: ScamTypeUpdateOneRequiredWithoutPostLinksNestedInput
  }

  export type EducationPostScamTypeUncheckedUpdateInput = {
    postId?: StringFieldUpdateOperationsInput | string
    scamTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type EducationPostScamTypeCreateManyInput = {
    postId: string
    scamTypeId: string
  }

  export type EducationPostScamTypeUpdateManyMutationInput = {

  }

  export type EducationPostScamTypeUncheckedUpdateManyInput = {
    postId?: StringFieldUpdateOperationsInput | string
    scamTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orgName: string
    category: $Enums.ContactCategory
    description?: string | null
    website?: string | null
    phone?: string | null
    email?: string | null
    submitUrl?: string | null
    languageCodes?: ContactCreatelanguageCodesInput | string[]
    country?: string | null
    region?: string | null
    city?: string | null
    status?: $Enums.ContactStatus
    verified?: boolean
    source?: string | null
    lastVerifiedAt?: Date | string | null
    createdById?: string | null
    scamTypes?: ContactScamTypeCreateNestedManyWithoutContactInput
    tags?: ContactTagCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orgName: string
    category: $Enums.ContactCategory
    description?: string | null
    website?: string | null
    phone?: string | null
    email?: string | null
    submitUrl?: string | null
    languageCodes?: ContactCreatelanguageCodesInput | string[]
    country?: string | null
    region?: string | null
    city?: string | null
    status?: $Enums.ContactStatus
    verified?: boolean
    source?: string | null
    lastVerifiedAt?: Date | string | null
    createdById?: string | null
    scamTypes?: ContactScamTypeUncheckedCreateNestedManyWithoutContactInput
    tags?: ContactTagUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orgName?: StringFieldUpdateOperationsInput | string
    category?: EnumContactCategoryFieldUpdateOperationsInput | $Enums.ContactCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    submitUrl?: NullableStringFieldUpdateOperationsInput | string | null
    languageCodes?: ContactUpdatelanguageCodesInput | string[]
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    verified?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    lastVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    scamTypes?: ContactScamTypeUpdateManyWithoutContactNestedInput
    tags?: ContactTagUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orgName?: StringFieldUpdateOperationsInput | string
    category?: EnumContactCategoryFieldUpdateOperationsInput | $Enums.ContactCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    submitUrl?: NullableStringFieldUpdateOperationsInput | string | null
    languageCodes?: ContactUpdatelanguageCodesInput | string[]
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    verified?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    lastVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    scamTypes?: ContactScamTypeUncheckedUpdateManyWithoutContactNestedInput
    tags?: ContactTagUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orgName: string
    category: $Enums.ContactCategory
    description?: string | null
    website?: string | null
    phone?: string | null
    email?: string | null
    submitUrl?: string | null
    languageCodes?: ContactCreatelanguageCodesInput | string[]
    country?: string | null
    region?: string | null
    city?: string | null
    status?: $Enums.ContactStatus
    verified?: boolean
    source?: string | null
    lastVerifiedAt?: Date | string | null
    createdById?: string | null
  }

  export type ContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orgName?: StringFieldUpdateOperationsInput | string
    category?: EnumContactCategoryFieldUpdateOperationsInput | $Enums.ContactCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    submitUrl?: NullableStringFieldUpdateOperationsInput | string | null
    languageCodes?: ContactUpdatelanguageCodesInput | string[]
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    verified?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    lastVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orgName?: StringFieldUpdateOperationsInput | string
    category?: EnumContactCategoryFieldUpdateOperationsInput | $Enums.ContactCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    submitUrl?: NullableStringFieldUpdateOperationsInput | string | null
    languageCodes?: ContactUpdatelanguageCodesInput | string[]
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    verified?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    lastVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactScamTypeCreateInput = {
    contact: ContactCreateNestedOneWithoutScamTypesInput
    scamType: ScamTypeCreateNestedOneWithoutContactLinksInput
  }

  export type ContactScamTypeUncheckedCreateInput = {
    contactId: string
    scamTypeId: string
  }

  export type ContactScamTypeUpdateInput = {
    contact?: ContactUpdateOneRequiredWithoutScamTypesNestedInput
    scamType?: ScamTypeUpdateOneRequiredWithoutContactLinksNestedInput
  }

  export type ContactScamTypeUncheckedUpdateInput = {
    contactId?: StringFieldUpdateOperationsInput | string
    scamTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactScamTypeCreateManyInput = {
    contactId: string
    scamTypeId: string
  }

  export type ContactScamTypeUpdateManyMutationInput = {

  }

  export type ContactScamTypeUncheckedUpdateManyInput = {
    contactId?: StringFieldUpdateOperationsInput | string
    scamTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactTagCreateInput = {
    contact: ContactCreateNestedOneWithoutTagsInput
    tag: TagCreateNestedOneWithoutContactsInput
  }

  export type ContactTagUncheckedCreateInput = {
    contactId: string
    tagId: string
  }

  export type ContactTagUpdateInput = {
    contact?: ContactUpdateOneRequiredWithoutTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutContactsNestedInput
  }

  export type ContactTagUncheckedUpdateInput = {
    contactId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactTagCreateManyInput = {
    contactId: string
    tagId: string
  }

  export type ContactTagUpdateManyMutationInput = {

  }

  export type ContactTagUncheckedUpdateManyInput = {
    contactId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type FlagListRelationFilter = {
    every?: FlagWhereInput
    some?: FlagWhereInput
    none?: FlagWhereInput
  }

  export type ScamTypeNullableScalarRelationFilter = {
    is?: ScamTypeWhereInput | null
    isNot?: ScamTypeWhereInput | null
  }

  export type VoteListRelationFilter = {
    every?: VoteWhereInput
    some?: VoteWhereInput
    none?: VoteWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FlagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScamReportCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    scammerDetails?: SortOrder
    city?: SortOrder
    country?: SortOrder
    region?: SortOrder
    ipHash?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    verified?: SortOrder
    trustScore?: SortOrder
    reportCount?: SortOrder
    reporterName?: SortOrder
    reporterEmail?: SortOrder
    anonymous?: SortOrder
    outcome?: SortOrder
    screenshots?: SortOrder
    evidence?: SortOrder
    scamTypeId?: SortOrder
    source?: SortOrder
  }

  export type ScamReportAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    trustScore?: SortOrder
    reportCount?: SortOrder
  }

  export type ScamReportMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    city?: SortOrder
    country?: SortOrder
    region?: SortOrder
    ipHash?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    verified?: SortOrder
    trustScore?: SortOrder
    reportCount?: SortOrder
    reporterName?: SortOrder
    reporterEmail?: SortOrder
    anonymous?: SortOrder
    screenshots?: SortOrder
    evidence?: SortOrder
    scamTypeId?: SortOrder
    source?: SortOrder
  }

  export type ScamReportMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    description?: SortOrder
    city?: SortOrder
    country?: SortOrder
    region?: SortOrder
    ipHash?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    verified?: SortOrder
    trustScore?: SortOrder
    reportCount?: SortOrder
    reporterName?: SortOrder
    reporterEmail?: SortOrder
    anonymous?: SortOrder
    screenshots?: SortOrder
    evidence?: SortOrder
    scamTypeId?: SortOrder
    source?: SortOrder
  }

  export type ScamReportSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    trustScore?: SortOrder
    reportCount?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type CommentNullableScalarRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type ScamReportScalarRelationFilter = {
    is?: ScamReportWhereInput
    isNot?: ScamReportWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    content?: SortOrder
    reportId?: SortOrder
    parentId?: SortOrder
    userId?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    content?: SortOrder
    reportId?: SortOrder
    parentId?: SortOrder
    userId?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    content?: SortOrder
    reportId?: SortOrder
    parentId?: SortOrder
    userId?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type VoteReportIdUserIdCompoundUniqueInput = {
    reportId: string
    userId: string
  }

  export type VoteCountOrderByAggregateInput = {
    id?: SortOrder
    reportId?: SortOrder
    userId?: SortOrder
    voteType?: SortOrder
  }

  export type VoteMaxOrderByAggregateInput = {
    id?: SortOrder
    reportId?: SortOrder
    userId?: SortOrder
    voteType?: SortOrder
  }

  export type VoteMinOrderByAggregateInput = {
    id?: SortOrder
    reportId?: SortOrder
    userId?: SortOrder
    voteType?: SortOrder
  }

  export type WikiPageCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    category?: SortOrder
    country?: SortOrder
    views?: SortOrder
    featured?: SortOrder
  }

  export type WikiPageAvgOrderByAggregateInput = {
    views?: SortOrder
  }

  export type WikiPageMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    category?: SortOrder
    country?: SortOrder
    views?: SortOrder
    featured?: SortOrder
  }

  export type WikiPageMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    category?: SortOrder
    country?: SortOrder
    views?: SortOrder
    featured?: SortOrder
  }

  export type WikiPageSumOrderByAggregateInput = {
    views?: SortOrder
  }

  export type SearchCacheCountOrderByAggregateInput = {
    id?: SortOrder
    query?: SortOrder
    results?: SortOrder
    lastUpdated?: SortOrder
    hitCount?: SortOrder
  }

  export type SearchCacheAvgOrderByAggregateInput = {
    hitCount?: SortOrder
  }

  export type SearchCacheMaxOrderByAggregateInput = {
    id?: SortOrder
    query?: SortOrder
    results?: SortOrder
    lastUpdated?: SortOrder
    hitCount?: SortOrder
  }

  export type SearchCacheMinOrderByAggregateInput = {
    id?: SortOrder
    query?: SortOrder
    results?: SortOrder
    lastUpdated?: SortOrder
    hitCount?: SortOrder
  }

  export type SearchCacheSumOrderByAggregateInput = {
    hitCount?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type AIScamReportCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    summary?: SortOrder
    averageRiskLevel?: SortOrder
    averageFinancialImpact?: SortOrder
    category?: SortOrder
  }

  export type AIScamReportAvgOrderByAggregateInput = {
    averageFinancialImpact?: SortOrder
  }

  export type AIScamReportMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    summary?: SortOrder
    averageRiskLevel?: SortOrder
    averageFinancialImpact?: SortOrder
    category?: SortOrder
  }

  export type AIScamReportMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    summary?: SortOrder
    averageRiskLevel?: SortOrder
    averageFinancialImpact?: SortOrder
    category?: SortOrder
  }

  export type AIScamReportSumOrderByAggregateInput = {
    averageFinancialImpact?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ContactScamTypeListRelationFilter = {
    every?: ContactScamTypeWhereInput
    some?: ContactScamTypeWhereInput
    none?: ContactScamTypeWhereInput
  }

  export type EducationPostScamTypeListRelationFilter = {
    every?: EducationPostScamTypeWhereInput
    some?: EducationPostScamTypeWhereInput
    none?: EducationPostScamTypeWhereInput
  }

  export type ScamReportListRelationFilter = {
    every?: ScamReportWhereInput
    some?: ScamReportWhereInput
    none?: ScamReportWhereInput
  }

  export type SeverityListRelationFilter = {
    every?: SeverityWhereInput
    some?: SeverityWhereInput
    none?: SeverityWhereInput
  }

  export type ContactScamTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EducationPostScamTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScamReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SeverityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScamTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    isApproved?: SortOrder
    isUserCreated?: SortOrder
    moderatedAt?: SortOrder
    moderatedBy?: SortOrder
  }

  export type ScamTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    isApproved?: SortOrder
    isUserCreated?: SortOrder
    moderatedAt?: SortOrder
    moderatedBy?: SortOrder
  }

  export type ScamTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    isApproved?: SortOrder
    isUserCreated?: SortOrder
    moderatedAt?: SortOrder
    moderatedBy?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ScamTypeScalarRelationFilter = {
    is?: ScamTypeWhereInput
    isNot?: ScamTypeWhereInput
  }

  export type SeverityCountOrderByAggregateInput = {
    id?: SortOrder
    scamTypeId?: SortOrder
    country?: SortOrder
    region?: SortOrder
    city?: SortOrder
    score?: SortOrder
    level?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SeverityAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type SeverityMaxOrderByAggregateInput = {
    id?: SortOrder
    scamTypeId?: SortOrder
    country?: SortOrder
    region?: SortOrder
    city?: SortOrder
    score?: SortOrder
    level?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SeverityMinOrderByAggregateInput = {
    id?: SortOrder
    scamTypeId?: SortOrder
    country?: SortOrder
    region?: SortOrder
    city?: SortOrder
    score?: SortOrder
    level?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SeveritySumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type FlagReportIdUserIdCompoundUniqueInput = {
    reportId: string
    userId: string
  }

  export type FlagCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    reportId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
  }

  export type FlagMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    reportId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
  }

  export type FlagMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    reportId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    name?: SortOrder
    image?: SortOrder
    notificationSettings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    name?: SortOrder
    image?: SortOrder
    notificationSettings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    name?: SortOrder
    image?: SortOrder
    notificationSettings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    data?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    data?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    data?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type OutcomeTypeCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutcomeTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutcomeTypeMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    label?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPostStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusFilter<$PrismaModel> | $Enums.PostStatus
  }

  export type EnumPostCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.PostCategory | EnumPostCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PostCategory[] | ListEnumPostCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostCategory[] | ListEnumPostCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPostCategoryFilter<$PrismaModel> | $Enums.PostCategory
  }

  export type PostTagListRelationFilter = {
    every?: PostTagWhereInput
    some?: PostTagWhereInput
    none?: PostTagWhereInput
  }

  export type PostTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EducationPostCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    excerpt?: SortOrder
    bodyMd?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    category?: SortOrder
    heroImageUrl?: SortOrder
    heroSvg?: SortOrder
    heroAlt?: SortOrder
    country?: SortOrder
    region?: SortOrder
    city?: SortOrder
    canonicalUrl?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    featured?: SortOrder
    authorName?: SortOrder
    sourceUrl?: SortOrder
  }

  export type EducationPostMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    excerpt?: SortOrder
    bodyMd?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    category?: SortOrder
    heroImageUrl?: SortOrder
    heroSvg?: SortOrder
    heroAlt?: SortOrder
    country?: SortOrder
    region?: SortOrder
    city?: SortOrder
    canonicalUrl?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    featured?: SortOrder
    authorName?: SortOrder
    sourceUrl?: SortOrder
  }

  export type EducationPostMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    excerpt?: SortOrder
    bodyMd?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    category?: SortOrder
    heroImageUrl?: SortOrder
    heroSvg?: SortOrder
    heroAlt?: SortOrder
    country?: SortOrder
    region?: SortOrder
    city?: SortOrder
    canonicalUrl?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    featured?: SortOrder
    authorName?: SortOrder
    sourceUrl?: SortOrder
  }

  export type EnumPostStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusWithAggregatesFilter<$PrismaModel> | $Enums.PostStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostStatusFilter<$PrismaModel>
    _max?: NestedEnumPostStatusFilter<$PrismaModel>
  }

  export type EnumPostCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostCategory | EnumPostCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PostCategory[] | ListEnumPostCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostCategory[] | ListEnumPostCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPostCategoryWithAggregatesFilter<$PrismaModel> | $Enums.PostCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostCategoryFilter<$PrismaModel>
    _max?: NestedEnumPostCategoryFilter<$PrismaModel>
  }

  export type ContactTagListRelationFilter = {
    every?: ContactTagWhereInput
    some?: ContactTagWhereInput
    none?: ContactTagWhereInput
  }

  export type ContactTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type EducationPostScalarRelationFilter = {
    is?: EducationPostWhereInput
    isNot?: EducationPostWhereInput
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type PostTagPostIdTagIdCompoundUniqueInput = {
    postId: string
    tagId: string
  }

  export type PostTagCountOrderByAggregateInput = {
    postId?: SortOrder
    tagId?: SortOrder
  }

  export type PostTagMaxOrderByAggregateInput = {
    postId?: SortOrder
    tagId?: SortOrder
  }

  export type PostTagMinOrderByAggregateInput = {
    postId?: SortOrder
    tagId?: SortOrder
  }

  export type EducationPostScamTypePostIdScamTypeIdCompoundUniqueInput = {
    postId: string
    scamTypeId: string
  }

  export type EducationPostScamTypeCountOrderByAggregateInput = {
    postId?: SortOrder
    scamTypeId?: SortOrder
  }

  export type EducationPostScamTypeMaxOrderByAggregateInput = {
    postId?: SortOrder
    scamTypeId?: SortOrder
  }

  export type EducationPostScamTypeMinOrderByAggregateInput = {
    postId?: SortOrder
    scamTypeId?: SortOrder
  }

  export type EnumContactCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactCategory | EnumContactCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ContactCategory[] | ListEnumContactCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactCategory[] | ListEnumContactCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumContactCategoryFilter<$PrismaModel> | $Enums.ContactCategory
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumContactStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactStatus | EnumContactStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContactStatus[] | ListEnumContactStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactStatus[] | ListEnumContactStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContactStatusFilter<$PrismaModel> | $Enums.ContactStatus
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orgName?: SortOrder
    category?: SortOrder
    description?: SortOrder
    website?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    submitUrl?: SortOrder
    languageCodes?: SortOrder
    country?: SortOrder
    region?: SortOrder
    city?: SortOrder
    status?: SortOrder
    verified?: SortOrder
    source?: SortOrder
    lastVerifiedAt?: SortOrder
    createdById?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orgName?: SortOrder
    category?: SortOrder
    description?: SortOrder
    website?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    submitUrl?: SortOrder
    country?: SortOrder
    region?: SortOrder
    city?: SortOrder
    status?: SortOrder
    verified?: SortOrder
    source?: SortOrder
    lastVerifiedAt?: SortOrder
    createdById?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orgName?: SortOrder
    category?: SortOrder
    description?: SortOrder
    website?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    submitUrl?: SortOrder
    country?: SortOrder
    region?: SortOrder
    city?: SortOrder
    status?: SortOrder
    verified?: SortOrder
    source?: SortOrder
    lastVerifiedAt?: SortOrder
    createdById?: SortOrder
  }

  export type EnumContactCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactCategory | EnumContactCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ContactCategory[] | ListEnumContactCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactCategory[] | ListEnumContactCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumContactCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ContactCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactCategoryFilter<$PrismaModel>
    _max?: NestedEnumContactCategoryFilter<$PrismaModel>
  }

  export type EnumContactStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactStatus | EnumContactStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContactStatus[] | ListEnumContactStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactStatus[] | ListEnumContactStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContactStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContactStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactStatusFilter<$PrismaModel>
    _max?: NestedEnumContactStatusFilter<$PrismaModel>
  }

  export type ContactScalarRelationFilter = {
    is?: ContactWhereInput
    isNot?: ContactWhereInput
  }

  export type ContactScamTypeContactIdScamTypeIdCompoundUniqueInput = {
    contactId: string
    scamTypeId: string
  }

  export type ContactScamTypeCountOrderByAggregateInput = {
    contactId?: SortOrder
    scamTypeId?: SortOrder
  }

  export type ContactScamTypeMaxOrderByAggregateInput = {
    contactId?: SortOrder
    scamTypeId?: SortOrder
  }

  export type ContactScamTypeMinOrderByAggregateInput = {
    contactId?: SortOrder
    scamTypeId?: SortOrder
  }

  export type ContactTagContactIdTagIdCompoundUniqueInput = {
    contactId: string
    tagId: string
  }

  export type ContactTagCountOrderByAggregateInput = {
    contactId?: SortOrder
    tagId?: SortOrder
  }

  export type ContactTagMaxOrderByAggregateInput = {
    contactId?: SortOrder
    tagId?: SortOrder
  }

  export type ContactTagMinOrderByAggregateInput = {
    contactId?: SortOrder
    tagId?: SortOrder
  }

  export type CommentCreateNestedManyWithoutReportInput = {
    create?: XOR<CommentCreateWithoutReportInput, CommentUncheckedCreateWithoutReportInput> | CommentCreateWithoutReportInput[] | CommentUncheckedCreateWithoutReportInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutReportInput | CommentCreateOrConnectWithoutReportInput[]
    createMany?: CommentCreateManyReportInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type FlagCreateNestedManyWithoutReportInput = {
    create?: XOR<FlagCreateWithoutReportInput, FlagUncheckedCreateWithoutReportInput> | FlagCreateWithoutReportInput[] | FlagUncheckedCreateWithoutReportInput[]
    connectOrCreate?: FlagCreateOrConnectWithoutReportInput | FlagCreateOrConnectWithoutReportInput[]
    createMany?: FlagCreateManyReportInputEnvelope
    connect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
  }

  export type ScamTypeCreateNestedOneWithoutReportsInput = {
    create?: XOR<ScamTypeCreateWithoutReportsInput, ScamTypeUncheckedCreateWithoutReportsInput>
    connectOrCreate?: ScamTypeCreateOrConnectWithoutReportsInput
    connect?: ScamTypeWhereUniqueInput
  }

  export type VoteCreateNestedManyWithoutReportInput = {
    create?: XOR<VoteCreateWithoutReportInput, VoteUncheckedCreateWithoutReportInput> | VoteCreateWithoutReportInput[] | VoteUncheckedCreateWithoutReportInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutReportInput | VoteCreateOrConnectWithoutReportInput[]
    createMany?: VoteCreateManyReportInputEnvelope
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutReportInput = {
    create?: XOR<CommentCreateWithoutReportInput, CommentUncheckedCreateWithoutReportInput> | CommentCreateWithoutReportInput[] | CommentUncheckedCreateWithoutReportInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutReportInput | CommentCreateOrConnectWithoutReportInput[]
    createMany?: CommentCreateManyReportInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type FlagUncheckedCreateNestedManyWithoutReportInput = {
    create?: XOR<FlagCreateWithoutReportInput, FlagUncheckedCreateWithoutReportInput> | FlagCreateWithoutReportInput[] | FlagUncheckedCreateWithoutReportInput[]
    connectOrCreate?: FlagCreateOrConnectWithoutReportInput | FlagCreateOrConnectWithoutReportInput[]
    createMany?: FlagCreateManyReportInputEnvelope
    connect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
  }

  export type VoteUncheckedCreateNestedManyWithoutReportInput = {
    create?: XOR<VoteCreateWithoutReportInput, VoteUncheckedCreateWithoutReportInput> | VoteCreateWithoutReportInput[] | VoteUncheckedCreateWithoutReportInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutReportInput | VoteCreateOrConnectWithoutReportInput[]
    createMany?: VoteCreateManyReportInputEnvelope
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CommentUpdateManyWithoutReportNestedInput = {
    create?: XOR<CommentCreateWithoutReportInput, CommentUncheckedCreateWithoutReportInput> | CommentCreateWithoutReportInput[] | CommentUncheckedCreateWithoutReportInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutReportInput | CommentCreateOrConnectWithoutReportInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutReportInput | CommentUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: CommentCreateManyReportInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutReportInput | CommentUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutReportInput | CommentUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type FlagUpdateManyWithoutReportNestedInput = {
    create?: XOR<FlagCreateWithoutReportInput, FlagUncheckedCreateWithoutReportInput> | FlagCreateWithoutReportInput[] | FlagUncheckedCreateWithoutReportInput[]
    connectOrCreate?: FlagCreateOrConnectWithoutReportInput | FlagCreateOrConnectWithoutReportInput[]
    upsert?: FlagUpsertWithWhereUniqueWithoutReportInput | FlagUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: FlagCreateManyReportInputEnvelope
    set?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    disconnect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    delete?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    connect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    update?: FlagUpdateWithWhereUniqueWithoutReportInput | FlagUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: FlagUpdateManyWithWhereWithoutReportInput | FlagUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: FlagScalarWhereInput | FlagScalarWhereInput[]
  }

  export type ScamTypeUpdateOneWithoutReportsNestedInput = {
    create?: XOR<ScamTypeCreateWithoutReportsInput, ScamTypeUncheckedCreateWithoutReportsInput>
    connectOrCreate?: ScamTypeCreateOrConnectWithoutReportsInput
    upsert?: ScamTypeUpsertWithoutReportsInput
    disconnect?: ScamTypeWhereInput | boolean
    delete?: ScamTypeWhereInput | boolean
    connect?: ScamTypeWhereUniqueInput
    update?: XOR<XOR<ScamTypeUpdateToOneWithWhereWithoutReportsInput, ScamTypeUpdateWithoutReportsInput>, ScamTypeUncheckedUpdateWithoutReportsInput>
  }

  export type VoteUpdateManyWithoutReportNestedInput = {
    create?: XOR<VoteCreateWithoutReportInput, VoteUncheckedCreateWithoutReportInput> | VoteCreateWithoutReportInput[] | VoteUncheckedCreateWithoutReportInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutReportInput | VoteCreateOrConnectWithoutReportInput[]
    upsert?: VoteUpsertWithWhereUniqueWithoutReportInput | VoteUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: VoteCreateManyReportInputEnvelope
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    update?: VoteUpdateWithWhereUniqueWithoutReportInput | VoteUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: VoteUpdateManyWithWhereWithoutReportInput | VoteUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutReportNestedInput = {
    create?: XOR<CommentCreateWithoutReportInput, CommentUncheckedCreateWithoutReportInput> | CommentCreateWithoutReportInput[] | CommentUncheckedCreateWithoutReportInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutReportInput | CommentCreateOrConnectWithoutReportInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutReportInput | CommentUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: CommentCreateManyReportInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutReportInput | CommentUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutReportInput | CommentUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type FlagUncheckedUpdateManyWithoutReportNestedInput = {
    create?: XOR<FlagCreateWithoutReportInput, FlagUncheckedCreateWithoutReportInput> | FlagCreateWithoutReportInput[] | FlagUncheckedCreateWithoutReportInput[]
    connectOrCreate?: FlagCreateOrConnectWithoutReportInput | FlagCreateOrConnectWithoutReportInput[]
    upsert?: FlagUpsertWithWhereUniqueWithoutReportInput | FlagUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: FlagCreateManyReportInputEnvelope
    set?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    disconnect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    delete?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    connect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    update?: FlagUpdateWithWhereUniqueWithoutReportInput | FlagUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: FlagUpdateManyWithWhereWithoutReportInput | FlagUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: FlagScalarWhereInput | FlagScalarWhereInput[]
  }

  export type VoteUncheckedUpdateManyWithoutReportNestedInput = {
    create?: XOR<VoteCreateWithoutReportInput, VoteUncheckedCreateWithoutReportInput> | VoteCreateWithoutReportInput[] | VoteUncheckedCreateWithoutReportInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutReportInput | VoteCreateOrConnectWithoutReportInput[]
    upsert?: VoteUpsertWithWhereUniqueWithoutReportInput | VoteUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: VoteCreateManyReportInputEnvelope
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    update?: VoteUpdateWithWhereUniqueWithoutReportInput | VoteUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: VoteUpdateManyWithWhereWithoutReportInput | VoteUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[]
  }

  export type CommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ScamReportCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ScamReportCreateWithoutCommentsInput, ScamReportUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ScamReportCreateOrConnectWithoutCommentsInput
    connect?: ScamReportWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type CommentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    upsert?: CommentUpsertWithoutRepliesInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutRepliesInput, CommentUpdateWithoutRepliesInput>, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ScamReportUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<ScamReportCreateWithoutCommentsInput, ScamReportUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ScamReportCreateOrConnectWithoutCommentsInput
    upsert?: ScamReportUpsertWithoutCommentsInput
    connect?: ScamReportWhereUniqueInput
    update?: XOR<XOR<ScamReportUpdateToOneWithWhereWithoutCommentsInput, ScamReportUpdateWithoutCommentsInput>, ScamReportUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type CommentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ScamReportCreateNestedOneWithoutVotesInput = {
    create?: XOR<ScamReportCreateWithoutVotesInput, ScamReportUncheckedCreateWithoutVotesInput>
    connectOrCreate?: ScamReportCreateOrConnectWithoutVotesInput
    connect?: ScamReportWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutVotesInput = {
    create?: XOR<UserCreateWithoutVotesInput, UserUncheckedCreateWithoutVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutVotesInput
    connect?: UserWhereUniqueInput
  }

  export type ScamReportUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<ScamReportCreateWithoutVotesInput, ScamReportUncheckedCreateWithoutVotesInput>
    connectOrCreate?: ScamReportCreateOrConnectWithoutVotesInput
    upsert?: ScamReportUpsertWithoutVotesInput
    connect?: ScamReportWhereUniqueInput
    update?: XOR<XOR<ScamReportUpdateToOneWithWhereWithoutVotesInput, ScamReportUpdateWithoutVotesInput>, ScamReportUncheckedUpdateWithoutVotesInput>
  }

  export type UserUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<UserCreateWithoutVotesInput, UserUncheckedCreateWithoutVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutVotesInput
    upsert?: UserUpsertWithoutVotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVotesInput, UserUpdateWithoutVotesInput>, UserUncheckedUpdateWithoutVotesInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ContactScamTypeCreateNestedManyWithoutScamTypeInput = {
    create?: XOR<ContactScamTypeCreateWithoutScamTypeInput, ContactScamTypeUncheckedCreateWithoutScamTypeInput> | ContactScamTypeCreateWithoutScamTypeInput[] | ContactScamTypeUncheckedCreateWithoutScamTypeInput[]
    connectOrCreate?: ContactScamTypeCreateOrConnectWithoutScamTypeInput | ContactScamTypeCreateOrConnectWithoutScamTypeInput[]
    createMany?: ContactScamTypeCreateManyScamTypeInputEnvelope
    connect?: ContactScamTypeWhereUniqueInput | ContactScamTypeWhereUniqueInput[]
  }

  export type EducationPostScamTypeCreateNestedManyWithoutScamTypeInput = {
    create?: XOR<EducationPostScamTypeCreateWithoutScamTypeInput, EducationPostScamTypeUncheckedCreateWithoutScamTypeInput> | EducationPostScamTypeCreateWithoutScamTypeInput[] | EducationPostScamTypeUncheckedCreateWithoutScamTypeInput[]
    connectOrCreate?: EducationPostScamTypeCreateOrConnectWithoutScamTypeInput | EducationPostScamTypeCreateOrConnectWithoutScamTypeInput[]
    createMany?: EducationPostScamTypeCreateManyScamTypeInputEnvelope
    connect?: EducationPostScamTypeWhereUniqueInput | EducationPostScamTypeWhereUniqueInput[]
  }

  export type ScamReportCreateNestedManyWithoutScamTypeInput = {
    create?: XOR<ScamReportCreateWithoutScamTypeInput, ScamReportUncheckedCreateWithoutScamTypeInput> | ScamReportCreateWithoutScamTypeInput[] | ScamReportUncheckedCreateWithoutScamTypeInput[]
    connectOrCreate?: ScamReportCreateOrConnectWithoutScamTypeInput | ScamReportCreateOrConnectWithoutScamTypeInput[]
    createMany?: ScamReportCreateManyScamTypeInputEnvelope
    connect?: ScamReportWhereUniqueInput | ScamReportWhereUniqueInput[]
  }

  export type SeverityCreateNestedManyWithoutScamTypeInput = {
    create?: XOR<SeverityCreateWithoutScamTypeInput, SeverityUncheckedCreateWithoutScamTypeInput> | SeverityCreateWithoutScamTypeInput[] | SeverityUncheckedCreateWithoutScamTypeInput[]
    connectOrCreate?: SeverityCreateOrConnectWithoutScamTypeInput | SeverityCreateOrConnectWithoutScamTypeInput[]
    createMany?: SeverityCreateManyScamTypeInputEnvelope
    connect?: SeverityWhereUniqueInput | SeverityWhereUniqueInput[]
  }

  export type ContactScamTypeUncheckedCreateNestedManyWithoutScamTypeInput = {
    create?: XOR<ContactScamTypeCreateWithoutScamTypeInput, ContactScamTypeUncheckedCreateWithoutScamTypeInput> | ContactScamTypeCreateWithoutScamTypeInput[] | ContactScamTypeUncheckedCreateWithoutScamTypeInput[]
    connectOrCreate?: ContactScamTypeCreateOrConnectWithoutScamTypeInput | ContactScamTypeCreateOrConnectWithoutScamTypeInput[]
    createMany?: ContactScamTypeCreateManyScamTypeInputEnvelope
    connect?: ContactScamTypeWhereUniqueInput | ContactScamTypeWhereUniqueInput[]
  }

  export type EducationPostScamTypeUncheckedCreateNestedManyWithoutScamTypeInput = {
    create?: XOR<EducationPostScamTypeCreateWithoutScamTypeInput, EducationPostScamTypeUncheckedCreateWithoutScamTypeInput> | EducationPostScamTypeCreateWithoutScamTypeInput[] | EducationPostScamTypeUncheckedCreateWithoutScamTypeInput[]
    connectOrCreate?: EducationPostScamTypeCreateOrConnectWithoutScamTypeInput | EducationPostScamTypeCreateOrConnectWithoutScamTypeInput[]
    createMany?: EducationPostScamTypeCreateManyScamTypeInputEnvelope
    connect?: EducationPostScamTypeWhereUniqueInput | EducationPostScamTypeWhereUniqueInput[]
  }

  export type ScamReportUncheckedCreateNestedManyWithoutScamTypeInput = {
    create?: XOR<ScamReportCreateWithoutScamTypeInput, ScamReportUncheckedCreateWithoutScamTypeInput> | ScamReportCreateWithoutScamTypeInput[] | ScamReportUncheckedCreateWithoutScamTypeInput[]
    connectOrCreate?: ScamReportCreateOrConnectWithoutScamTypeInput | ScamReportCreateOrConnectWithoutScamTypeInput[]
    createMany?: ScamReportCreateManyScamTypeInputEnvelope
    connect?: ScamReportWhereUniqueInput | ScamReportWhereUniqueInput[]
  }

  export type SeverityUncheckedCreateNestedManyWithoutScamTypeInput = {
    create?: XOR<SeverityCreateWithoutScamTypeInput, SeverityUncheckedCreateWithoutScamTypeInput> | SeverityCreateWithoutScamTypeInput[] | SeverityUncheckedCreateWithoutScamTypeInput[]
    connectOrCreate?: SeverityCreateOrConnectWithoutScamTypeInput | SeverityCreateOrConnectWithoutScamTypeInput[]
    createMany?: SeverityCreateManyScamTypeInputEnvelope
    connect?: SeverityWhereUniqueInput | SeverityWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ContactScamTypeUpdateManyWithoutScamTypeNestedInput = {
    create?: XOR<ContactScamTypeCreateWithoutScamTypeInput, ContactScamTypeUncheckedCreateWithoutScamTypeInput> | ContactScamTypeCreateWithoutScamTypeInput[] | ContactScamTypeUncheckedCreateWithoutScamTypeInput[]
    connectOrCreate?: ContactScamTypeCreateOrConnectWithoutScamTypeInput | ContactScamTypeCreateOrConnectWithoutScamTypeInput[]
    upsert?: ContactScamTypeUpsertWithWhereUniqueWithoutScamTypeInput | ContactScamTypeUpsertWithWhereUniqueWithoutScamTypeInput[]
    createMany?: ContactScamTypeCreateManyScamTypeInputEnvelope
    set?: ContactScamTypeWhereUniqueInput | ContactScamTypeWhereUniqueInput[]
    disconnect?: ContactScamTypeWhereUniqueInput | ContactScamTypeWhereUniqueInput[]
    delete?: ContactScamTypeWhereUniqueInput | ContactScamTypeWhereUniqueInput[]
    connect?: ContactScamTypeWhereUniqueInput | ContactScamTypeWhereUniqueInput[]
    update?: ContactScamTypeUpdateWithWhereUniqueWithoutScamTypeInput | ContactScamTypeUpdateWithWhereUniqueWithoutScamTypeInput[]
    updateMany?: ContactScamTypeUpdateManyWithWhereWithoutScamTypeInput | ContactScamTypeUpdateManyWithWhereWithoutScamTypeInput[]
    deleteMany?: ContactScamTypeScalarWhereInput | ContactScamTypeScalarWhereInput[]
  }

  export type EducationPostScamTypeUpdateManyWithoutScamTypeNestedInput = {
    create?: XOR<EducationPostScamTypeCreateWithoutScamTypeInput, EducationPostScamTypeUncheckedCreateWithoutScamTypeInput> | EducationPostScamTypeCreateWithoutScamTypeInput[] | EducationPostScamTypeUncheckedCreateWithoutScamTypeInput[]
    connectOrCreate?: EducationPostScamTypeCreateOrConnectWithoutScamTypeInput | EducationPostScamTypeCreateOrConnectWithoutScamTypeInput[]
    upsert?: EducationPostScamTypeUpsertWithWhereUniqueWithoutScamTypeInput | EducationPostScamTypeUpsertWithWhereUniqueWithoutScamTypeInput[]
    createMany?: EducationPostScamTypeCreateManyScamTypeInputEnvelope
    set?: EducationPostScamTypeWhereUniqueInput | EducationPostScamTypeWhereUniqueInput[]
    disconnect?: EducationPostScamTypeWhereUniqueInput | EducationPostScamTypeWhereUniqueInput[]
    delete?: EducationPostScamTypeWhereUniqueInput | EducationPostScamTypeWhereUniqueInput[]
    connect?: EducationPostScamTypeWhereUniqueInput | EducationPostScamTypeWhereUniqueInput[]
    update?: EducationPostScamTypeUpdateWithWhereUniqueWithoutScamTypeInput | EducationPostScamTypeUpdateWithWhereUniqueWithoutScamTypeInput[]
    updateMany?: EducationPostScamTypeUpdateManyWithWhereWithoutScamTypeInput | EducationPostScamTypeUpdateManyWithWhereWithoutScamTypeInput[]
    deleteMany?: EducationPostScamTypeScalarWhereInput | EducationPostScamTypeScalarWhereInput[]
  }

  export type ScamReportUpdateManyWithoutScamTypeNestedInput = {
    create?: XOR<ScamReportCreateWithoutScamTypeInput, ScamReportUncheckedCreateWithoutScamTypeInput> | ScamReportCreateWithoutScamTypeInput[] | ScamReportUncheckedCreateWithoutScamTypeInput[]
    connectOrCreate?: ScamReportCreateOrConnectWithoutScamTypeInput | ScamReportCreateOrConnectWithoutScamTypeInput[]
    upsert?: ScamReportUpsertWithWhereUniqueWithoutScamTypeInput | ScamReportUpsertWithWhereUniqueWithoutScamTypeInput[]
    createMany?: ScamReportCreateManyScamTypeInputEnvelope
    set?: ScamReportWhereUniqueInput | ScamReportWhereUniqueInput[]
    disconnect?: ScamReportWhereUniqueInput | ScamReportWhereUniqueInput[]
    delete?: ScamReportWhereUniqueInput | ScamReportWhereUniqueInput[]
    connect?: ScamReportWhereUniqueInput | ScamReportWhereUniqueInput[]
    update?: ScamReportUpdateWithWhereUniqueWithoutScamTypeInput | ScamReportUpdateWithWhereUniqueWithoutScamTypeInput[]
    updateMany?: ScamReportUpdateManyWithWhereWithoutScamTypeInput | ScamReportUpdateManyWithWhereWithoutScamTypeInput[]
    deleteMany?: ScamReportScalarWhereInput | ScamReportScalarWhereInput[]
  }

  export type SeverityUpdateManyWithoutScamTypeNestedInput = {
    create?: XOR<SeverityCreateWithoutScamTypeInput, SeverityUncheckedCreateWithoutScamTypeInput> | SeverityCreateWithoutScamTypeInput[] | SeverityUncheckedCreateWithoutScamTypeInput[]
    connectOrCreate?: SeverityCreateOrConnectWithoutScamTypeInput | SeverityCreateOrConnectWithoutScamTypeInput[]
    upsert?: SeverityUpsertWithWhereUniqueWithoutScamTypeInput | SeverityUpsertWithWhereUniqueWithoutScamTypeInput[]
    createMany?: SeverityCreateManyScamTypeInputEnvelope
    set?: SeverityWhereUniqueInput | SeverityWhereUniqueInput[]
    disconnect?: SeverityWhereUniqueInput | SeverityWhereUniqueInput[]
    delete?: SeverityWhereUniqueInput | SeverityWhereUniqueInput[]
    connect?: SeverityWhereUniqueInput | SeverityWhereUniqueInput[]
    update?: SeverityUpdateWithWhereUniqueWithoutScamTypeInput | SeverityUpdateWithWhereUniqueWithoutScamTypeInput[]
    updateMany?: SeverityUpdateManyWithWhereWithoutScamTypeInput | SeverityUpdateManyWithWhereWithoutScamTypeInput[]
    deleteMany?: SeverityScalarWhereInput | SeverityScalarWhereInput[]
  }

  export type ContactScamTypeUncheckedUpdateManyWithoutScamTypeNestedInput = {
    create?: XOR<ContactScamTypeCreateWithoutScamTypeInput, ContactScamTypeUncheckedCreateWithoutScamTypeInput> | ContactScamTypeCreateWithoutScamTypeInput[] | ContactScamTypeUncheckedCreateWithoutScamTypeInput[]
    connectOrCreate?: ContactScamTypeCreateOrConnectWithoutScamTypeInput | ContactScamTypeCreateOrConnectWithoutScamTypeInput[]
    upsert?: ContactScamTypeUpsertWithWhereUniqueWithoutScamTypeInput | ContactScamTypeUpsertWithWhereUniqueWithoutScamTypeInput[]
    createMany?: ContactScamTypeCreateManyScamTypeInputEnvelope
    set?: ContactScamTypeWhereUniqueInput | ContactScamTypeWhereUniqueInput[]
    disconnect?: ContactScamTypeWhereUniqueInput | ContactScamTypeWhereUniqueInput[]
    delete?: ContactScamTypeWhereUniqueInput | ContactScamTypeWhereUniqueInput[]
    connect?: ContactScamTypeWhereUniqueInput | ContactScamTypeWhereUniqueInput[]
    update?: ContactScamTypeUpdateWithWhereUniqueWithoutScamTypeInput | ContactScamTypeUpdateWithWhereUniqueWithoutScamTypeInput[]
    updateMany?: ContactScamTypeUpdateManyWithWhereWithoutScamTypeInput | ContactScamTypeUpdateManyWithWhereWithoutScamTypeInput[]
    deleteMany?: ContactScamTypeScalarWhereInput | ContactScamTypeScalarWhereInput[]
  }

  export type EducationPostScamTypeUncheckedUpdateManyWithoutScamTypeNestedInput = {
    create?: XOR<EducationPostScamTypeCreateWithoutScamTypeInput, EducationPostScamTypeUncheckedCreateWithoutScamTypeInput> | EducationPostScamTypeCreateWithoutScamTypeInput[] | EducationPostScamTypeUncheckedCreateWithoutScamTypeInput[]
    connectOrCreate?: EducationPostScamTypeCreateOrConnectWithoutScamTypeInput | EducationPostScamTypeCreateOrConnectWithoutScamTypeInput[]
    upsert?: EducationPostScamTypeUpsertWithWhereUniqueWithoutScamTypeInput | EducationPostScamTypeUpsertWithWhereUniqueWithoutScamTypeInput[]
    createMany?: EducationPostScamTypeCreateManyScamTypeInputEnvelope
    set?: EducationPostScamTypeWhereUniqueInput | EducationPostScamTypeWhereUniqueInput[]
    disconnect?: EducationPostScamTypeWhereUniqueInput | EducationPostScamTypeWhereUniqueInput[]
    delete?: EducationPostScamTypeWhereUniqueInput | EducationPostScamTypeWhereUniqueInput[]
    connect?: EducationPostScamTypeWhereUniqueInput | EducationPostScamTypeWhereUniqueInput[]
    update?: EducationPostScamTypeUpdateWithWhereUniqueWithoutScamTypeInput | EducationPostScamTypeUpdateWithWhereUniqueWithoutScamTypeInput[]
    updateMany?: EducationPostScamTypeUpdateManyWithWhereWithoutScamTypeInput | EducationPostScamTypeUpdateManyWithWhereWithoutScamTypeInput[]
    deleteMany?: EducationPostScamTypeScalarWhereInput | EducationPostScamTypeScalarWhereInput[]
  }

  export type ScamReportUncheckedUpdateManyWithoutScamTypeNestedInput = {
    create?: XOR<ScamReportCreateWithoutScamTypeInput, ScamReportUncheckedCreateWithoutScamTypeInput> | ScamReportCreateWithoutScamTypeInput[] | ScamReportUncheckedCreateWithoutScamTypeInput[]
    connectOrCreate?: ScamReportCreateOrConnectWithoutScamTypeInput | ScamReportCreateOrConnectWithoutScamTypeInput[]
    upsert?: ScamReportUpsertWithWhereUniqueWithoutScamTypeInput | ScamReportUpsertWithWhereUniqueWithoutScamTypeInput[]
    createMany?: ScamReportCreateManyScamTypeInputEnvelope
    set?: ScamReportWhereUniqueInput | ScamReportWhereUniqueInput[]
    disconnect?: ScamReportWhereUniqueInput | ScamReportWhereUniqueInput[]
    delete?: ScamReportWhereUniqueInput | ScamReportWhereUniqueInput[]
    connect?: ScamReportWhereUniqueInput | ScamReportWhereUniqueInput[]
    update?: ScamReportUpdateWithWhereUniqueWithoutScamTypeInput | ScamReportUpdateWithWhereUniqueWithoutScamTypeInput[]
    updateMany?: ScamReportUpdateManyWithWhereWithoutScamTypeInput | ScamReportUpdateManyWithWhereWithoutScamTypeInput[]
    deleteMany?: ScamReportScalarWhereInput | ScamReportScalarWhereInput[]
  }

  export type SeverityUncheckedUpdateManyWithoutScamTypeNestedInput = {
    create?: XOR<SeverityCreateWithoutScamTypeInput, SeverityUncheckedCreateWithoutScamTypeInput> | SeverityCreateWithoutScamTypeInput[] | SeverityUncheckedCreateWithoutScamTypeInput[]
    connectOrCreate?: SeverityCreateOrConnectWithoutScamTypeInput | SeverityCreateOrConnectWithoutScamTypeInput[]
    upsert?: SeverityUpsertWithWhereUniqueWithoutScamTypeInput | SeverityUpsertWithWhereUniqueWithoutScamTypeInput[]
    createMany?: SeverityCreateManyScamTypeInputEnvelope
    set?: SeverityWhereUniqueInput | SeverityWhereUniqueInput[]
    disconnect?: SeverityWhereUniqueInput | SeverityWhereUniqueInput[]
    delete?: SeverityWhereUniqueInput | SeverityWhereUniqueInput[]
    connect?: SeverityWhereUniqueInput | SeverityWhereUniqueInput[]
    update?: SeverityUpdateWithWhereUniqueWithoutScamTypeInput | SeverityUpdateWithWhereUniqueWithoutScamTypeInput[]
    updateMany?: SeverityUpdateManyWithWhereWithoutScamTypeInput | SeverityUpdateManyWithWhereWithoutScamTypeInput[]
    deleteMany?: SeverityScalarWhereInput | SeverityScalarWhereInput[]
  }

  export type ScamTypeCreateNestedOneWithoutSeverityRecordsInput = {
    create?: XOR<ScamTypeCreateWithoutSeverityRecordsInput, ScamTypeUncheckedCreateWithoutSeverityRecordsInput>
    connectOrCreate?: ScamTypeCreateOrConnectWithoutSeverityRecordsInput
    connect?: ScamTypeWhereUniqueInput
  }

  export type ScamTypeUpdateOneRequiredWithoutSeverityRecordsNestedInput = {
    create?: XOR<ScamTypeCreateWithoutSeverityRecordsInput, ScamTypeUncheckedCreateWithoutSeverityRecordsInput>
    connectOrCreate?: ScamTypeCreateOrConnectWithoutSeverityRecordsInput
    upsert?: ScamTypeUpsertWithoutSeverityRecordsInput
    connect?: ScamTypeWhereUniqueInput
    update?: XOR<XOR<ScamTypeUpdateToOneWithWhereWithoutSeverityRecordsInput, ScamTypeUpdateWithoutSeverityRecordsInput>, ScamTypeUncheckedUpdateWithoutSeverityRecordsInput>
  }

  export type ScamReportCreateNestedOneWithoutFlagsInput = {
    create?: XOR<ScamReportCreateWithoutFlagsInput, ScamReportUncheckedCreateWithoutFlagsInput>
    connectOrCreate?: ScamReportCreateOrConnectWithoutFlagsInput
    connect?: ScamReportWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFlagsInput = {
    create?: XOR<UserCreateWithoutFlagsInput, UserUncheckedCreateWithoutFlagsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFlagsInput
    connect?: UserWhereUniqueInput
  }

  export type ScamReportUpdateOneRequiredWithoutFlagsNestedInput = {
    create?: XOR<ScamReportCreateWithoutFlagsInput, ScamReportUncheckedCreateWithoutFlagsInput>
    connectOrCreate?: ScamReportCreateOrConnectWithoutFlagsInput
    upsert?: ScamReportUpsertWithoutFlagsInput
    connect?: ScamReportWhereUniqueInput
    update?: XOR<XOR<ScamReportUpdateToOneWithWhereWithoutFlagsInput, ScamReportUpdateWithoutFlagsInput>, ScamReportUncheckedUpdateWithoutFlagsInput>
  }

  export type UserUpdateOneRequiredWithoutFlagsNestedInput = {
    create?: XOR<UserCreateWithoutFlagsInput, UserUncheckedCreateWithoutFlagsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFlagsInput
    upsert?: UserUpsertWithoutFlagsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFlagsInput, UserUpdateWithoutFlagsInput>, UserUncheckedUpdateWithoutFlagsInput>
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type FlagCreateNestedManyWithoutUserInput = {
    create?: XOR<FlagCreateWithoutUserInput, FlagUncheckedCreateWithoutUserInput> | FlagCreateWithoutUserInput[] | FlagUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FlagCreateOrConnectWithoutUserInput | FlagCreateOrConnectWithoutUserInput[]
    createMany?: FlagCreateManyUserInputEnvelope
    connect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type VoteCreateNestedManyWithoutUserInput = {
    create?: XOR<VoteCreateWithoutUserInput, VoteUncheckedCreateWithoutUserInput> | VoteCreateWithoutUserInput[] | VoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutUserInput | VoteCreateOrConnectWithoutUserInput[]
    createMany?: VoteCreateManyUserInputEnvelope
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type FlagUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FlagCreateWithoutUserInput, FlagUncheckedCreateWithoutUserInput> | FlagCreateWithoutUserInput[] | FlagUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FlagCreateOrConnectWithoutUserInput | FlagCreateOrConnectWithoutUserInput[]
    createMany?: FlagCreateManyUserInputEnvelope
    connect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type VoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<VoteCreateWithoutUserInput, VoteUncheckedCreateWithoutUserInput> | VoteCreateWithoutUserInput[] | VoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutUserInput | VoteCreateOrConnectWithoutUserInput[]
    createMany?: VoteCreateManyUserInputEnvelope
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type FlagUpdateManyWithoutUserNestedInput = {
    create?: XOR<FlagCreateWithoutUserInput, FlagUncheckedCreateWithoutUserInput> | FlagCreateWithoutUserInput[] | FlagUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FlagCreateOrConnectWithoutUserInput | FlagCreateOrConnectWithoutUserInput[]
    upsert?: FlagUpsertWithWhereUniqueWithoutUserInput | FlagUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FlagCreateManyUserInputEnvelope
    set?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    disconnect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    delete?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    connect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    update?: FlagUpdateWithWhereUniqueWithoutUserInput | FlagUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FlagUpdateManyWithWhereWithoutUserInput | FlagUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FlagScalarWhereInput | FlagScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type VoteUpdateManyWithoutUserNestedInput = {
    create?: XOR<VoteCreateWithoutUserInput, VoteUncheckedCreateWithoutUserInput> | VoteCreateWithoutUserInput[] | VoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutUserInput | VoteCreateOrConnectWithoutUserInput[]
    upsert?: VoteUpsertWithWhereUniqueWithoutUserInput | VoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VoteCreateManyUserInputEnvelope
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    update?: VoteUpdateWithWhereUniqueWithoutUserInput | VoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VoteUpdateManyWithWhereWithoutUserInput | VoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type FlagUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FlagCreateWithoutUserInput, FlagUncheckedCreateWithoutUserInput> | FlagCreateWithoutUserInput[] | FlagUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FlagCreateOrConnectWithoutUserInput | FlagCreateOrConnectWithoutUserInput[]
    upsert?: FlagUpsertWithWhereUniqueWithoutUserInput | FlagUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FlagCreateManyUserInputEnvelope
    set?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    disconnect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    delete?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    connect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    update?: FlagUpdateWithWhereUniqueWithoutUserInput | FlagUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FlagUpdateManyWithWhereWithoutUserInput | FlagUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FlagScalarWhereInput | FlagScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type VoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<VoteCreateWithoutUserInput, VoteUncheckedCreateWithoutUserInput> | VoteCreateWithoutUserInput[] | VoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VoteCreateOrConnectWithoutUserInput | VoteCreateOrConnectWithoutUserInput[]
    upsert?: VoteUpsertWithWhereUniqueWithoutUserInput | VoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VoteCreateManyUserInputEnvelope
    set?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    disconnect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    delete?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    connect?: VoteWhereUniqueInput | VoteWhereUniqueInput[]
    update?: VoteUpdateWithWhereUniqueWithoutUserInput | VoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VoteUpdateManyWithWhereWithoutUserInput | VoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VoteScalarWhereInput | VoteScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type EducationPostScamTypeCreateNestedManyWithoutPostInput = {
    create?: XOR<EducationPostScamTypeCreateWithoutPostInput, EducationPostScamTypeUncheckedCreateWithoutPostInput> | EducationPostScamTypeCreateWithoutPostInput[] | EducationPostScamTypeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: EducationPostScamTypeCreateOrConnectWithoutPostInput | EducationPostScamTypeCreateOrConnectWithoutPostInput[]
    createMany?: EducationPostScamTypeCreateManyPostInputEnvelope
    connect?: EducationPostScamTypeWhereUniqueInput | EducationPostScamTypeWhereUniqueInput[]
  }

  export type PostTagCreateNestedManyWithoutPostInput = {
    create?: XOR<PostTagCreateWithoutPostInput, PostTagUncheckedCreateWithoutPostInput> | PostTagCreateWithoutPostInput[] | PostTagUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutPostInput | PostTagCreateOrConnectWithoutPostInput[]
    createMany?: PostTagCreateManyPostInputEnvelope
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
  }

  export type EducationPostScamTypeUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<EducationPostScamTypeCreateWithoutPostInput, EducationPostScamTypeUncheckedCreateWithoutPostInput> | EducationPostScamTypeCreateWithoutPostInput[] | EducationPostScamTypeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: EducationPostScamTypeCreateOrConnectWithoutPostInput | EducationPostScamTypeCreateOrConnectWithoutPostInput[]
    createMany?: EducationPostScamTypeCreateManyPostInputEnvelope
    connect?: EducationPostScamTypeWhereUniqueInput | EducationPostScamTypeWhereUniqueInput[]
  }

  export type PostTagUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostTagCreateWithoutPostInput, PostTagUncheckedCreateWithoutPostInput> | PostTagCreateWithoutPostInput[] | PostTagUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutPostInput | PostTagCreateOrConnectWithoutPostInput[]
    createMany?: PostTagCreateManyPostInputEnvelope
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
  }

  export type EnumPostStatusFieldUpdateOperationsInput = {
    set?: $Enums.PostStatus
  }

  export type EnumPostCategoryFieldUpdateOperationsInput = {
    set?: $Enums.PostCategory
  }

  export type EducationPostScamTypeUpdateManyWithoutPostNestedInput = {
    create?: XOR<EducationPostScamTypeCreateWithoutPostInput, EducationPostScamTypeUncheckedCreateWithoutPostInput> | EducationPostScamTypeCreateWithoutPostInput[] | EducationPostScamTypeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: EducationPostScamTypeCreateOrConnectWithoutPostInput | EducationPostScamTypeCreateOrConnectWithoutPostInput[]
    upsert?: EducationPostScamTypeUpsertWithWhereUniqueWithoutPostInput | EducationPostScamTypeUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: EducationPostScamTypeCreateManyPostInputEnvelope
    set?: EducationPostScamTypeWhereUniqueInput | EducationPostScamTypeWhereUniqueInput[]
    disconnect?: EducationPostScamTypeWhereUniqueInput | EducationPostScamTypeWhereUniqueInput[]
    delete?: EducationPostScamTypeWhereUniqueInput | EducationPostScamTypeWhereUniqueInput[]
    connect?: EducationPostScamTypeWhereUniqueInput | EducationPostScamTypeWhereUniqueInput[]
    update?: EducationPostScamTypeUpdateWithWhereUniqueWithoutPostInput | EducationPostScamTypeUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: EducationPostScamTypeUpdateManyWithWhereWithoutPostInput | EducationPostScamTypeUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: EducationPostScamTypeScalarWhereInput | EducationPostScamTypeScalarWhereInput[]
  }

  export type PostTagUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostTagCreateWithoutPostInput, PostTagUncheckedCreateWithoutPostInput> | PostTagCreateWithoutPostInput[] | PostTagUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutPostInput | PostTagCreateOrConnectWithoutPostInput[]
    upsert?: PostTagUpsertWithWhereUniqueWithoutPostInput | PostTagUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostTagCreateManyPostInputEnvelope
    set?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    disconnect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    delete?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    update?: PostTagUpdateWithWhereUniqueWithoutPostInput | PostTagUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostTagUpdateManyWithWhereWithoutPostInput | PostTagUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
  }

  export type EducationPostScamTypeUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<EducationPostScamTypeCreateWithoutPostInput, EducationPostScamTypeUncheckedCreateWithoutPostInput> | EducationPostScamTypeCreateWithoutPostInput[] | EducationPostScamTypeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: EducationPostScamTypeCreateOrConnectWithoutPostInput | EducationPostScamTypeCreateOrConnectWithoutPostInput[]
    upsert?: EducationPostScamTypeUpsertWithWhereUniqueWithoutPostInput | EducationPostScamTypeUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: EducationPostScamTypeCreateManyPostInputEnvelope
    set?: EducationPostScamTypeWhereUniqueInput | EducationPostScamTypeWhereUniqueInput[]
    disconnect?: EducationPostScamTypeWhereUniqueInput | EducationPostScamTypeWhereUniqueInput[]
    delete?: EducationPostScamTypeWhereUniqueInput | EducationPostScamTypeWhereUniqueInput[]
    connect?: EducationPostScamTypeWhereUniqueInput | EducationPostScamTypeWhereUniqueInput[]
    update?: EducationPostScamTypeUpdateWithWhereUniqueWithoutPostInput | EducationPostScamTypeUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: EducationPostScamTypeUpdateManyWithWhereWithoutPostInput | EducationPostScamTypeUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: EducationPostScamTypeScalarWhereInput | EducationPostScamTypeScalarWhereInput[]
  }

  export type PostTagUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostTagCreateWithoutPostInput, PostTagUncheckedCreateWithoutPostInput> | PostTagCreateWithoutPostInput[] | PostTagUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutPostInput | PostTagCreateOrConnectWithoutPostInput[]
    upsert?: PostTagUpsertWithWhereUniqueWithoutPostInput | PostTagUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostTagCreateManyPostInputEnvelope
    set?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    disconnect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    delete?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    update?: PostTagUpdateWithWhereUniqueWithoutPostInput | PostTagUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostTagUpdateManyWithWhereWithoutPostInput | PostTagUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
  }

  export type ContactTagCreateNestedManyWithoutTagInput = {
    create?: XOR<ContactTagCreateWithoutTagInput, ContactTagUncheckedCreateWithoutTagInput> | ContactTagCreateWithoutTagInput[] | ContactTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ContactTagCreateOrConnectWithoutTagInput | ContactTagCreateOrConnectWithoutTagInput[]
    createMany?: ContactTagCreateManyTagInputEnvelope
    connect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
  }

  export type PostTagCreateNestedManyWithoutTagInput = {
    create?: XOR<PostTagCreateWithoutTagInput, PostTagUncheckedCreateWithoutTagInput> | PostTagCreateWithoutTagInput[] | PostTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutTagInput | PostTagCreateOrConnectWithoutTagInput[]
    createMany?: PostTagCreateManyTagInputEnvelope
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
  }

  export type ContactTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<ContactTagCreateWithoutTagInput, ContactTagUncheckedCreateWithoutTagInput> | ContactTagCreateWithoutTagInput[] | ContactTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ContactTagCreateOrConnectWithoutTagInput | ContactTagCreateOrConnectWithoutTagInput[]
    createMany?: ContactTagCreateManyTagInputEnvelope
    connect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
  }

  export type PostTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<PostTagCreateWithoutTagInput, PostTagUncheckedCreateWithoutTagInput> | PostTagCreateWithoutTagInput[] | PostTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutTagInput | PostTagCreateOrConnectWithoutTagInput[]
    createMany?: PostTagCreateManyTagInputEnvelope
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
  }

  export type ContactTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<ContactTagCreateWithoutTagInput, ContactTagUncheckedCreateWithoutTagInput> | ContactTagCreateWithoutTagInput[] | ContactTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ContactTagCreateOrConnectWithoutTagInput | ContactTagCreateOrConnectWithoutTagInput[]
    upsert?: ContactTagUpsertWithWhereUniqueWithoutTagInput | ContactTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: ContactTagCreateManyTagInputEnvelope
    set?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    disconnect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    delete?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    connect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    update?: ContactTagUpdateWithWhereUniqueWithoutTagInput | ContactTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: ContactTagUpdateManyWithWhereWithoutTagInput | ContactTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: ContactTagScalarWhereInput | ContactTagScalarWhereInput[]
  }

  export type PostTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<PostTagCreateWithoutTagInput, PostTagUncheckedCreateWithoutTagInput> | PostTagCreateWithoutTagInput[] | PostTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutTagInput | PostTagCreateOrConnectWithoutTagInput[]
    upsert?: PostTagUpsertWithWhereUniqueWithoutTagInput | PostTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: PostTagCreateManyTagInputEnvelope
    set?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    disconnect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    delete?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    update?: PostTagUpdateWithWhereUniqueWithoutTagInput | PostTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: PostTagUpdateManyWithWhereWithoutTagInput | PostTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
  }

  export type ContactTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<ContactTagCreateWithoutTagInput, ContactTagUncheckedCreateWithoutTagInput> | ContactTagCreateWithoutTagInput[] | ContactTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ContactTagCreateOrConnectWithoutTagInput | ContactTagCreateOrConnectWithoutTagInput[]
    upsert?: ContactTagUpsertWithWhereUniqueWithoutTagInput | ContactTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: ContactTagCreateManyTagInputEnvelope
    set?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    disconnect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    delete?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    connect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    update?: ContactTagUpdateWithWhereUniqueWithoutTagInput | ContactTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: ContactTagUpdateManyWithWhereWithoutTagInput | ContactTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: ContactTagScalarWhereInput | ContactTagScalarWhereInput[]
  }

  export type PostTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<PostTagCreateWithoutTagInput, PostTagUncheckedCreateWithoutTagInput> | PostTagCreateWithoutTagInput[] | PostTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: PostTagCreateOrConnectWithoutTagInput | PostTagCreateOrConnectWithoutTagInput[]
    upsert?: PostTagUpsertWithWhereUniqueWithoutTagInput | PostTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: PostTagCreateManyTagInputEnvelope
    set?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    disconnect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    delete?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    connect?: PostTagWhereUniqueInput | PostTagWhereUniqueInput[]
    update?: PostTagUpdateWithWhereUniqueWithoutTagInput | PostTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: PostTagUpdateManyWithWhereWithoutTagInput | PostTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
  }

  export type EducationPostCreateNestedOneWithoutTagsInput = {
    create?: XOR<EducationPostCreateWithoutTagsInput, EducationPostUncheckedCreateWithoutTagsInput>
    connectOrCreate?: EducationPostCreateOrConnectWithoutTagsInput
    connect?: EducationPostWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutPostsInput = {
    create?: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput>
    connectOrCreate?: TagCreateOrConnectWithoutPostsInput
    connect?: TagWhereUniqueInput
  }

  export type EducationPostUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<EducationPostCreateWithoutTagsInput, EducationPostUncheckedCreateWithoutTagsInput>
    connectOrCreate?: EducationPostCreateOrConnectWithoutTagsInput
    upsert?: EducationPostUpsertWithoutTagsInput
    connect?: EducationPostWhereUniqueInput
    update?: XOR<XOR<EducationPostUpdateToOneWithWhereWithoutTagsInput, EducationPostUpdateWithoutTagsInput>, EducationPostUncheckedUpdateWithoutTagsInput>
  }

  export type TagUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput>
    connectOrCreate?: TagCreateOrConnectWithoutPostsInput
    upsert?: TagUpsertWithoutPostsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutPostsInput, TagUpdateWithoutPostsInput>, TagUncheckedUpdateWithoutPostsInput>
  }

  export type EducationPostCreateNestedOneWithoutScamTypesInput = {
    create?: XOR<EducationPostCreateWithoutScamTypesInput, EducationPostUncheckedCreateWithoutScamTypesInput>
    connectOrCreate?: EducationPostCreateOrConnectWithoutScamTypesInput
    connect?: EducationPostWhereUniqueInput
  }

  export type ScamTypeCreateNestedOneWithoutPostLinksInput = {
    create?: XOR<ScamTypeCreateWithoutPostLinksInput, ScamTypeUncheckedCreateWithoutPostLinksInput>
    connectOrCreate?: ScamTypeCreateOrConnectWithoutPostLinksInput
    connect?: ScamTypeWhereUniqueInput
  }

  export type EducationPostUpdateOneRequiredWithoutScamTypesNestedInput = {
    create?: XOR<EducationPostCreateWithoutScamTypesInput, EducationPostUncheckedCreateWithoutScamTypesInput>
    connectOrCreate?: EducationPostCreateOrConnectWithoutScamTypesInput
    upsert?: EducationPostUpsertWithoutScamTypesInput
    connect?: EducationPostWhereUniqueInput
    update?: XOR<XOR<EducationPostUpdateToOneWithWhereWithoutScamTypesInput, EducationPostUpdateWithoutScamTypesInput>, EducationPostUncheckedUpdateWithoutScamTypesInput>
  }

  export type ScamTypeUpdateOneRequiredWithoutPostLinksNestedInput = {
    create?: XOR<ScamTypeCreateWithoutPostLinksInput, ScamTypeUncheckedCreateWithoutPostLinksInput>
    connectOrCreate?: ScamTypeCreateOrConnectWithoutPostLinksInput
    upsert?: ScamTypeUpsertWithoutPostLinksInput
    connect?: ScamTypeWhereUniqueInput
    update?: XOR<XOR<ScamTypeUpdateToOneWithWhereWithoutPostLinksInput, ScamTypeUpdateWithoutPostLinksInput>, ScamTypeUncheckedUpdateWithoutPostLinksInput>
  }

  export type ContactCreatelanguageCodesInput = {
    set: string[]
  }

  export type ContactScamTypeCreateNestedManyWithoutContactInput = {
    create?: XOR<ContactScamTypeCreateWithoutContactInput, ContactScamTypeUncheckedCreateWithoutContactInput> | ContactScamTypeCreateWithoutContactInput[] | ContactScamTypeUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactScamTypeCreateOrConnectWithoutContactInput | ContactScamTypeCreateOrConnectWithoutContactInput[]
    createMany?: ContactScamTypeCreateManyContactInputEnvelope
    connect?: ContactScamTypeWhereUniqueInput | ContactScamTypeWhereUniqueInput[]
  }

  export type ContactTagCreateNestedManyWithoutContactInput = {
    create?: XOR<ContactTagCreateWithoutContactInput, ContactTagUncheckedCreateWithoutContactInput> | ContactTagCreateWithoutContactInput[] | ContactTagUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactTagCreateOrConnectWithoutContactInput | ContactTagCreateOrConnectWithoutContactInput[]
    createMany?: ContactTagCreateManyContactInputEnvelope
    connect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
  }

  export type ContactScamTypeUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<ContactScamTypeCreateWithoutContactInput, ContactScamTypeUncheckedCreateWithoutContactInput> | ContactScamTypeCreateWithoutContactInput[] | ContactScamTypeUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactScamTypeCreateOrConnectWithoutContactInput | ContactScamTypeCreateOrConnectWithoutContactInput[]
    createMany?: ContactScamTypeCreateManyContactInputEnvelope
    connect?: ContactScamTypeWhereUniqueInput | ContactScamTypeWhereUniqueInput[]
  }

  export type ContactTagUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<ContactTagCreateWithoutContactInput, ContactTagUncheckedCreateWithoutContactInput> | ContactTagCreateWithoutContactInput[] | ContactTagUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactTagCreateOrConnectWithoutContactInput | ContactTagCreateOrConnectWithoutContactInput[]
    createMany?: ContactTagCreateManyContactInputEnvelope
    connect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
  }

  export type EnumContactCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ContactCategory
  }

  export type ContactUpdatelanguageCodesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumContactStatusFieldUpdateOperationsInput = {
    set?: $Enums.ContactStatus
  }

  export type ContactScamTypeUpdateManyWithoutContactNestedInput = {
    create?: XOR<ContactScamTypeCreateWithoutContactInput, ContactScamTypeUncheckedCreateWithoutContactInput> | ContactScamTypeCreateWithoutContactInput[] | ContactScamTypeUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactScamTypeCreateOrConnectWithoutContactInput | ContactScamTypeCreateOrConnectWithoutContactInput[]
    upsert?: ContactScamTypeUpsertWithWhereUniqueWithoutContactInput | ContactScamTypeUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ContactScamTypeCreateManyContactInputEnvelope
    set?: ContactScamTypeWhereUniqueInput | ContactScamTypeWhereUniqueInput[]
    disconnect?: ContactScamTypeWhereUniqueInput | ContactScamTypeWhereUniqueInput[]
    delete?: ContactScamTypeWhereUniqueInput | ContactScamTypeWhereUniqueInput[]
    connect?: ContactScamTypeWhereUniqueInput | ContactScamTypeWhereUniqueInput[]
    update?: ContactScamTypeUpdateWithWhereUniqueWithoutContactInput | ContactScamTypeUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ContactScamTypeUpdateManyWithWhereWithoutContactInput | ContactScamTypeUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ContactScamTypeScalarWhereInput | ContactScamTypeScalarWhereInput[]
  }

  export type ContactTagUpdateManyWithoutContactNestedInput = {
    create?: XOR<ContactTagCreateWithoutContactInput, ContactTagUncheckedCreateWithoutContactInput> | ContactTagCreateWithoutContactInput[] | ContactTagUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactTagCreateOrConnectWithoutContactInput | ContactTagCreateOrConnectWithoutContactInput[]
    upsert?: ContactTagUpsertWithWhereUniqueWithoutContactInput | ContactTagUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ContactTagCreateManyContactInputEnvelope
    set?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    disconnect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    delete?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    connect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    update?: ContactTagUpdateWithWhereUniqueWithoutContactInput | ContactTagUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ContactTagUpdateManyWithWhereWithoutContactInput | ContactTagUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ContactTagScalarWhereInput | ContactTagScalarWhereInput[]
  }

  export type ContactScamTypeUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<ContactScamTypeCreateWithoutContactInput, ContactScamTypeUncheckedCreateWithoutContactInput> | ContactScamTypeCreateWithoutContactInput[] | ContactScamTypeUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactScamTypeCreateOrConnectWithoutContactInput | ContactScamTypeCreateOrConnectWithoutContactInput[]
    upsert?: ContactScamTypeUpsertWithWhereUniqueWithoutContactInput | ContactScamTypeUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ContactScamTypeCreateManyContactInputEnvelope
    set?: ContactScamTypeWhereUniqueInput | ContactScamTypeWhereUniqueInput[]
    disconnect?: ContactScamTypeWhereUniqueInput | ContactScamTypeWhereUniqueInput[]
    delete?: ContactScamTypeWhereUniqueInput | ContactScamTypeWhereUniqueInput[]
    connect?: ContactScamTypeWhereUniqueInput | ContactScamTypeWhereUniqueInput[]
    update?: ContactScamTypeUpdateWithWhereUniqueWithoutContactInput | ContactScamTypeUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ContactScamTypeUpdateManyWithWhereWithoutContactInput | ContactScamTypeUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ContactScamTypeScalarWhereInput | ContactScamTypeScalarWhereInput[]
  }

  export type ContactTagUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<ContactTagCreateWithoutContactInput, ContactTagUncheckedCreateWithoutContactInput> | ContactTagCreateWithoutContactInput[] | ContactTagUncheckedCreateWithoutContactInput[]
    connectOrCreate?: ContactTagCreateOrConnectWithoutContactInput | ContactTagCreateOrConnectWithoutContactInput[]
    upsert?: ContactTagUpsertWithWhereUniqueWithoutContactInput | ContactTagUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: ContactTagCreateManyContactInputEnvelope
    set?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    disconnect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    delete?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    connect?: ContactTagWhereUniqueInput | ContactTagWhereUniqueInput[]
    update?: ContactTagUpdateWithWhereUniqueWithoutContactInput | ContactTagUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: ContactTagUpdateManyWithWhereWithoutContactInput | ContactTagUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: ContactTagScalarWhereInput | ContactTagScalarWhereInput[]
  }

  export type ContactCreateNestedOneWithoutScamTypesInput = {
    create?: XOR<ContactCreateWithoutScamTypesInput, ContactUncheckedCreateWithoutScamTypesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutScamTypesInput
    connect?: ContactWhereUniqueInput
  }

  export type ScamTypeCreateNestedOneWithoutContactLinksInput = {
    create?: XOR<ScamTypeCreateWithoutContactLinksInput, ScamTypeUncheckedCreateWithoutContactLinksInput>
    connectOrCreate?: ScamTypeCreateOrConnectWithoutContactLinksInput
    connect?: ScamTypeWhereUniqueInput
  }

  export type ContactUpdateOneRequiredWithoutScamTypesNestedInput = {
    create?: XOR<ContactCreateWithoutScamTypesInput, ContactUncheckedCreateWithoutScamTypesInput>
    connectOrCreate?: ContactCreateOrConnectWithoutScamTypesInput
    upsert?: ContactUpsertWithoutScamTypesInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutScamTypesInput, ContactUpdateWithoutScamTypesInput>, ContactUncheckedUpdateWithoutScamTypesInput>
  }

  export type ScamTypeUpdateOneRequiredWithoutContactLinksNestedInput = {
    create?: XOR<ScamTypeCreateWithoutContactLinksInput, ScamTypeUncheckedCreateWithoutContactLinksInput>
    connectOrCreate?: ScamTypeCreateOrConnectWithoutContactLinksInput
    upsert?: ScamTypeUpsertWithoutContactLinksInput
    connect?: ScamTypeWhereUniqueInput
    update?: XOR<XOR<ScamTypeUpdateToOneWithWhereWithoutContactLinksInput, ScamTypeUpdateWithoutContactLinksInput>, ScamTypeUncheckedUpdateWithoutContactLinksInput>
  }

  export type ContactCreateNestedOneWithoutTagsInput = {
    create?: XOR<ContactCreateWithoutTagsInput, ContactUncheckedCreateWithoutTagsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutTagsInput
    connect?: ContactWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutContactsInput = {
    create?: XOR<TagCreateWithoutContactsInput, TagUncheckedCreateWithoutContactsInput>
    connectOrCreate?: TagCreateOrConnectWithoutContactsInput
    connect?: TagWhereUniqueInput
  }

  export type ContactUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<ContactCreateWithoutTagsInput, ContactUncheckedCreateWithoutTagsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutTagsInput
    upsert?: ContactUpsertWithoutTagsInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutTagsInput, ContactUpdateWithoutTagsInput>, ContactUncheckedUpdateWithoutTagsInput>
  }

  export type TagUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<TagCreateWithoutContactsInput, TagUncheckedCreateWithoutContactsInput>
    connectOrCreate?: TagCreateOrConnectWithoutContactsInput
    upsert?: TagUpsertWithoutContactsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutContactsInput, TagUpdateWithoutContactsInput>, TagUncheckedUpdateWithoutContactsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumPostStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusFilter<$PrismaModel> | $Enums.PostStatus
  }

  export type NestedEnumPostCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.PostCategory | EnumPostCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PostCategory[] | ListEnumPostCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostCategory[] | ListEnumPostCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPostCategoryFilter<$PrismaModel> | $Enums.PostCategory
  }

  export type NestedEnumPostStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostStatus | EnumPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostStatus[] | ListEnumPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPostStatusWithAggregatesFilter<$PrismaModel> | $Enums.PostStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostStatusFilter<$PrismaModel>
    _max?: NestedEnumPostStatusFilter<$PrismaModel>
  }

  export type NestedEnumPostCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostCategory | EnumPostCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PostCategory[] | ListEnumPostCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostCategory[] | ListEnumPostCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPostCategoryWithAggregatesFilter<$PrismaModel> | $Enums.PostCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostCategoryFilter<$PrismaModel>
    _max?: NestedEnumPostCategoryFilter<$PrismaModel>
  }

  export type NestedEnumContactCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactCategory | EnumContactCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ContactCategory[] | ListEnumContactCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactCategory[] | ListEnumContactCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumContactCategoryFilter<$PrismaModel> | $Enums.ContactCategory
  }

  export type NestedEnumContactStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactStatus | EnumContactStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContactStatus[] | ListEnumContactStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactStatus[] | ListEnumContactStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContactStatusFilter<$PrismaModel> | $Enums.ContactStatus
  }

  export type NestedEnumContactCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactCategory | EnumContactCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ContactCategory[] | ListEnumContactCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactCategory[] | ListEnumContactCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumContactCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ContactCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactCategoryFilter<$PrismaModel>
    _max?: NestedEnumContactCategoryFilter<$PrismaModel>
  }

  export type NestedEnumContactStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactStatus | EnumContactStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContactStatus[] | ListEnumContactStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactStatus[] | ListEnumContactStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumContactStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContactStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactStatusFilter<$PrismaModel>
    _max?: NestedEnumContactStatusFilter<$PrismaModel>
  }

  export type CommentCreateWithoutReportInput = {
    id?: string
    createdAt?: Date | string
    content: string
    parent?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentInput
    user?: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutReportInput = {
    id?: string
    createdAt?: Date | string
    content: string
    parentId?: string | null
    userId?: string | null
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutReportInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutReportInput, CommentUncheckedCreateWithoutReportInput>
  }

  export type CommentCreateManyReportInputEnvelope = {
    data: CommentCreateManyReportInput | CommentCreateManyReportInput[]
    skipDuplicates?: boolean
  }

  export type FlagCreateWithoutReportInput = {
    id?: string
    createdAt?: Date | string
    reason?: string | null
    user: UserCreateNestedOneWithoutFlagsInput
  }

  export type FlagUncheckedCreateWithoutReportInput = {
    id?: string
    createdAt?: Date | string
    userId: string
    reason?: string | null
  }

  export type FlagCreateOrConnectWithoutReportInput = {
    where: FlagWhereUniqueInput
    create: XOR<FlagCreateWithoutReportInput, FlagUncheckedCreateWithoutReportInput>
  }

  export type FlagCreateManyReportInputEnvelope = {
    data: FlagCreateManyReportInput | FlagCreateManyReportInput[]
    skipDuplicates?: boolean
  }

  export type ScamTypeCreateWithoutReportsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    createdBy?: string | null
    isApproved?: boolean
    isUserCreated?: boolean
    moderatedAt?: Date | string | null
    moderatedBy?: string | null
    contactLinks?: ContactScamTypeCreateNestedManyWithoutScamTypeInput
    postLinks?: EducationPostScamTypeCreateNestedManyWithoutScamTypeInput
    severityRecords?: SeverityCreateNestedManyWithoutScamTypeInput
  }

  export type ScamTypeUncheckedCreateWithoutReportsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    createdBy?: string | null
    isApproved?: boolean
    isUserCreated?: boolean
    moderatedAt?: Date | string | null
    moderatedBy?: string | null
    contactLinks?: ContactScamTypeUncheckedCreateNestedManyWithoutScamTypeInput
    postLinks?: EducationPostScamTypeUncheckedCreateNestedManyWithoutScamTypeInput
    severityRecords?: SeverityUncheckedCreateNestedManyWithoutScamTypeInput
  }

  export type ScamTypeCreateOrConnectWithoutReportsInput = {
    where: ScamTypeWhereUniqueInput
    create: XOR<ScamTypeCreateWithoutReportsInput, ScamTypeUncheckedCreateWithoutReportsInput>
  }

  export type VoteCreateWithoutReportInput = {
    id?: string
    voteType: string
    user: UserCreateNestedOneWithoutVotesInput
  }

  export type VoteUncheckedCreateWithoutReportInput = {
    id?: string
    userId: string
    voteType: string
  }

  export type VoteCreateOrConnectWithoutReportInput = {
    where: VoteWhereUniqueInput
    create: XOR<VoteCreateWithoutReportInput, VoteUncheckedCreateWithoutReportInput>
  }

  export type VoteCreateManyReportInputEnvelope = {
    data: VoteCreateManyReportInput | VoteCreateManyReportInput[]
    skipDuplicates?: boolean
  }

  export type CommentUpsertWithWhereUniqueWithoutReportInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutReportInput, CommentUncheckedUpdateWithoutReportInput>
    create: XOR<CommentCreateWithoutReportInput, CommentUncheckedCreateWithoutReportInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutReportInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutReportInput, CommentUncheckedUpdateWithoutReportInput>
  }

  export type CommentUpdateManyWithWhereWithoutReportInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutReportInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    content?: StringFilter<"Comment"> | string
    reportId?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    userId?: StringNullableFilter<"Comment"> | string | null
  }

  export type FlagUpsertWithWhereUniqueWithoutReportInput = {
    where: FlagWhereUniqueInput
    update: XOR<FlagUpdateWithoutReportInput, FlagUncheckedUpdateWithoutReportInput>
    create: XOR<FlagCreateWithoutReportInput, FlagUncheckedCreateWithoutReportInput>
  }

  export type FlagUpdateWithWhereUniqueWithoutReportInput = {
    where: FlagWhereUniqueInput
    data: XOR<FlagUpdateWithoutReportInput, FlagUncheckedUpdateWithoutReportInput>
  }

  export type FlagUpdateManyWithWhereWithoutReportInput = {
    where: FlagScalarWhereInput
    data: XOR<FlagUpdateManyMutationInput, FlagUncheckedUpdateManyWithoutReportInput>
  }

  export type FlagScalarWhereInput = {
    AND?: FlagScalarWhereInput | FlagScalarWhereInput[]
    OR?: FlagScalarWhereInput[]
    NOT?: FlagScalarWhereInput | FlagScalarWhereInput[]
    id?: StringFilter<"Flag"> | string
    createdAt?: DateTimeFilter<"Flag"> | Date | string
    reportId?: StringFilter<"Flag"> | string
    userId?: StringFilter<"Flag"> | string
    reason?: StringNullableFilter<"Flag"> | string | null
  }

  export type ScamTypeUpsertWithoutReportsInput = {
    update: XOR<ScamTypeUpdateWithoutReportsInput, ScamTypeUncheckedUpdateWithoutReportsInput>
    create: XOR<ScamTypeCreateWithoutReportsInput, ScamTypeUncheckedCreateWithoutReportsInput>
    where?: ScamTypeWhereInput
  }

  export type ScamTypeUpdateToOneWithWhereWithoutReportsInput = {
    where?: ScamTypeWhereInput
    data: XOR<ScamTypeUpdateWithoutReportsInput, ScamTypeUncheckedUpdateWithoutReportsInput>
  }

  export type ScamTypeUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isUserCreated?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    contactLinks?: ContactScamTypeUpdateManyWithoutScamTypeNestedInput
    postLinks?: EducationPostScamTypeUpdateManyWithoutScamTypeNestedInput
    severityRecords?: SeverityUpdateManyWithoutScamTypeNestedInput
  }

  export type ScamTypeUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isUserCreated?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    contactLinks?: ContactScamTypeUncheckedUpdateManyWithoutScamTypeNestedInput
    postLinks?: EducationPostScamTypeUncheckedUpdateManyWithoutScamTypeNestedInput
    severityRecords?: SeverityUncheckedUpdateManyWithoutScamTypeNestedInput
  }

  export type VoteUpsertWithWhereUniqueWithoutReportInput = {
    where: VoteWhereUniqueInput
    update: XOR<VoteUpdateWithoutReportInput, VoteUncheckedUpdateWithoutReportInput>
    create: XOR<VoteCreateWithoutReportInput, VoteUncheckedCreateWithoutReportInput>
  }

  export type VoteUpdateWithWhereUniqueWithoutReportInput = {
    where: VoteWhereUniqueInput
    data: XOR<VoteUpdateWithoutReportInput, VoteUncheckedUpdateWithoutReportInput>
  }

  export type VoteUpdateManyWithWhereWithoutReportInput = {
    where: VoteScalarWhereInput
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyWithoutReportInput>
  }

  export type VoteScalarWhereInput = {
    AND?: VoteScalarWhereInput | VoteScalarWhereInput[]
    OR?: VoteScalarWhereInput[]
    NOT?: VoteScalarWhereInput | VoteScalarWhereInput[]
    id?: StringFilter<"Vote"> | string
    reportId?: StringFilter<"Vote"> | string
    userId?: StringFilter<"Vote"> | string
    voteType?: StringFilter<"Vote"> | string
  }

  export type CommentCreateWithoutRepliesInput = {
    id?: string
    createdAt?: Date | string
    content: string
    parent?: CommentCreateNestedOneWithoutRepliesInput
    report: ScamReportCreateNestedOneWithoutCommentsInput
    user?: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutRepliesInput = {
    id?: string
    createdAt?: Date | string
    content: string
    reportId: string
    parentId?: string | null
    userId?: string | null
  }

  export type CommentCreateOrConnectWithoutRepliesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
  }

  export type CommentCreateWithoutParentInput = {
    id?: string
    createdAt?: Date | string
    content: string
    replies?: CommentCreateNestedManyWithoutParentInput
    report: ScamReportCreateNestedOneWithoutCommentsInput
    user?: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutParentInput = {
    id?: string
    createdAt?: Date | string
    content: string
    reportId: string
    userId?: string | null
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutParentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentCreateManyParentInputEnvelope = {
    data: CommentCreateManyParentInput | CommentCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type ScamReportCreateWithoutCommentsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    scammerDetails?: NullableJsonNullValueInput | InputJsonValue
    city?: string | null
    country?: string | null
    region?: string | null
    ipHash?: string | null
    latitude?: number | null
    longitude?: number | null
    verified?: boolean
    trustScore?: number
    reportCount?: number
    reporterName?: string | null
    reporterEmail?: string | null
    anonymous?: boolean
    outcome?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: string | null
    evidence?: string | null
    source?: string | null
    flags?: FlagCreateNestedManyWithoutReportInput
    scamType?: ScamTypeCreateNestedOneWithoutReportsInput
    votes?: VoteCreateNestedManyWithoutReportInput
  }

  export type ScamReportUncheckedCreateWithoutCommentsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    scammerDetails?: NullableJsonNullValueInput | InputJsonValue
    city?: string | null
    country?: string | null
    region?: string | null
    ipHash?: string | null
    latitude?: number | null
    longitude?: number | null
    verified?: boolean
    trustScore?: number
    reportCount?: number
    reporterName?: string | null
    reporterEmail?: string | null
    anonymous?: boolean
    outcome?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: string | null
    evidence?: string | null
    scamTypeId?: string | null
    source?: string | null
    flags?: FlagUncheckedCreateNestedManyWithoutReportInput
    votes?: VoteUncheckedCreateNestedManyWithoutReportInput
  }

  export type ScamReportCreateOrConnectWithoutCommentsInput = {
    where: ScamReportWhereUniqueInput
    create: XOR<ScamReportCreateWithoutCommentsInput, ScamReportUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    email: string
    username: string
    name?: string | null
    image?: string | null
    notificationSettings?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: string
    flags?: FlagCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    votes?: VoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    email: string
    username: string
    name?: string | null
    image?: string | null
    notificationSettings?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: string
    flags?: FlagUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type CommentUpsertWithoutRepliesInput = {
    update: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    parent?: CommentUpdateOneWithoutRepliesNestedInput
    report?: ScamReportUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentUpsertWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
  }

  export type CommentUpdateManyWithWhereWithoutParentInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutParentInput>
  }

  export type ScamReportUpsertWithoutCommentsInput = {
    update: XOR<ScamReportUpdateWithoutCommentsInput, ScamReportUncheckedUpdateWithoutCommentsInput>
    create: XOR<ScamReportCreateWithoutCommentsInput, ScamReportUncheckedCreateWithoutCommentsInput>
    where?: ScamReportWhereInput
  }

  export type ScamReportUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ScamReportWhereInput
    data: XOR<ScamReportUpdateWithoutCommentsInput, ScamReportUncheckedUpdateWithoutCommentsInput>
  }

  export type ScamReportUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    scammerDetails?: NullableJsonNullValueInput | InputJsonValue
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    trustScore?: IntFieldUpdateOperationsInput | number
    reportCount?: IntFieldUpdateOperationsInput | number
    reporterName?: NullableStringFieldUpdateOperationsInput | string | null
    reporterEmail?: NullableStringFieldUpdateOperationsInput | string | null
    anonymous?: BoolFieldUpdateOperationsInput | boolean
    outcome?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: FlagUpdateManyWithoutReportNestedInput
    scamType?: ScamTypeUpdateOneWithoutReportsNestedInput
    votes?: VoteUpdateManyWithoutReportNestedInput
  }

  export type ScamReportUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    scammerDetails?: NullableJsonNullValueInput | InputJsonValue
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    trustScore?: IntFieldUpdateOperationsInput | number
    reportCount?: IntFieldUpdateOperationsInput | number
    reporterName?: NullableStringFieldUpdateOperationsInput | string | null
    reporterEmail?: NullableStringFieldUpdateOperationsInput | string | null
    anonymous?: BoolFieldUpdateOperationsInput | boolean
    outcome?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    scamTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    flags?: FlagUncheckedUpdateManyWithoutReportNestedInput
    votes?: VoteUncheckedUpdateManyWithoutReportNestedInput
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    notificationSettings?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    flags?: FlagUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    votes?: VoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    notificationSettings?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    flags?: FlagUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ScamReportCreateWithoutVotesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    scammerDetails?: NullableJsonNullValueInput | InputJsonValue
    city?: string | null
    country?: string | null
    region?: string | null
    ipHash?: string | null
    latitude?: number | null
    longitude?: number | null
    verified?: boolean
    trustScore?: number
    reportCount?: number
    reporterName?: string | null
    reporterEmail?: string | null
    anonymous?: boolean
    outcome?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: string | null
    evidence?: string | null
    source?: string | null
    comments?: CommentCreateNestedManyWithoutReportInput
    flags?: FlagCreateNestedManyWithoutReportInput
    scamType?: ScamTypeCreateNestedOneWithoutReportsInput
  }

  export type ScamReportUncheckedCreateWithoutVotesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    scammerDetails?: NullableJsonNullValueInput | InputJsonValue
    city?: string | null
    country?: string | null
    region?: string | null
    ipHash?: string | null
    latitude?: number | null
    longitude?: number | null
    verified?: boolean
    trustScore?: number
    reportCount?: number
    reporterName?: string | null
    reporterEmail?: string | null
    anonymous?: boolean
    outcome?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: string | null
    evidence?: string | null
    scamTypeId?: string | null
    source?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutReportInput
    flags?: FlagUncheckedCreateNestedManyWithoutReportInput
  }

  export type ScamReportCreateOrConnectWithoutVotesInput = {
    where: ScamReportWhereUniqueInput
    create: XOR<ScamReportCreateWithoutVotesInput, ScamReportUncheckedCreateWithoutVotesInput>
  }

  export type UserCreateWithoutVotesInput = {
    id?: string
    email: string
    username: string
    name?: string | null
    image?: string | null
    notificationSettings?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: string
    comments?: CommentCreateNestedManyWithoutUserInput
    flags?: FlagCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVotesInput = {
    id?: string
    email: string
    username: string
    name?: string | null
    image?: string | null
    notificationSettings?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: string
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    flags?: FlagUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVotesInput, UserUncheckedCreateWithoutVotesInput>
  }

  export type ScamReportUpsertWithoutVotesInput = {
    update: XOR<ScamReportUpdateWithoutVotesInput, ScamReportUncheckedUpdateWithoutVotesInput>
    create: XOR<ScamReportCreateWithoutVotesInput, ScamReportUncheckedCreateWithoutVotesInput>
    where?: ScamReportWhereInput
  }

  export type ScamReportUpdateToOneWithWhereWithoutVotesInput = {
    where?: ScamReportWhereInput
    data: XOR<ScamReportUpdateWithoutVotesInput, ScamReportUncheckedUpdateWithoutVotesInput>
  }

  export type ScamReportUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    scammerDetails?: NullableJsonNullValueInput | InputJsonValue
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    trustScore?: IntFieldUpdateOperationsInput | number
    reportCount?: IntFieldUpdateOperationsInput | number
    reporterName?: NullableStringFieldUpdateOperationsInput | string | null
    reporterEmail?: NullableStringFieldUpdateOperationsInput | string | null
    anonymous?: BoolFieldUpdateOperationsInput | boolean
    outcome?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUpdateManyWithoutReportNestedInput
    flags?: FlagUpdateManyWithoutReportNestedInput
    scamType?: ScamTypeUpdateOneWithoutReportsNestedInput
  }

  export type ScamReportUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    scammerDetails?: NullableJsonNullValueInput | InputJsonValue
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    trustScore?: IntFieldUpdateOperationsInput | number
    reportCount?: IntFieldUpdateOperationsInput | number
    reporterName?: NullableStringFieldUpdateOperationsInput | string | null
    reporterEmail?: NullableStringFieldUpdateOperationsInput | string | null
    anonymous?: BoolFieldUpdateOperationsInput | boolean
    outcome?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    scamTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutReportNestedInput
    flags?: FlagUncheckedUpdateManyWithoutReportNestedInput
  }

  export type UserUpsertWithoutVotesInput = {
    update: XOR<UserUpdateWithoutVotesInput, UserUncheckedUpdateWithoutVotesInput>
    create: XOR<UserCreateWithoutVotesInput, UserUncheckedCreateWithoutVotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVotesInput, UserUncheckedUpdateWithoutVotesInput>
  }

  export type UserUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    notificationSettings?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    comments?: CommentUpdateManyWithoutUserNestedInput
    flags?: FlagUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    notificationSettings?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    flags?: FlagUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ContactScamTypeCreateWithoutScamTypeInput = {
    contact: ContactCreateNestedOneWithoutScamTypesInput
  }

  export type ContactScamTypeUncheckedCreateWithoutScamTypeInput = {
    contactId: string
  }

  export type ContactScamTypeCreateOrConnectWithoutScamTypeInput = {
    where: ContactScamTypeWhereUniqueInput
    create: XOR<ContactScamTypeCreateWithoutScamTypeInput, ContactScamTypeUncheckedCreateWithoutScamTypeInput>
  }

  export type ContactScamTypeCreateManyScamTypeInputEnvelope = {
    data: ContactScamTypeCreateManyScamTypeInput | ContactScamTypeCreateManyScamTypeInput[]
    skipDuplicates?: boolean
  }

  export type EducationPostScamTypeCreateWithoutScamTypeInput = {
    post: EducationPostCreateNestedOneWithoutScamTypesInput
  }

  export type EducationPostScamTypeUncheckedCreateWithoutScamTypeInput = {
    postId: string
  }

  export type EducationPostScamTypeCreateOrConnectWithoutScamTypeInput = {
    where: EducationPostScamTypeWhereUniqueInput
    create: XOR<EducationPostScamTypeCreateWithoutScamTypeInput, EducationPostScamTypeUncheckedCreateWithoutScamTypeInput>
  }

  export type EducationPostScamTypeCreateManyScamTypeInputEnvelope = {
    data: EducationPostScamTypeCreateManyScamTypeInput | EducationPostScamTypeCreateManyScamTypeInput[]
    skipDuplicates?: boolean
  }

  export type ScamReportCreateWithoutScamTypeInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    scammerDetails?: NullableJsonNullValueInput | InputJsonValue
    city?: string | null
    country?: string | null
    region?: string | null
    ipHash?: string | null
    latitude?: number | null
    longitude?: number | null
    verified?: boolean
    trustScore?: number
    reportCount?: number
    reporterName?: string | null
    reporterEmail?: string | null
    anonymous?: boolean
    outcome?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: string | null
    evidence?: string | null
    source?: string | null
    comments?: CommentCreateNestedManyWithoutReportInput
    flags?: FlagCreateNestedManyWithoutReportInput
    votes?: VoteCreateNestedManyWithoutReportInput
  }

  export type ScamReportUncheckedCreateWithoutScamTypeInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    scammerDetails?: NullableJsonNullValueInput | InputJsonValue
    city?: string | null
    country?: string | null
    region?: string | null
    ipHash?: string | null
    latitude?: number | null
    longitude?: number | null
    verified?: boolean
    trustScore?: number
    reportCount?: number
    reporterName?: string | null
    reporterEmail?: string | null
    anonymous?: boolean
    outcome?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: string | null
    evidence?: string | null
    source?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutReportInput
    flags?: FlagUncheckedCreateNestedManyWithoutReportInput
    votes?: VoteUncheckedCreateNestedManyWithoutReportInput
  }

  export type ScamReportCreateOrConnectWithoutScamTypeInput = {
    where: ScamReportWhereUniqueInput
    create: XOR<ScamReportCreateWithoutScamTypeInput, ScamReportUncheckedCreateWithoutScamTypeInput>
  }

  export type ScamReportCreateManyScamTypeInputEnvelope = {
    data: ScamReportCreateManyScamTypeInput | ScamReportCreateManyScamTypeInput[]
    skipDuplicates?: boolean
  }

  export type SeverityCreateWithoutScamTypeInput = {
    id?: string
    country?: string | null
    region?: string | null
    city?: string | null
    score: number
    level: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type SeverityUncheckedCreateWithoutScamTypeInput = {
    id?: string
    country?: string | null
    region?: string | null
    city?: string | null
    score: number
    level: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type SeverityCreateOrConnectWithoutScamTypeInput = {
    where: SeverityWhereUniqueInput
    create: XOR<SeverityCreateWithoutScamTypeInput, SeverityUncheckedCreateWithoutScamTypeInput>
  }

  export type SeverityCreateManyScamTypeInputEnvelope = {
    data: SeverityCreateManyScamTypeInput | SeverityCreateManyScamTypeInput[]
    skipDuplicates?: boolean
  }

  export type ContactScamTypeUpsertWithWhereUniqueWithoutScamTypeInput = {
    where: ContactScamTypeWhereUniqueInput
    update: XOR<ContactScamTypeUpdateWithoutScamTypeInput, ContactScamTypeUncheckedUpdateWithoutScamTypeInput>
    create: XOR<ContactScamTypeCreateWithoutScamTypeInput, ContactScamTypeUncheckedCreateWithoutScamTypeInput>
  }

  export type ContactScamTypeUpdateWithWhereUniqueWithoutScamTypeInput = {
    where: ContactScamTypeWhereUniqueInput
    data: XOR<ContactScamTypeUpdateWithoutScamTypeInput, ContactScamTypeUncheckedUpdateWithoutScamTypeInput>
  }

  export type ContactScamTypeUpdateManyWithWhereWithoutScamTypeInput = {
    where: ContactScamTypeScalarWhereInput
    data: XOR<ContactScamTypeUpdateManyMutationInput, ContactScamTypeUncheckedUpdateManyWithoutScamTypeInput>
  }

  export type ContactScamTypeScalarWhereInput = {
    AND?: ContactScamTypeScalarWhereInput | ContactScamTypeScalarWhereInput[]
    OR?: ContactScamTypeScalarWhereInput[]
    NOT?: ContactScamTypeScalarWhereInput | ContactScamTypeScalarWhereInput[]
    contactId?: StringFilter<"ContactScamType"> | string
    scamTypeId?: StringFilter<"ContactScamType"> | string
  }

  export type EducationPostScamTypeUpsertWithWhereUniqueWithoutScamTypeInput = {
    where: EducationPostScamTypeWhereUniqueInput
    update: XOR<EducationPostScamTypeUpdateWithoutScamTypeInput, EducationPostScamTypeUncheckedUpdateWithoutScamTypeInput>
    create: XOR<EducationPostScamTypeCreateWithoutScamTypeInput, EducationPostScamTypeUncheckedCreateWithoutScamTypeInput>
  }

  export type EducationPostScamTypeUpdateWithWhereUniqueWithoutScamTypeInput = {
    where: EducationPostScamTypeWhereUniqueInput
    data: XOR<EducationPostScamTypeUpdateWithoutScamTypeInput, EducationPostScamTypeUncheckedUpdateWithoutScamTypeInput>
  }

  export type EducationPostScamTypeUpdateManyWithWhereWithoutScamTypeInput = {
    where: EducationPostScamTypeScalarWhereInput
    data: XOR<EducationPostScamTypeUpdateManyMutationInput, EducationPostScamTypeUncheckedUpdateManyWithoutScamTypeInput>
  }

  export type EducationPostScamTypeScalarWhereInput = {
    AND?: EducationPostScamTypeScalarWhereInput | EducationPostScamTypeScalarWhereInput[]
    OR?: EducationPostScamTypeScalarWhereInput[]
    NOT?: EducationPostScamTypeScalarWhereInput | EducationPostScamTypeScalarWhereInput[]
    postId?: StringFilter<"EducationPostScamType"> | string
    scamTypeId?: StringFilter<"EducationPostScamType"> | string
  }

  export type ScamReportUpsertWithWhereUniqueWithoutScamTypeInput = {
    where: ScamReportWhereUniqueInput
    update: XOR<ScamReportUpdateWithoutScamTypeInput, ScamReportUncheckedUpdateWithoutScamTypeInput>
    create: XOR<ScamReportCreateWithoutScamTypeInput, ScamReportUncheckedCreateWithoutScamTypeInput>
  }

  export type ScamReportUpdateWithWhereUniqueWithoutScamTypeInput = {
    where: ScamReportWhereUniqueInput
    data: XOR<ScamReportUpdateWithoutScamTypeInput, ScamReportUncheckedUpdateWithoutScamTypeInput>
  }

  export type ScamReportUpdateManyWithWhereWithoutScamTypeInput = {
    where: ScamReportScalarWhereInput
    data: XOR<ScamReportUpdateManyMutationInput, ScamReportUncheckedUpdateManyWithoutScamTypeInput>
  }

  export type ScamReportScalarWhereInput = {
    AND?: ScamReportScalarWhereInput | ScamReportScalarWhereInput[]
    OR?: ScamReportScalarWhereInput[]
    NOT?: ScamReportScalarWhereInput | ScamReportScalarWhereInput[]
    id?: StringFilter<"ScamReport"> | string
    createdAt?: DateTimeFilter<"ScamReport"> | Date | string
    updatedAt?: DateTimeFilter<"ScamReport"> | Date | string
    description?: StringFilter<"ScamReport"> | string
    scammerDetails?: JsonNullableFilter<"ScamReport">
    city?: StringNullableFilter<"ScamReport"> | string | null
    country?: StringNullableFilter<"ScamReport"> | string | null
    region?: StringNullableFilter<"ScamReport"> | string | null
    ipHash?: StringNullableFilter<"ScamReport"> | string | null
    latitude?: FloatNullableFilter<"ScamReport"> | number | null
    longitude?: FloatNullableFilter<"ScamReport"> | number | null
    verified?: BoolFilter<"ScamReport"> | boolean
    trustScore?: IntFilter<"ScamReport"> | number
    reportCount?: IntFilter<"ScamReport"> | number
    reporterName?: StringNullableFilter<"ScamReport"> | string | null
    reporterEmail?: StringNullableFilter<"ScamReport"> | string | null
    anonymous?: BoolFilter<"ScamReport"> | boolean
    outcome?: JsonNullableFilter<"ScamReport">
    screenshots?: StringNullableFilter<"ScamReport"> | string | null
    evidence?: StringNullableFilter<"ScamReport"> | string | null
    scamTypeId?: StringNullableFilter<"ScamReport"> | string | null
    source?: StringNullableFilter<"ScamReport"> | string | null
  }

  export type SeverityUpsertWithWhereUniqueWithoutScamTypeInput = {
    where: SeverityWhereUniqueInput
    update: XOR<SeverityUpdateWithoutScamTypeInput, SeverityUncheckedUpdateWithoutScamTypeInput>
    create: XOR<SeverityCreateWithoutScamTypeInput, SeverityUncheckedCreateWithoutScamTypeInput>
  }

  export type SeverityUpdateWithWhereUniqueWithoutScamTypeInput = {
    where: SeverityWhereUniqueInput
    data: XOR<SeverityUpdateWithoutScamTypeInput, SeverityUncheckedUpdateWithoutScamTypeInput>
  }

  export type SeverityUpdateManyWithWhereWithoutScamTypeInput = {
    where: SeverityScalarWhereInput
    data: XOR<SeverityUpdateManyMutationInput, SeverityUncheckedUpdateManyWithoutScamTypeInput>
  }

  export type SeverityScalarWhereInput = {
    AND?: SeverityScalarWhereInput | SeverityScalarWhereInput[]
    OR?: SeverityScalarWhereInput[]
    NOT?: SeverityScalarWhereInput | SeverityScalarWhereInput[]
    id?: StringFilter<"Severity"> | string
    scamTypeId?: StringFilter<"Severity"> | string
    country?: StringNullableFilter<"Severity"> | string | null
    region?: StringNullableFilter<"Severity"> | string | null
    city?: StringNullableFilter<"Severity"> | string | null
    score?: IntFilter<"Severity"> | number
    level?: StringFilter<"Severity"> | string
    updatedAt?: DateTimeFilter<"Severity"> | Date | string
    createdAt?: DateTimeFilter<"Severity"> | Date | string
  }

  export type ScamTypeCreateWithoutSeverityRecordsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    createdBy?: string | null
    isApproved?: boolean
    isUserCreated?: boolean
    moderatedAt?: Date | string | null
    moderatedBy?: string | null
    contactLinks?: ContactScamTypeCreateNestedManyWithoutScamTypeInput
    postLinks?: EducationPostScamTypeCreateNestedManyWithoutScamTypeInput
    reports?: ScamReportCreateNestedManyWithoutScamTypeInput
  }

  export type ScamTypeUncheckedCreateWithoutSeverityRecordsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    createdBy?: string | null
    isApproved?: boolean
    isUserCreated?: boolean
    moderatedAt?: Date | string | null
    moderatedBy?: string | null
    contactLinks?: ContactScamTypeUncheckedCreateNestedManyWithoutScamTypeInput
    postLinks?: EducationPostScamTypeUncheckedCreateNestedManyWithoutScamTypeInput
    reports?: ScamReportUncheckedCreateNestedManyWithoutScamTypeInput
  }

  export type ScamTypeCreateOrConnectWithoutSeverityRecordsInput = {
    where: ScamTypeWhereUniqueInput
    create: XOR<ScamTypeCreateWithoutSeverityRecordsInput, ScamTypeUncheckedCreateWithoutSeverityRecordsInput>
  }

  export type ScamTypeUpsertWithoutSeverityRecordsInput = {
    update: XOR<ScamTypeUpdateWithoutSeverityRecordsInput, ScamTypeUncheckedUpdateWithoutSeverityRecordsInput>
    create: XOR<ScamTypeCreateWithoutSeverityRecordsInput, ScamTypeUncheckedCreateWithoutSeverityRecordsInput>
    where?: ScamTypeWhereInput
  }

  export type ScamTypeUpdateToOneWithWhereWithoutSeverityRecordsInput = {
    where?: ScamTypeWhereInput
    data: XOR<ScamTypeUpdateWithoutSeverityRecordsInput, ScamTypeUncheckedUpdateWithoutSeverityRecordsInput>
  }

  export type ScamTypeUpdateWithoutSeverityRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isUserCreated?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    contactLinks?: ContactScamTypeUpdateManyWithoutScamTypeNestedInput
    postLinks?: EducationPostScamTypeUpdateManyWithoutScamTypeNestedInput
    reports?: ScamReportUpdateManyWithoutScamTypeNestedInput
  }

  export type ScamTypeUncheckedUpdateWithoutSeverityRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isUserCreated?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    contactLinks?: ContactScamTypeUncheckedUpdateManyWithoutScamTypeNestedInput
    postLinks?: EducationPostScamTypeUncheckedUpdateManyWithoutScamTypeNestedInput
    reports?: ScamReportUncheckedUpdateManyWithoutScamTypeNestedInput
  }

  export type ScamReportCreateWithoutFlagsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    scammerDetails?: NullableJsonNullValueInput | InputJsonValue
    city?: string | null
    country?: string | null
    region?: string | null
    ipHash?: string | null
    latitude?: number | null
    longitude?: number | null
    verified?: boolean
    trustScore?: number
    reportCount?: number
    reporterName?: string | null
    reporterEmail?: string | null
    anonymous?: boolean
    outcome?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: string | null
    evidence?: string | null
    source?: string | null
    comments?: CommentCreateNestedManyWithoutReportInput
    scamType?: ScamTypeCreateNestedOneWithoutReportsInput
    votes?: VoteCreateNestedManyWithoutReportInput
  }

  export type ScamReportUncheckedCreateWithoutFlagsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    scammerDetails?: NullableJsonNullValueInput | InputJsonValue
    city?: string | null
    country?: string | null
    region?: string | null
    ipHash?: string | null
    latitude?: number | null
    longitude?: number | null
    verified?: boolean
    trustScore?: number
    reportCount?: number
    reporterName?: string | null
    reporterEmail?: string | null
    anonymous?: boolean
    outcome?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: string | null
    evidence?: string | null
    scamTypeId?: string | null
    source?: string | null
    comments?: CommentUncheckedCreateNestedManyWithoutReportInput
    votes?: VoteUncheckedCreateNestedManyWithoutReportInput
  }

  export type ScamReportCreateOrConnectWithoutFlagsInput = {
    where: ScamReportWhereUniqueInput
    create: XOR<ScamReportCreateWithoutFlagsInput, ScamReportUncheckedCreateWithoutFlagsInput>
  }

  export type UserCreateWithoutFlagsInput = {
    id?: string
    email: string
    username: string
    name?: string | null
    image?: string | null
    notificationSettings?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: string
    comments?: CommentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    votes?: VoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFlagsInput = {
    id?: string
    email: string
    username: string
    name?: string | null
    image?: string | null
    notificationSettings?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: string
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFlagsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFlagsInput, UserUncheckedCreateWithoutFlagsInput>
  }

  export type ScamReportUpsertWithoutFlagsInput = {
    update: XOR<ScamReportUpdateWithoutFlagsInput, ScamReportUncheckedUpdateWithoutFlagsInput>
    create: XOR<ScamReportCreateWithoutFlagsInput, ScamReportUncheckedCreateWithoutFlagsInput>
    where?: ScamReportWhereInput
  }

  export type ScamReportUpdateToOneWithWhereWithoutFlagsInput = {
    where?: ScamReportWhereInput
    data: XOR<ScamReportUpdateWithoutFlagsInput, ScamReportUncheckedUpdateWithoutFlagsInput>
  }

  export type ScamReportUpdateWithoutFlagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    scammerDetails?: NullableJsonNullValueInput | InputJsonValue
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    trustScore?: IntFieldUpdateOperationsInput | number
    reportCount?: IntFieldUpdateOperationsInput | number
    reporterName?: NullableStringFieldUpdateOperationsInput | string | null
    reporterEmail?: NullableStringFieldUpdateOperationsInput | string | null
    anonymous?: BoolFieldUpdateOperationsInput | boolean
    outcome?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUpdateManyWithoutReportNestedInput
    scamType?: ScamTypeUpdateOneWithoutReportsNestedInput
    votes?: VoteUpdateManyWithoutReportNestedInput
  }

  export type ScamReportUncheckedUpdateWithoutFlagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    scammerDetails?: NullableJsonNullValueInput | InputJsonValue
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    trustScore?: IntFieldUpdateOperationsInput | number
    reportCount?: IntFieldUpdateOperationsInput | number
    reporterName?: NullableStringFieldUpdateOperationsInput | string | null
    reporterEmail?: NullableStringFieldUpdateOperationsInput | string | null
    anonymous?: BoolFieldUpdateOperationsInput | boolean
    outcome?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    scamTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutReportNestedInput
    votes?: VoteUncheckedUpdateManyWithoutReportNestedInput
  }

  export type UserUpsertWithoutFlagsInput = {
    update: XOR<UserUpdateWithoutFlagsInput, UserUncheckedUpdateWithoutFlagsInput>
    create: XOR<UserCreateWithoutFlagsInput, UserUncheckedCreateWithoutFlagsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFlagsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFlagsInput, UserUncheckedUpdateWithoutFlagsInput>
  }

  export type UserUpdateWithoutFlagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    notificationSettings?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    comments?: CommentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    votes?: VoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFlagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    notificationSettings?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    content: string
    parent?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentInput
    report: ScamReportCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    content: string
    reportId: string
    parentId?: string | null
    replies?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FlagCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    reason?: string | null
    report: ScamReportCreateNestedOneWithoutFlagsInput
  }

  export type FlagUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    reportId: string
    reason?: string | null
  }

  export type FlagCreateOrConnectWithoutUserInput = {
    where: FlagWhereUniqueInput
    create: XOR<FlagCreateWithoutUserInput, FlagUncheckedCreateWithoutUserInput>
  }

  export type FlagCreateManyUserInputEnvelope = {
    data: FlagCreateManyUserInput | FlagCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: string
    data?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    data?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type VoteCreateWithoutUserInput = {
    id?: string
    voteType: string
    report: ScamReportCreateNestedOneWithoutVotesInput
  }

  export type VoteUncheckedCreateWithoutUserInput = {
    id?: string
    reportId: string
    voteType: string
  }

  export type VoteCreateOrConnectWithoutUserInput = {
    where: VoteWhereUniqueInput
    create: XOR<VoteCreateWithoutUserInput, VoteUncheckedCreateWithoutUserInput>
  }

  export type VoteCreateManyUserInputEnvelope = {
    data: VoteCreateManyUserInput | VoteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>
  }

  export type FlagUpsertWithWhereUniqueWithoutUserInput = {
    where: FlagWhereUniqueInput
    update: XOR<FlagUpdateWithoutUserInput, FlagUncheckedUpdateWithoutUserInput>
    create: XOR<FlagCreateWithoutUserInput, FlagUncheckedCreateWithoutUserInput>
  }

  export type FlagUpdateWithWhereUniqueWithoutUserInput = {
    where: FlagWhereUniqueInput
    data: XOR<FlagUpdateWithoutUserInput, FlagUncheckedUpdateWithoutUserInput>
  }

  export type FlagUpdateManyWithWhereWithoutUserInput = {
    where: FlagScalarWhereInput
    data: XOR<FlagUpdateManyMutationInput, FlagUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    data?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type VoteUpsertWithWhereUniqueWithoutUserInput = {
    where: VoteWhereUniqueInput
    update: XOR<VoteUpdateWithoutUserInput, VoteUncheckedUpdateWithoutUserInput>
    create: XOR<VoteCreateWithoutUserInput, VoteUncheckedCreateWithoutUserInput>
  }

  export type VoteUpdateWithWhereUniqueWithoutUserInput = {
    where: VoteWhereUniqueInput
    data: XOR<VoteUpdateWithoutUserInput, VoteUncheckedUpdateWithoutUserInput>
  }

  export type VoteUpdateManyWithWhereWithoutUserInput = {
    where: VoteScalarWhereInput
    data: XOR<VoteUpdateManyMutationInput, VoteUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    username: string
    name?: string | null
    image?: string | null
    notificationSettings?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: string
    comments?: CommentCreateNestedManyWithoutUserInput
    flags?: FlagCreateNestedManyWithoutUserInput
    votes?: VoteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    username: string
    name?: string | null
    image?: string | null
    notificationSettings?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    role?: string
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    flags?: FlagUncheckedCreateNestedManyWithoutUserInput
    votes?: VoteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    notificationSettings?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    comments?: CommentUpdateManyWithoutUserNestedInput
    flags?: FlagUpdateManyWithoutUserNestedInput
    votes?: VoteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    notificationSettings?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    flags?: FlagUncheckedUpdateManyWithoutUserNestedInput
    votes?: VoteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EducationPostScamTypeCreateWithoutPostInput = {
    scamType: ScamTypeCreateNestedOneWithoutPostLinksInput
  }

  export type EducationPostScamTypeUncheckedCreateWithoutPostInput = {
    scamTypeId: string
  }

  export type EducationPostScamTypeCreateOrConnectWithoutPostInput = {
    where: EducationPostScamTypeWhereUniqueInput
    create: XOR<EducationPostScamTypeCreateWithoutPostInput, EducationPostScamTypeUncheckedCreateWithoutPostInput>
  }

  export type EducationPostScamTypeCreateManyPostInputEnvelope = {
    data: EducationPostScamTypeCreateManyPostInput | EducationPostScamTypeCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type PostTagCreateWithoutPostInput = {
    tag: TagCreateNestedOneWithoutPostsInput
  }

  export type PostTagUncheckedCreateWithoutPostInput = {
    tagId: string
  }

  export type PostTagCreateOrConnectWithoutPostInput = {
    where: PostTagWhereUniqueInput
    create: XOR<PostTagCreateWithoutPostInput, PostTagUncheckedCreateWithoutPostInput>
  }

  export type PostTagCreateManyPostInputEnvelope = {
    data: PostTagCreateManyPostInput | PostTagCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type EducationPostScamTypeUpsertWithWhereUniqueWithoutPostInput = {
    where: EducationPostScamTypeWhereUniqueInput
    update: XOR<EducationPostScamTypeUpdateWithoutPostInput, EducationPostScamTypeUncheckedUpdateWithoutPostInput>
    create: XOR<EducationPostScamTypeCreateWithoutPostInput, EducationPostScamTypeUncheckedCreateWithoutPostInput>
  }

  export type EducationPostScamTypeUpdateWithWhereUniqueWithoutPostInput = {
    where: EducationPostScamTypeWhereUniqueInput
    data: XOR<EducationPostScamTypeUpdateWithoutPostInput, EducationPostScamTypeUncheckedUpdateWithoutPostInput>
  }

  export type EducationPostScamTypeUpdateManyWithWhereWithoutPostInput = {
    where: EducationPostScamTypeScalarWhereInput
    data: XOR<EducationPostScamTypeUpdateManyMutationInput, EducationPostScamTypeUncheckedUpdateManyWithoutPostInput>
  }

  export type PostTagUpsertWithWhereUniqueWithoutPostInput = {
    where: PostTagWhereUniqueInput
    update: XOR<PostTagUpdateWithoutPostInput, PostTagUncheckedUpdateWithoutPostInput>
    create: XOR<PostTagCreateWithoutPostInput, PostTagUncheckedCreateWithoutPostInput>
  }

  export type PostTagUpdateWithWhereUniqueWithoutPostInput = {
    where: PostTagWhereUniqueInput
    data: XOR<PostTagUpdateWithoutPostInput, PostTagUncheckedUpdateWithoutPostInput>
  }

  export type PostTagUpdateManyWithWhereWithoutPostInput = {
    where: PostTagScalarWhereInput
    data: XOR<PostTagUpdateManyMutationInput, PostTagUncheckedUpdateManyWithoutPostInput>
  }

  export type PostTagScalarWhereInput = {
    AND?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
    OR?: PostTagScalarWhereInput[]
    NOT?: PostTagScalarWhereInput | PostTagScalarWhereInput[]
    postId?: StringFilter<"PostTag"> | string
    tagId?: StringFilter<"PostTag"> | string
  }

  export type ContactTagCreateWithoutTagInput = {
    contact: ContactCreateNestedOneWithoutTagsInput
  }

  export type ContactTagUncheckedCreateWithoutTagInput = {
    contactId: string
  }

  export type ContactTagCreateOrConnectWithoutTagInput = {
    where: ContactTagWhereUniqueInput
    create: XOR<ContactTagCreateWithoutTagInput, ContactTagUncheckedCreateWithoutTagInput>
  }

  export type ContactTagCreateManyTagInputEnvelope = {
    data: ContactTagCreateManyTagInput | ContactTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type PostTagCreateWithoutTagInput = {
    post: EducationPostCreateNestedOneWithoutTagsInput
  }

  export type PostTagUncheckedCreateWithoutTagInput = {
    postId: string
  }

  export type PostTagCreateOrConnectWithoutTagInput = {
    where: PostTagWhereUniqueInput
    create: XOR<PostTagCreateWithoutTagInput, PostTagUncheckedCreateWithoutTagInput>
  }

  export type PostTagCreateManyTagInputEnvelope = {
    data: PostTagCreateManyTagInput | PostTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type ContactTagUpsertWithWhereUniqueWithoutTagInput = {
    where: ContactTagWhereUniqueInput
    update: XOR<ContactTagUpdateWithoutTagInput, ContactTagUncheckedUpdateWithoutTagInput>
    create: XOR<ContactTagCreateWithoutTagInput, ContactTagUncheckedCreateWithoutTagInput>
  }

  export type ContactTagUpdateWithWhereUniqueWithoutTagInput = {
    where: ContactTagWhereUniqueInput
    data: XOR<ContactTagUpdateWithoutTagInput, ContactTagUncheckedUpdateWithoutTagInput>
  }

  export type ContactTagUpdateManyWithWhereWithoutTagInput = {
    where: ContactTagScalarWhereInput
    data: XOR<ContactTagUpdateManyMutationInput, ContactTagUncheckedUpdateManyWithoutTagInput>
  }

  export type ContactTagScalarWhereInput = {
    AND?: ContactTagScalarWhereInput | ContactTagScalarWhereInput[]
    OR?: ContactTagScalarWhereInput[]
    NOT?: ContactTagScalarWhereInput | ContactTagScalarWhereInput[]
    contactId?: StringFilter<"ContactTag"> | string
    tagId?: StringFilter<"ContactTag"> | string
  }

  export type PostTagUpsertWithWhereUniqueWithoutTagInput = {
    where: PostTagWhereUniqueInput
    update: XOR<PostTagUpdateWithoutTagInput, PostTagUncheckedUpdateWithoutTagInput>
    create: XOR<PostTagCreateWithoutTagInput, PostTagUncheckedCreateWithoutTagInput>
  }

  export type PostTagUpdateWithWhereUniqueWithoutTagInput = {
    where: PostTagWhereUniqueInput
    data: XOR<PostTagUpdateWithoutTagInput, PostTagUncheckedUpdateWithoutTagInput>
  }

  export type PostTagUpdateManyWithWhereWithoutTagInput = {
    where: PostTagScalarWhereInput
    data: XOR<PostTagUpdateManyMutationInput, PostTagUncheckedUpdateManyWithoutTagInput>
  }

  export type EducationPostCreateWithoutTagsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    title: string
    excerpt?: string | null
    bodyMd: string
    status?: $Enums.PostStatus
    publishedAt?: Date | string | null
    category: $Enums.PostCategory
    heroImageUrl?: string | null
    heroSvg?: string | null
    heroAlt?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    canonicalUrl?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    featured?: boolean
    authorName?: string | null
    sourceUrl?: string | null
    scamTypes?: EducationPostScamTypeCreateNestedManyWithoutPostInput
  }

  export type EducationPostUncheckedCreateWithoutTagsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    title: string
    excerpt?: string | null
    bodyMd: string
    status?: $Enums.PostStatus
    publishedAt?: Date | string | null
    category: $Enums.PostCategory
    heroImageUrl?: string | null
    heroSvg?: string | null
    heroAlt?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    canonicalUrl?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    featured?: boolean
    authorName?: string | null
    sourceUrl?: string | null
    scamTypes?: EducationPostScamTypeUncheckedCreateNestedManyWithoutPostInput
  }

  export type EducationPostCreateOrConnectWithoutTagsInput = {
    where: EducationPostWhereUniqueInput
    create: XOR<EducationPostCreateWithoutTagsInput, EducationPostUncheckedCreateWithoutTagsInput>
  }

  export type TagCreateWithoutPostsInput = {
    id?: string
    name: string
    contacts?: ContactTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutPostsInput = {
    id?: string
    name: string
    contacts?: ContactTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutPostsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput>
  }

  export type EducationPostUpsertWithoutTagsInput = {
    update: XOR<EducationPostUpdateWithoutTagsInput, EducationPostUncheckedUpdateWithoutTagsInput>
    create: XOR<EducationPostCreateWithoutTagsInput, EducationPostUncheckedCreateWithoutTagsInput>
    where?: EducationPostWhereInput
  }

  export type EducationPostUpdateToOneWithWhereWithoutTagsInput = {
    where?: EducationPostWhereInput
    data: XOR<EducationPostUpdateWithoutTagsInput, EducationPostUncheckedUpdateWithoutTagsInput>
  }

  export type EducationPostUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    bodyMd?: StringFieldUpdateOperationsInput | string
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPostCategoryFieldUpdateOperationsInput | $Enums.PostCategory
    heroImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    heroSvg?: NullableStringFieldUpdateOperationsInput | string | null
    heroAlt?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scamTypes?: EducationPostScamTypeUpdateManyWithoutPostNestedInput
  }

  export type EducationPostUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    bodyMd?: StringFieldUpdateOperationsInput | string
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPostCategoryFieldUpdateOperationsInput | $Enums.PostCategory
    heroImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    heroSvg?: NullableStringFieldUpdateOperationsInput | string | null
    heroAlt?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    scamTypes?: EducationPostScamTypeUncheckedUpdateManyWithoutPostNestedInput
  }

  export type TagUpsertWithoutPostsInput = {
    update: XOR<TagUpdateWithoutPostsInput, TagUncheckedUpdateWithoutPostsInput>
    create: XOR<TagCreateWithoutPostsInput, TagUncheckedCreateWithoutPostsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutPostsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutPostsInput, TagUncheckedUpdateWithoutPostsInput>
  }

  export type TagUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contacts?: ContactTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contacts?: ContactTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type EducationPostCreateWithoutScamTypesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    title: string
    excerpt?: string | null
    bodyMd: string
    status?: $Enums.PostStatus
    publishedAt?: Date | string | null
    category: $Enums.PostCategory
    heroImageUrl?: string | null
    heroSvg?: string | null
    heroAlt?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    canonicalUrl?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    featured?: boolean
    authorName?: string | null
    sourceUrl?: string | null
    tags?: PostTagCreateNestedManyWithoutPostInput
  }

  export type EducationPostUncheckedCreateWithoutScamTypesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    slug: string
    title: string
    excerpt?: string | null
    bodyMd: string
    status?: $Enums.PostStatus
    publishedAt?: Date | string | null
    category: $Enums.PostCategory
    heroImageUrl?: string | null
    heroSvg?: string | null
    heroAlt?: string | null
    country?: string | null
    region?: string | null
    city?: string | null
    canonicalUrl?: string | null
    metaTitle?: string | null
    metaDescription?: string | null
    featured?: boolean
    authorName?: string | null
    sourceUrl?: string | null
    tags?: PostTagUncheckedCreateNestedManyWithoutPostInput
  }

  export type EducationPostCreateOrConnectWithoutScamTypesInput = {
    where: EducationPostWhereUniqueInput
    create: XOR<EducationPostCreateWithoutScamTypesInput, EducationPostUncheckedCreateWithoutScamTypesInput>
  }

  export type ScamTypeCreateWithoutPostLinksInput = {
    id?: string
    name: string
    createdAt?: Date | string
    createdBy?: string | null
    isApproved?: boolean
    isUserCreated?: boolean
    moderatedAt?: Date | string | null
    moderatedBy?: string | null
    contactLinks?: ContactScamTypeCreateNestedManyWithoutScamTypeInput
    reports?: ScamReportCreateNestedManyWithoutScamTypeInput
    severityRecords?: SeverityCreateNestedManyWithoutScamTypeInput
  }

  export type ScamTypeUncheckedCreateWithoutPostLinksInput = {
    id?: string
    name: string
    createdAt?: Date | string
    createdBy?: string | null
    isApproved?: boolean
    isUserCreated?: boolean
    moderatedAt?: Date | string | null
    moderatedBy?: string | null
    contactLinks?: ContactScamTypeUncheckedCreateNestedManyWithoutScamTypeInput
    reports?: ScamReportUncheckedCreateNestedManyWithoutScamTypeInput
    severityRecords?: SeverityUncheckedCreateNestedManyWithoutScamTypeInput
  }

  export type ScamTypeCreateOrConnectWithoutPostLinksInput = {
    where: ScamTypeWhereUniqueInput
    create: XOR<ScamTypeCreateWithoutPostLinksInput, ScamTypeUncheckedCreateWithoutPostLinksInput>
  }

  export type EducationPostUpsertWithoutScamTypesInput = {
    update: XOR<EducationPostUpdateWithoutScamTypesInput, EducationPostUncheckedUpdateWithoutScamTypesInput>
    create: XOR<EducationPostCreateWithoutScamTypesInput, EducationPostUncheckedCreateWithoutScamTypesInput>
    where?: EducationPostWhereInput
  }

  export type EducationPostUpdateToOneWithWhereWithoutScamTypesInput = {
    where?: EducationPostWhereInput
    data: XOR<EducationPostUpdateWithoutScamTypesInput, EducationPostUncheckedUpdateWithoutScamTypesInput>
  }

  export type EducationPostUpdateWithoutScamTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    bodyMd?: StringFieldUpdateOperationsInput | string
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPostCategoryFieldUpdateOperationsInput | $Enums.PostCategory
    heroImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    heroSvg?: NullableStringFieldUpdateOperationsInput | string | null
    heroAlt?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: PostTagUpdateManyWithoutPostNestedInput
  }

  export type EducationPostUncheckedUpdateWithoutScamTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    bodyMd?: StringFieldUpdateOperationsInput | string
    status?: EnumPostStatusFieldUpdateOperationsInput | $Enums.PostStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPostCategoryFieldUpdateOperationsInput | $Enums.PostCategory
    heroImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    heroSvg?: NullableStringFieldUpdateOperationsInput | string | null
    heroAlt?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    canonicalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: PostTagUncheckedUpdateManyWithoutPostNestedInput
  }

  export type ScamTypeUpsertWithoutPostLinksInput = {
    update: XOR<ScamTypeUpdateWithoutPostLinksInput, ScamTypeUncheckedUpdateWithoutPostLinksInput>
    create: XOR<ScamTypeCreateWithoutPostLinksInput, ScamTypeUncheckedCreateWithoutPostLinksInput>
    where?: ScamTypeWhereInput
  }

  export type ScamTypeUpdateToOneWithWhereWithoutPostLinksInput = {
    where?: ScamTypeWhereInput
    data: XOR<ScamTypeUpdateWithoutPostLinksInput, ScamTypeUncheckedUpdateWithoutPostLinksInput>
  }

  export type ScamTypeUpdateWithoutPostLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isUserCreated?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    contactLinks?: ContactScamTypeUpdateManyWithoutScamTypeNestedInput
    reports?: ScamReportUpdateManyWithoutScamTypeNestedInput
    severityRecords?: SeverityUpdateManyWithoutScamTypeNestedInput
  }

  export type ScamTypeUncheckedUpdateWithoutPostLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isUserCreated?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    contactLinks?: ContactScamTypeUncheckedUpdateManyWithoutScamTypeNestedInput
    reports?: ScamReportUncheckedUpdateManyWithoutScamTypeNestedInput
    severityRecords?: SeverityUncheckedUpdateManyWithoutScamTypeNestedInput
  }

  export type ContactScamTypeCreateWithoutContactInput = {
    scamType: ScamTypeCreateNestedOneWithoutContactLinksInput
  }

  export type ContactScamTypeUncheckedCreateWithoutContactInput = {
    scamTypeId: string
  }

  export type ContactScamTypeCreateOrConnectWithoutContactInput = {
    where: ContactScamTypeWhereUniqueInput
    create: XOR<ContactScamTypeCreateWithoutContactInput, ContactScamTypeUncheckedCreateWithoutContactInput>
  }

  export type ContactScamTypeCreateManyContactInputEnvelope = {
    data: ContactScamTypeCreateManyContactInput | ContactScamTypeCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type ContactTagCreateWithoutContactInput = {
    tag: TagCreateNestedOneWithoutContactsInput
  }

  export type ContactTagUncheckedCreateWithoutContactInput = {
    tagId: string
  }

  export type ContactTagCreateOrConnectWithoutContactInput = {
    where: ContactTagWhereUniqueInput
    create: XOR<ContactTagCreateWithoutContactInput, ContactTagUncheckedCreateWithoutContactInput>
  }

  export type ContactTagCreateManyContactInputEnvelope = {
    data: ContactTagCreateManyContactInput | ContactTagCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type ContactScamTypeUpsertWithWhereUniqueWithoutContactInput = {
    where: ContactScamTypeWhereUniqueInput
    update: XOR<ContactScamTypeUpdateWithoutContactInput, ContactScamTypeUncheckedUpdateWithoutContactInput>
    create: XOR<ContactScamTypeCreateWithoutContactInput, ContactScamTypeUncheckedCreateWithoutContactInput>
  }

  export type ContactScamTypeUpdateWithWhereUniqueWithoutContactInput = {
    where: ContactScamTypeWhereUniqueInput
    data: XOR<ContactScamTypeUpdateWithoutContactInput, ContactScamTypeUncheckedUpdateWithoutContactInput>
  }

  export type ContactScamTypeUpdateManyWithWhereWithoutContactInput = {
    where: ContactScamTypeScalarWhereInput
    data: XOR<ContactScamTypeUpdateManyMutationInput, ContactScamTypeUncheckedUpdateManyWithoutContactInput>
  }

  export type ContactTagUpsertWithWhereUniqueWithoutContactInput = {
    where: ContactTagWhereUniqueInput
    update: XOR<ContactTagUpdateWithoutContactInput, ContactTagUncheckedUpdateWithoutContactInput>
    create: XOR<ContactTagCreateWithoutContactInput, ContactTagUncheckedCreateWithoutContactInput>
  }

  export type ContactTagUpdateWithWhereUniqueWithoutContactInput = {
    where: ContactTagWhereUniqueInput
    data: XOR<ContactTagUpdateWithoutContactInput, ContactTagUncheckedUpdateWithoutContactInput>
  }

  export type ContactTagUpdateManyWithWhereWithoutContactInput = {
    where: ContactTagScalarWhereInput
    data: XOR<ContactTagUpdateManyMutationInput, ContactTagUncheckedUpdateManyWithoutContactInput>
  }

  export type ContactCreateWithoutScamTypesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orgName: string
    category: $Enums.ContactCategory
    description?: string | null
    website?: string | null
    phone?: string | null
    email?: string | null
    submitUrl?: string | null
    languageCodes?: ContactCreatelanguageCodesInput | string[]
    country?: string | null
    region?: string | null
    city?: string | null
    status?: $Enums.ContactStatus
    verified?: boolean
    source?: string | null
    lastVerifiedAt?: Date | string | null
    createdById?: string | null
    tags?: ContactTagCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutScamTypesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orgName: string
    category: $Enums.ContactCategory
    description?: string | null
    website?: string | null
    phone?: string | null
    email?: string | null
    submitUrl?: string | null
    languageCodes?: ContactCreatelanguageCodesInput | string[]
    country?: string | null
    region?: string | null
    city?: string | null
    status?: $Enums.ContactStatus
    verified?: boolean
    source?: string | null
    lastVerifiedAt?: Date | string | null
    createdById?: string | null
    tags?: ContactTagUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutScamTypesInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutScamTypesInput, ContactUncheckedCreateWithoutScamTypesInput>
  }

  export type ScamTypeCreateWithoutContactLinksInput = {
    id?: string
    name: string
    createdAt?: Date | string
    createdBy?: string | null
    isApproved?: boolean
    isUserCreated?: boolean
    moderatedAt?: Date | string | null
    moderatedBy?: string | null
    postLinks?: EducationPostScamTypeCreateNestedManyWithoutScamTypeInput
    reports?: ScamReportCreateNestedManyWithoutScamTypeInput
    severityRecords?: SeverityCreateNestedManyWithoutScamTypeInput
  }

  export type ScamTypeUncheckedCreateWithoutContactLinksInput = {
    id?: string
    name: string
    createdAt?: Date | string
    createdBy?: string | null
    isApproved?: boolean
    isUserCreated?: boolean
    moderatedAt?: Date | string | null
    moderatedBy?: string | null
    postLinks?: EducationPostScamTypeUncheckedCreateNestedManyWithoutScamTypeInput
    reports?: ScamReportUncheckedCreateNestedManyWithoutScamTypeInput
    severityRecords?: SeverityUncheckedCreateNestedManyWithoutScamTypeInput
  }

  export type ScamTypeCreateOrConnectWithoutContactLinksInput = {
    where: ScamTypeWhereUniqueInput
    create: XOR<ScamTypeCreateWithoutContactLinksInput, ScamTypeUncheckedCreateWithoutContactLinksInput>
  }

  export type ContactUpsertWithoutScamTypesInput = {
    update: XOR<ContactUpdateWithoutScamTypesInput, ContactUncheckedUpdateWithoutScamTypesInput>
    create: XOR<ContactCreateWithoutScamTypesInput, ContactUncheckedCreateWithoutScamTypesInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutScamTypesInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutScamTypesInput, ContactUncheckedUpdateWithoutScamTypesInput>
  }

  export type ContactUpdateWithoutScamTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orgName?: StringFieldUpdateOperationsInput | string
    category?: EnumContactCategoryFieldUpdateOperationsInput | $Enums.ContactCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    submitUrl?: NullableStringFieldUpdateOperationsInput | string | null
    languageCodes?: ContactUpdatelanguageCodesInput | string[]
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    verified?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    lastVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactTagUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutScamTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orgName?: StringFieldUpdateOperationsInput | string
    category?: EnumContactCategoryFieldUpdateOperationsInput | $Enums.ContactCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    submitUrl?: NullableStringFieldUpdateOperationsInput | string | null
    languageCodes?: ContactUpdatelanguageCodesInput | string[]
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    verified?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    lastVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ContactTagUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ScamTypeUpsertWithoutContactLinksInput = {
    update: XOR<ScamTypeUpdateWithoutContactLinksInput, ScamTypeUncheckedUpdateWithoutContactLinksInput>
    create: XOR<ScamTypeCreateWithoutContactLinksInput, ScamTypeUncheckedCreateWithoutContactLinksInput>
    where?: ScamTypeWhereInput
  }

  export type ScamTypeUpdateToOneWithWhereWithoutContactLinksInput = {
    where?: ScamTypeWhereInput
    data: XOR<ScamTypeUpdateWithoutContactLinksInput, ScamTypeUncheckedUpdateWithoutContactLinksInput>
  }

  export type ScamTypeUpdateWithoutContactLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isUserCreated?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    postLinks?: EducationPostScamTypeUpdateManyWithoutScamTypeNestedInput
    reports?: ScamReportUpdateManyWithoutScamTypeNestedInput
    severityRecords?: SeverityUpdateManyWithoutScamTypeNestedInput
  }

  export type ScamTypeUncheckedUpdateWithoutContactLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    isApproved?: BoolFieldUpdateOperationsInput | boolean
    isUserCreated?: BoolFieldUpdateOperationsInput | boolean
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    postLinks?: EducationPostScamTypeUncheckedUpdateManyWithoutScamTypeNestedInput
    reports?: ScamReportUncheckedUpdateManyWithoutScamTypeNestedInput
    severityRecords?: SeverityUncheckedUpdateManyWithoutScamTypeNestedInput
  }

  export type ContactCreateWithoutTagsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orgName: string
    category: $Enums.ContactCategory
    description?: string | null
    website?: string | null
    phone?: string | null
    email?: string | null
    submitUrl?: string | null
    languageCodes?: ContactCreatelanguageCodesInput | string[]
    country?: string | null
    region?: string | null
    city?: string | null
    status?: $Enums.ContactStatus
    verified?: boolean
    source?: string | null
    lastVerifiedAt?: Date | string | null
    createdById?: string | null
    scamTypes?: ContactScamTypeCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutTagsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orgName: string
    category: $Enums.ContactCategory
    description?: string | null
    website?: string | null
    phone?: string | null
    email?: string | null
    submitUrl?: string | null
    languageCodes?: ContactCreatelanguageCodesInput | string[]
    country?: string | null
    region?: string | null
    city?: string | null
    status?: $Enums.ContactStatus
    verified?: boolean
    source?: string | null
    lastVerifiedAt?: Date | string | null
    createdById?: string | null
    scamTypes?: ContactScamTypeUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutTagsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutTagsInput, ContactUncheckedCreateWithoutTagsInput>
  }

  export type TagCreateWithoutContactsInput = {
    id?: string
    name: string
    posts?: PostTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutContactsInput = {
    id?: string
    name: string
    posts?: PostTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutContactsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutContactsInput, TagUncheckedCreateWithoutContactsInput>
  }

  export type ContactUpsertWithoutTagsInput = {
    update: XOR<ContactUpdateWithoutTagsInput, ContactUncheckedUpdateWithoutTagsInput>
    create: XOR<ContactCreateWithoutTagsInput, ContactUncheckedCreateWithoutTagsInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutTagsInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutTagsInput, ContactUncheckedUpdateWithoutTagsInput>
  }

  export type ContactUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orgName?: StringFieldUpdateOperationsInput | string
    category?: EnumContactCategoryFieldUpdateOperationsInput | $Enums.ContactCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    submitUrl?: NullableStringFieldUpdateOperationsInput | string | null
    languageCodes?: ContactUpdatelanguageCodesInput | string[]
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    verified?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    lastVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    scamTypes?: ContactScamTypeUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orgName?: StringFieldUpdateOperationsInput | string
    category?: EnumContactCategoryFieldUpdateOperationsInput | $Enums.ContactCategory
    description?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    submitUrl?: NullableStringFieldUpdateOperationsInput | string | null
    languageCodes?: ContactUpdatelanguageCodesInput | string[]
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContactStatusFieldUpdateOperationsInput | $Enums.ContactStatus
    verified?: BoolFieldUpdateOperationsInput | boolean
    source?: NullableStringFieldUpdateOperationsInput | string | null
    lastVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    scamTypes?: ContactScamTypeUncheckedUpdateManyWithoutContactNestedInput
  }

  export type TagUpsertWithoutContactsInput = {
    update: XOR<TagUpdateWithoutContactsInput, TagUncheckedUpdateWithoutContactsInput>
    create: XOR<TagCreateWithoutContactsInput, TagUncheckedCreateWithoutContactsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutContactsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutContactsInput, TagUncheckedUpdateWithoutContactsInput>
  }

  export type TagUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    posts?: PostTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    posts?: PostTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type CommentCreateManyReportInput = {
    id?: string
    createdAt?: Date | string
    content: string
    parentId?: string | null
    userId?: string | null
  }

  export type FlagCreateManyReportInput = {
    id?: string
    createdAt?: Date | string
    userId: string
    reason?: string | null
  }

  export type VoteCreateManyReportInput = {
    id?: string
    userId: string
    voteType: string
  }

  export type CommentUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    parent?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
    user?: UserUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FlagUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutFlagsNestedInput
  }

  export type FlagUncheckedUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FlagUncheckedUpdateManyWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VoteUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    voteType?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutVotesNestedInput
  }

  export type VoteUncheckedUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    voteType?: StringFieldUpdateOperationsInput | string
  }

  export type VoteUncheckedUpdateManyWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    voteType?: StringFieldUpdateOperationsInput | string
  }

  export type CommentCreateManyParentInput = {
    id?: string
    createdAt?: Date | string
    content: string
    reportId: string
    userId?: string | null
  }

  export type CommentUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    replies?: CommentUpdateManyWithoutParentNestedInput
    report?: ScamReportUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactScamTypeCreateManyScamTypeInput = {
    contactId: string
  }

  export type EducationPostScamTypeCreateManyScamTypeInput = {
    postId: string
  }

  export type ScamReportCreateManyScamTypeInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    description: string
    scammerDetails?: NullableJsonNullValueInput | InputJsonValue
    city?: string | null
    country?: string | null
    region?: string | null
    ipHash?: string | null
    latitude?: number | null
    longitude?: number | null
    verified?: boolean
    trustScore?: number
    reportCount?: number
    reporterName?: string | null
    reporterEmail?: string | null
    anonymous?: boolean
    outcome?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: string | null
    evidence?: string | null
    source?: string | null
  }

  export type SeverityCreateManyScamTypeInput = {
    id?: string
    country?: string | null
    region?: string | null
    city?: string | null
    score: number
    level: string
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type ContactScamTypeUpdateWithoutScamTypeInput = {
    contact?: ContactUpdateOneRequiredWithoutScamTypesNestedInput
  }

  export type ContactScamTypeUncheckedUpdateWithoutScamTypeInput = {
    contactId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactScamTypeUncheckedUpdateManyWithoutScamTypeInput = {
    contactId?: StringFieldUpdateOperationsInput | string
  }

  export type EducationPostScamTypeUpdateWithoutScamTypeInput = {
    post?: EducationPostUpdateOneRequiredWithoutScamTypesNestedInput
  }

  export type EducationPostScamTypeUncheckedUpdateWithoutScamTypeInput = {
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type EducationPostScamTypeUncheckedUpdateManyWithoutScamTypeInput = {
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type ScamReportUpdateWithoutScamTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    scammerDetails?: NullableJsonNullValueInput | InputJsonValue
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    trustScore?: IntFieldUpdateOperationsInput | number
    reportCount?: IntFieldUpdateOperationsInput | number
    reporterName?: NullableStringFieldUpdateOperationsInput | string | null
    reporterEmail?: NullableStringFieldUpdateOperationsInput | string | null
    anonymous?: BoolFieldUpdateOperationsInput | boolean
    outcome?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUpdateManyWithoutReportNestedInput
    flags?: FlagUpdateManyWithoutReportNestedInput
    votes?: VoteUpdateManyWithoutReportNestedInput
  }

  export type ScamReportUncheckedUpdateWithoutScamTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    scammerDetails?: NullableJsonNullValueInput | InputJsonValue
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    trustScore?: IntFieldUpdateOperationsInput | number
    reportCount?: IntFieldUpdateOperationsInput | number
    reporterName?: NullableStringFieldUpdateOperationsInput | string | null
    reporterEmail?: NullableStringFieldUpdateOperationsInput | string | null
    anonymous?: BoolFieldUpdateOperationsInput | boolean
    outcome?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: CommentUncheckedUpdateManyWithoutReportNestedInput
    flags?: FlagUncheckedUpdateManyWithoutReportNestedInput
    votes?: VoteUncheckedUpdateManyWithoutReportNestedInput
  }

  export type ScamReportUncheckedUpdateManyWithoutScamTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    scammerDetails?: NullableJsonNullValueInput | InputJsonValue
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    ipHash?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    trustScore?: IntFieldUpdateOperationsInput | number
    reportCount?: IntFieldUpdateOperationsInput | number
    reporterName?: NullableStringFieldUpdateOperationsInput | string | null
    reporterEmail?: NullableStringFieldUpdateOperationsInput | string | null
    anonymous?: BoolFieldUpdateOperationsInput | boolean
    outcome?: NullableJsonNullValueInput | InputJsonValue
    screenshots?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SeverityUpdateWithoutScamTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeverityUncheckedUpdateWithoutScamTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeverityUncheckedUpdateManyWithoutScamTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    level?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    content: string
    reportId: string
    parentId?: string | null
  }

  export type FlagCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    reportId: string
    reason?: string | null
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: string
    data?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type VoteCreateManyUserInput = {
    id?: string
    reportId: string
    voteType: string
  }

  export type CommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    parent?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentNestedInput
    report?: ScamReportUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FlagUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    report?: ScamReportUpdateOneRequiredWithoutFlagsNestedInput
  }

  export type FlagUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FlagUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportId?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VoteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    voteType?: StringFieldUpdateOperationsInput | string
    report?: ScamReportUpdateOneRequiredWithoutVotesNestedInput
  }

  export type VoteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    voteType?: StringFieldUpdateOperationsInput | string
  }

  export type VoteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    voteType?: StringFieldUpdateOperationsInput | string
  }

  export type EducationPostScamTypeCreateManyPostInput = {
    scamTypeId: string
  }

  export type PostTagCreateManyPostInput = {
    tagId: string
  }

  export type EducationPostScamTypeUpdateWithoutPostInput = {
    scamType?: ScamTypeUpdateOneRequiredWithoutPostLinksNestedInput
  }

  export type EducationPostScamTypeUncheckedUpdateWithoutPostInput = {
    scamTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type EducationPostScamTypeUncheckedUpdateManyWithoutPostInput = {
    scamTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type PostTagUpdateWithoutPostInput = {
    tag?: TagUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostTagUncheckedUpdateWithoutPostInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type PostTagUncheckedUpdateManyWithoutPostInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactTagCreateManyTagInput = {
    contactId: string
  }

  export type PostTagCreateManyTagInput = {
    postId: string
  }

  export type ContactTagUpdateWithoutTagInput = {
    contact?: ContactUpdateOneRequiredWithoutTagsNestedInput
  }

  export type ContactTagUncheckedUpdateWithoutTagInput = {
    contactId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactTagUncheckedUpdateManyWithoutTagInput = {
    contactId?: StringFieldUpdateOperationsInput | string
  }

  export type PostTagUpdateWithoutTagInput = {
    post?: EducationPostUpdateOneRequiredWithoutTagsNestedInput
  }

  export type PostTagUncheckedUpdateWithoutTagInput = {
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type PostTagUncheckedUpdateManyWithoutTagInput = {
    postId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactScamTypeCreateManyContactInput = {
    scamTypeId: string
  }

  export type ContactTagCreateManyContactInput = {
    tagId: string
  }

  export type ContactScamTypeUpdateWithoutContactInput = {
    scamType?: ScamTypeUpdateOneRequiredWithoutContactLinksNestedInput
  }

  export type ContactScamTypeUncheckedUpdateWithoutContactInput = {
    scamTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactScamTypeUncheckedUpdateManyWithoutContactInput = {
    scamTypeId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactTagUpdateWithoutContactInput = {
    tag?: TagUpdateOneRequiredWithoutContactsNestedInput
  }

  export type ContactTagUncheckedUpdateWithoutContactInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactTagUncheckedUpdateManyWithoutContactInput = {
    tagId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}